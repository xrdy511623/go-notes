
---
使用泛型增强代码的复用性
---

# 1 背景

假设我们已经有了如下的函数，用于求取两个整数间的最大值。

```go
func MaxInt(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

现在，如果我们想要实现一个类似的函数，来求取两个浮点数的最大值，我们可能会像下面这样增加一个新的函数。

```go
func MaxFloat32(a, b float32) float32 {
    if a > b {
        return a
    }
    return b
}
```

不过，一旦我们进一步拓展需求，需要针对 int64、float64 等很多其它数值类型获取最大值，这种不断添加新函数的方式，
会导致代码中出现大量逻辑极为相似的函数。这不仅会使代码库变得臃肿不堪，还会极大地增加代码维护的成本。那么是否存在
一种方法，能够让我们避免重复编写逻辑相似的函数，而是在一个统一的函数里，就可以实现对所有数值类型求最大值的功能呢？


# 2 反射：如何动态操作任意类型的对象？

在 Go 1.18 版本之前，我们可以通过反射（reflection）机制，实现一个函数兼容多种不同的数据类型。反射使我们能够在
程序运行时操作任意类型的对象，例如灵活地调用对象的方法和访问它的属性。在用反射来实现支持多种类型的最大值函数之前，
我们先来了解下 Golang 中的反射机制。Golang 通过 reflect 包提供了强大的反射功能，这个包的核心能力在于将 
interface{} 类型的变量转换为反射类型对象 reflect.Type 和 reflect.Value。借助这两个反射类型对象，我们就可以
访问和操作真实对象的方法和属性。下面是 reflect 包和反射对象提供的三大核心功能。首先是对象类型转换功能。
我们可以通过 TypeOf 和 ValueOf 方法将 interface{} 类型的变量转换为反射类型对象 Type 和 Value。同样，
通过 Interface 方法，我们可以将 Value 对象转换回 interface{} 类型的变量。

```go
package main

import (
    "fmt"
    "reflect"
)

func main() {
    age := 18
    fmt.Println("type: ", reflect.TypeOf(age)) // 输出type:  int
    value := reflect.ValueOf(age)
    fmt.Println("value: ", value) // 输出value:  18

    fmt.Println(value.Interface().(int)) // 输出18
}
```

接下来是变量值的设置功能。代码示例如下，借助 reflect.Value 对象提供的以 Set 为前缀的方法（如代码中的 SetInt 方法），
我们能够对实际变量的值进行修改。同时，需要注意的是，只有当传入 ValueOf 方法的参数是变量的指针时，我们才能够通过
reflect.Value 来改变实际变量的值。

```go
package main

import (
    "fmt"
    "reflect"
)

func main() {
    age := 18
    // 通过reflect.ValueOf获取age中的reflect.Value
    // 参数必须是指针才能修改其值
    pointerValue := reflect.ValueOf(&age)
    // Elem和Set方法结合，相当于给指针指向的变量赋值*p=值
    newValue := pointerValue.Elem()
    newValue.SetInt(28) 
    fmt.Println(age) // 值被改变，输出28

    // reflect.ValueOf参数不是指针
    pointerValue = reflect.ValueOf(age)
    // 非指针，直接panic: reflect: call of reflect.Value.Elem on int Value
    newValue = pointerValue.Elem() 
}
```

最后是动态方法调用功能。如下面示例代码所示，利用 Value 对象提供的 MethodByName 或 Method 方法，我们能够获取
实际对象的特定方法，随后，通过 Call 方法，我们可以动态地调用该方法，并传递所需的参数。

```go
package main

import (
    "fmt"
    "reflect"
)

type User struct {
    Age int
}

func (u User) ReflectCallFunc(name string) {
    fmt.Printf("age %d ,name %+v\n", u.Age, name)
}

func main() {
    user := User{18}

    // 1. 通过reflect.ValueOf(interface)来获取到reflect.Value
    getValue := reflect.ValueOf(user)
    // 或者getValue.Method(0)
    methodValue := getValue.MethodByName("ReflectCallFunc")
    args := []reflect.Value{reflect.ValueOf("k哥")}
    // 2. 通过Call调用方法
    methodValue.Call(args) // 输出age 18 ,name k哥
}
```

在掌握了反射包 reflect 的基础知识后，我们就可以运用这个包来实现最大值函数了。下面代码是基于反射实现的这个函数。

```go
import (
    "errors"
    "reflect"
)

// Max 使用反射比较两个值（目前支持基本数字类型），返回较大的值以及可能的错误
func Max(a, b interface{}) (interface{}, error) {
    va := reflect.ValueOf(a)
    vb := reflect.ValueOf(b)

    // 检查类型是否一致且是支持的数字类型
    if va.Type() != vb.Type() {
        return nil, errors.New("a and b are not of equal type")
    }
    switch va.Kind() {
    case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
        if va.Int() > vb.Int() {
            return a, nil
        }
        return b, nil
    case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
        if va.Uint() > vb.Uint() {
            return a, nil
        }
        return b, nil
    case reflect.Float32, reflect.Float64:
        if va.Float() > vb.Float() {
            return a, nil
        }
        return b, nil
    default:
        return nil, errors.New("unsupported kind")
    }
}
```

它的核心逻辑是这样的。首先，我们通过 reflect.ValueOf 方法，获取 Value 类型的反射对象。紧接着，
我们利用 Value 对象的 Type 方法，分别获取变量 a 和 b 的类型，并进行对比。如果两者类型不同，
则抛出错误。随后，我们使用 Value 对象的 Kind 方法来识别变量的基础数据类型。Kind 方法返回
一个枚举值，它涵盖了 Golang 中所有可能的类型，包括 Bool、Int、Float64、String、Struct 等。
Kind 方法能够揭示一个值的底层类型，即使这个值被自定义类型所包装。例如，下面代码使用 TypeOf 函数
获取变量的类型信息，结果显示 myInt 的类型是 MyInt，而 Kind 方法获取的类型信息，结果显示的类型是 int。


```go
type MyInt int

func main() {
    var myInt MyInt = 42
    // 使用reflect.TypeOf()获取类型信息
    myIntType := reflect.TypeOf(myInt)
    // 使用reflect.ValueOf()获取值对象，并使用Kind()获取基础类型
    myIntValue := reflect.ValueOf(myInt)
    // 打印类型和基础类型
    fmt.Printf("Type of myInt: %s, Kind of myInt: %s\n", myIntType, myIntValue.Kind())
    // 输出 Type of myInt: main.MyInt, Kind of myInt: int
}
```

最后，基于 Kind 方法返回的不同类型，我们分别调用 Value 对象的 Int、Uint、Float 等方法来获取数值变量的实际数值，
并进行比较。通过这种方式，我们就实现了一个能够处理多种数值类型的最大值函数。尽管上面借助反射，我们成功实现了支持
多种数值类型的最大值函数，但反射的实现方式存在下面几个问题，我们也要特别留意。

## 2.1 反射存在的问题

### 2.1.1 类型安全问题

首先是类型安全问题。当我们向这个函数传入字符串时，编译阶段无法提前察觉错误，只有在程序运行调用这个函数时才会报错，
使得我们无法预先发现这类问题。你可以参考一下后面的示例代码。

```go
func TestMax(t *testing.T) {
    a := "aaa"
    b := "bbb"
    _, err := Max(a, b)
    if err != nil {
        panic(err)
    }
}
```

```shell
// 输出
Running tool: /usr/local/go/bin/go test -timeout 30s -run ^TestMax$ server-go/18/reflection
=== RUN   TestMax
--- FAIL: TestMax (0.00s)
panic: unsupported kind [recovered]
        panic: unsupported kind
```

### 2.1.2 性能问题

反射机制需要在运行时解析类型信息来执行操作，相较于直接的类型操作，这个过程会产生更高的性能开销。我们可以用下面的
Benchmark 脚本，来测试反射实现的最大值函数和普通最大值函数两者的性能差异。

```go
// MaxInt函数benchmark
func BenchmarkRegular(b *testing.B) {
    for i := 0; i < b.N; i++ {
        regular.MaxInt(1, 2)
    }
}

// 反射实现的最大值函数benchmark
func BenchmarkReflection(b *testing.B) {
    for i := 0; i < b.N; i++ {
        reflection.Max(1, 2)
    }
}
```

测试结果出来了，两者在性能上的差异显著。借助反射机制求取两个整型的最大值，单次操作耗时约 9.5 ns，
而采用常规方式，同样的操作仅需 0.3 ns，性能差距可达 30 倍之多。

```shell
killianxu@KILLIANXU-MB0 18 % go test -bench . -benchmem
goos: darwin
goarch: amd64
pkg: server-go/18
cpu: Intel(R) Core(TM) i5-7360U CPU @ 2.30GHz
BenchmarkRegular-4              1000000000               0.3005 ns/op          0 B/op          0 allocs/op
BenchmarkReflection-4           121113453                9.541 ns/op           0 B/op          0 allocs/op
```

### 2.1.3 代码可读性问题

在我们准备的案例中，常规的 MaxInt 函数仅需 6 行代码，简洁明了。然而，通过反射实现的 Max 函数，代码量激增到 20 多行，
而且大量运用反射相关方法，这无疑极大地增加了理解难度，使得代码的可读性大打折扣。为了避免反射的这些问题，Go 在 1.18 
版本引入了泛型特性。当我们需要根据不同类型执行差异化逻辑时，反射机制是一个不错的选择。然而，如果不同类型所对应的
实现逻辑一致，那么泛型便是更优的选择。


# 3 泛型：如何实现多种类型对象的逻辑复用？

泛型允许我们在编写代码时使用类型参数，从而使代码能够适用于多种不同类型，而无需为每种类型单独编写特定的实现。
在 Go 语言中，泛型主要是通过类型参数和类型约束来实现的。以支持 int 和 float32 两种类型的最大值函数为例，
我们可以通过下面的代码来实现。这里的 T 就是类型参数，而 int | float32 就是类型约束。

```go
// Max使用泛型来比较两个同类型的值（要求类型是可比较的），并返回较大的值
func Max[T int | float32](a, b T) T {
    if a > b {
        return a
    }
    return b
}
```

需要留意的是，Golang 的泛型机制在编译阶段，会基于传入的实际参数类型，实例化出具体的函数。以下面的代码为例，
若两次调用分别传入 int 和 float32 类型，编译时就会实例化出类似 MaxInt 和 MaxFloat32 这样的函数。然而，
若传入 string 类型，编译时便会报错，这样一来，我们就能提前察觉类型安全问题。

```go
var a int = 1
var b int =1
Max[int](a,b) // 实例化出类似MaxInt的函数

var a float32 = 0.1
var b float32 = 0.2
Max[float32](a,b) // 实例化出类似MaxFloat32的函数

var a string = "aa"
var b string = "bb"

// 我们的实现里，不支持string类型，因此编译会报错
// string does not satisfy int | float32 (string missing in int | float32)
Max[string](a,b)
```

当然，上述关于泛型函数的实现与使用，仅仅是一个简易示例。实际上，为了给开发者提供更多便利，Golang 还具备更为强大的功能。
比如上面的最大值函数，如果我们希望它能支持更多类型，那么我们可以参考下面代码的做法，将类型约束放在一个单独的
interface 定义中。这样一来，就能有效避免在函数定义内出现冗长的类型约束列表，从而成功实现一个可支持多种数值
类型的最大值函数。

```go
type Ordered interface {
        ~int | ~int8 | ~int16 | ~int32 | ~int64 |
                ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64 | ~uintptr |
                ~float32 | ~float64 
               
}

// Max使用泛型来比较两个同类型的值（要求类型是可比较的），并返回较大的值
func Max[T Ordered](a, b T) T {
    if a > b {
        return a
    }
    return b
}
```

再比如，在实际使用过程中，我们无需显式传入类型参数。Golang 编译器具备类型推断能力，它能够依据传入的
具体参数，自动推断出相应的类型参数。

```go
var a int = 1
var b int =1
// 显示传入int类型
Max[int](a,b)

// 不传入int类型，由Go编译器推断
Max(a,b)
```

那么，通过泛型实现的最大值函数，是否解决了反射存在的三个缺点呢？接下来，我们就逐一分析看看。首先是类型安全问题。
泛型在编译阶段，依据传入的具体类型进行实例化。这意味着，一旦存在类型方面的问题，在编译时便会被察觉，于是就有效
规避了运行时可能出现的类型安全隐患。

接着是性能问题。泛型减少了对大量反射方法的调用，所以在性能上更具优势。我们可以借助下面的 Benchmark 脚本进行测试。

```go
// 泛型实现的最大值函数benchmark
func BenchmarkGenerics(b *testing.B) {
    for i := 0; i < b.N; i++ {
        generics.Max(1, 2)
    }
}
```

测试结果出来了，采用泛型实现的函数，性能与常规类型的函数大致相当，然而，相较于使用反射实现的函数，它的性能高出几十倍。

```shell
go test -benchmem . -bench="^Bench"
goos: darwin
goarch: amd64
pkg: go-notes/goprincipleandpractise/generics/performance
cpu: Intel(R) Core(TM) i9-9880H CPU @ 2.30GHz
BenchmarkRegular-16             1000000000               0.2822 ns/op          0 B/op          0 allocs/op
BenchmarkReflection-16          142170075                8.185 ns/op           0 B/op          0 allocs/op
BenchmarkGenerics-16            1000000000               0.2350 ns/op          0 B/op          0 allocs/op
PASS
ok      go-notes/goprincipleandpractise/generics/performance 4.141s
```

最后是可读性问题。泛型的逻辑简明直观，它规避了很多反射方法的繁杂调用，显著提升了代码的可读性。


# 4 泛型进阶

## 4.1 内置约束：any与comparable

Go提供了两个内置的类型约束，使用频率极高：

- **any**：`interface{}`的别名，表示任意类型，不对类型做任何限制
- **comparable**：表示支持`==`和`!=`运算的类型，常用于map的key或需要判等的场景

```go
// any: 接受任意类型
func PrintSlice[T any](s []T) {
    for _, v := range s {
        fmt.Println(v)
    }
}

// comparable: 要求类型可判等，适用于map key或去重场景
func Contains[T comparable](s []T, target T) bool {
    for _, v := range s {
        if v == target {
            return true
        }
    }
    return false
}

func Unique[T comparable](s []T) []T {
    seen := make(map[T]bool)
    var result []T
    for _, v := range s {
        if !seen[v] {
            seen[v] = true
            result = append(result, v)
        }
    }
    return result
}
```

注意：切片、map、函数类型不满足comparable约束，因为它们不支持==比较。

## 4.2 泛型类型

泛型不仅可以用于函数，还可以用于定义类型。这在实现通用数据结构时尤为有用：

```go
// 泛型栈
type Stack[T any] struct {
    items []T
}

func (s *Stack[T]) Push(item T) {
    s.items = append(s.items, item)
}

func (s *Stack[T]) Pop() (T, bool) {
    var zero T
    if len(s.items) == 0 {
        return zero, false
    }
    item := s.items[len(s.items)-1]
    s.items = s.items[:len(s.items)-1]
    return item, true
}

func (s *Stack[T]) Len() int {
    return len(s.items)
}
```

使用方式：

```go
intStack := Stack[int]{}
intStack.Push(1)
intStack.Push(2)
val, _ := intStack.Pop() // val = 2

strStack := Stack[string]{}
strStack.Push("hello")
```

注意上面`Pop`方法中`var zero T`的用法——当需要返回泛型类型的零值时，声明一个该类型的变量即可获得零值。

## 4.3 多类型参数

一个泛型函数或类型可以有多个类型参数，类型参数之间用逗号分隔：

```go
// Map：将 []T 转换为 []U
func Map[T, U any](s []T, f func(T) U) []U {
    result := make([]U, len(s))
    for i, v := range s {
        result[i] = f(v)
    }
    return result
}

// 使用示例
names := []string{"alice", "bob", "charlie"}
lengths := Map(names, func(s string) int {
    return len(s)
})
// lengths = [5, 3, 7]
```

```go
// 泛型Pair，两个类型参数可以不同
type Pair[K comparable, V any] struct {
    Key   K
    Value V
}

func NewPair[K comparable, V any](k K, v V) Pair[K, V] {
    return Pair[K, V]{Key: k, Value: v}
}
```

## 4.4 约束中混合方法与类型集

接口约束不仅可以列举类型（类型集），还可以包含方法要求，两者可以混合使用：

```go
// 要求类型既是数值类型，又实现了String()方法
type FormattableNumber interface {
    ~int | ~float64
    String() string
}
```

更实用的例子——要求类型实现特定方法：

```go
type Sizer interface {
    Size() int
}

func SumSizes[T Sizer](items []T) int {
    total := 0
    for _, item := range items {
        total += item.Size()
    }
    return total
}
```

这种约束方式比反射更安全：如果传入的类型没有实现`Size()`方法，编译器会直接报错。


# 5 标准库中的泛型

Go 1.21引入了多个基于泛型的标准库包，极大地减少了日常开发中的样板代码。

## 5.1 slices包

`slices`包提供了针对切片的通用操作，替代了以前需要手写循环或使用`sort.Slice`的场景：

```go
import "slices"

nums := []int{3, 1, 4, 1, 5, 9}

// 排序
slices.Sort(nums)
// nums = [1, 1, 3, 4, 5, 9]

// 查找
idx, found := slices.BinarySearch(nums, 4)
// idx = 3, found = true

// 判断是否包含
slices.Contains(nums, 5) // true

// 去重（需先排序）
nums = slices.Compact(nums)
// nums = [1, 3, 4, 5, 9]

// 自定义排序
people := []string{"Charlie", "Alice", "Bob"}
slices.SortFunc(people, func(a, b string) int {
    return strings.Compare(a, b)
})
```

## 5.2 maps包

`maps`包提供了针对map的通用操作：

```go
import "maps"

m1 := map[string]int{"a": 1, "b": 2}
m2 := map[string]int{"a": 1, "b": 2}

// 判断两个map是否相等
maps.Equal(m1, m2) // true

// 获取所有key
keys := slices.Collect(maps.Keys(m1))

// 复制map
m3 := maps.Clone(m1)
```

## 5.3 cmp包与cmp.Ordered

`cmp`包提供了`Ordered`约束和比较函数，取代了自己定义Ordered接口的需要：

```go
import "cmp"

// cmp.Ordered 已包含所有可比较大小的内置类型
// 不再需要自己定义 type Ordered interface { ~int | ~float64 | ... }

func Max[T cmp.Ordered](a, b T) T {
    if a > b {
        return a
    }
    return b
}

// cmp.Compare 返回 -1, 0, 1
cmp.Compare(1, 2)       // -1
cmp.Compare("b", "a")   // 1

// cmp.Or 返回第一个非零值（类似于其他语言的 coalesce）
name := cmp.Or(userInput, envDefault, "fallback")
```

实际上，本文第3节中自定义的`Ordered`接口与`cmp.Ordered`功能一致。在实际工程中，应直接使用标准库的`cmp.Ordered`。


# 6 泛型的局限性

尽管泛型很强大，但Go的泛型实现有一些刻意的限制，了解这些限制有助于避免踩坑。

## 6.1 方法不能有类型参数

Go允许类型有类型参数，但方法不能引入新的类型参数：

```go
type Container[T any] struct {
    items []T
}

// 合法：方法使用类型定义时的类型参数T
func (c *Container[T]) Add(item T) {
    c.items = append(c.items, item)
}

// 非法：方法不能引入新的类型参数U
// func (c *Container[T]) Convert[U any](f func(T) U) []U { ... }
// 编译错误: method must have no type parameters
```

如果需要这种功能，应使用顶层泛型函数代替：

```go
// 用顶层函数替代
func Convert[T, U any](c *Container[T], f func(T) U) []U {
    result := make([]U, len(c.items))
    for i, item := range c.items {
        result[i] = f(item)
    }
    return result
}
```

## 6.2 类型推断的限制

类型推断并非万能，某些场景下编译器无法自动推断类型参数，需要显式指定：

```go
// 返回值类型无法从参数推断时，需要显式指定
func Zero[T any]() T {
    var zero T
    return zero
}

// 必须显式传入类型参数
n := Zero[int]()     // 0
s := Zero[string]()  // ""
```

## 6.3 不支持特化

Go不支持针对特定类型提供特殊实现（即模板特化），所有满足约束的类型共享相同的实现逻辑。
如果确实需要对不同类型执行不同逻辑，应使用接口多态或反射，而非泛型。


# 7 使用建议

泛型是一个强大的工具，但并非所有场景都适合使用。以下是一些实践建议：

**适合使用泛型的场景：**
- 通用数据结构（栈、队列、链表、树等）
- 通用算法（排序、过滤、映射、归约等）
- 多种类型共享完全相同的逻辑

**不适合使用泛型的场景：**
- 不同类型需要不同的处理逻辑 → 使用接口多态
- 只有一两种类型需要支持 → 直接写具体类型即可
- 为了"通用"而通用 → 过度设计，增加理解成本

**核心原则：** 如果使用泛型后代码变得更复杂而非更简单，那就不该使用泛型。泛型的目的是消除重复，而非展示技巧。