
---
使用泛型增强代码的复用性
---

# 1 背景

假设我们已经有了如下的函数，用于求取两个整数间的最大值。

```go
func MaxInt(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

现在，如果我们想要实现一个类似的函数，来求取两个浮点数的最大值，我们可能会像下面这样增加一个新的函数。

```go
func MaxFloat32(a, b float32) float32 {
    if a > b {
        return a
    }
    return b
}
```

不过，一旦我们进一步拓展需求，需要针对 int64、float64 等很多其它数值类型获取最大值，这种不断添加新函数的方式，
会导致代码中出现大量逻辑极为相似的函数。这不仅会使代码库变得臃肿不堪，还会极大地增加代码维护的成本。那么是否存在
一种方法，能够让我们避免重复编写逻辑相似的函数，而是在一个统一的函数里，就可以实现对所有数值类型求最大值的功能呢？


# 2 反射：如何动态操作任意类型的对象？

在 Go 1.18 版本之前，我们可以通过反射（reflection）机制，实现一个函数兼容多种不同的数据类型。反射使我们能够在
程序运行时操作任意类型的对象，例如灵活地调用对象的方法和访问它的属性。在用反射来实现支持多种类型的最大值函数之前，
我们先来了解下 Golang 中的反射机制。Golang 通过 reflect 包提供了强大的反射功能，这个包的核心能力在于将 
interface{} 类型的变量转换为反射类型对象 reflect.Type 和 reflect.Value。借助这两个反射类型对象，我们就可以
访问和操作真实对象的方法和属性。下面是 reflect 包和反射对象提供的三大核心功能。首先是对象类型转换功能。
我们可以通过 TypeOf 和 ValueOf 方法将 interface{} 类型的变量转换为反射类型对象 Type 和 Value。同样，
通过 Interface 方法，我们可以将 Value 对象转换回 interface{} 类型的变量。

```go
package main

import (
    "fmt"
    "reflect"
)

func main() {
    age := 18
    fmt.Println("type: ", reflect.TypeOf(age)) // 输出type:  int
    value := reflect.ValueOf(age)
    fmt.Println("value: ", value) // 输出value:  18

    fmt.Println(value.Interface().(int)) // 输出18
}
```

接下来是变量值的设置功能。代码示例如下，借助 reflect.Value 对象提供的以 Set 为前缀的方法（如代码中的 SetInt 方法），
我们能够对实际变量的值进行修改。同时，需要注意的是，只有当传入 ValueOf 方法的参数是变量的指针时，我们才能够通过
reflect.Value 来改变实际变量的值。

```go
package main

import (
    "fmt"
    "reflect"
)

func main() {
    age := 18
    // 通过reflect.ValueOf获取age中的reflect.Value
    // 参数必须是指针才能修改其值
    pointerValue := reflect.ValueOf(&age)
    // Elem和Set方法结合，相当于给指针指向的变量赋值*p=值
    newValue := pointerValue.Elem()
    newValue.SetInt(28) 
    fmt.Println(age) // 值被改变，输出28

    // reflect.ValueOf参数不是指针
    pointerValue = reflect.ValueOf(age)
    // 非指针，直接panic: reflect: call of reflect.Value.Elem on int Value
    newValue = pointerValue.Elem() 
}
```

最后是动态方法调用功能。如下面示例代码所示，利用 Value 对象提供的 MethodByName 或 Method 方法，我们能够获取
实际对象的特定方法，随后，通过 Call 方法，我们可以动态地调用该方法，并传递所需的参数。

```go
package main

import (
    "fmt"
    "reflect"
)

type User struct {
    Age int
}

func (u User) ReflectCallFunc(name string) {
    fmt.Printf("age %d ,name %+v\n", u.Age, name)
}

func main() {
    user := User{18}

    // 1. 通过reflect.ValueOf(interface)来获取到reflect.Value
    getValue := reflect.ValueOf(user)
    // 或者getValue.Method(0)
    methodValue := getValue.MethodByName("ReflectCallFunc")
    args := []reflect.Value{reflect.ValueOf("k哥")}
    // 2. 通过Call调用方法
    methodValue.Call(args) // 输出age 18 ,name k哥
}
```

在掌握了反射包 reflect 的基础知识后，我们就可以运用这个包来实现最大值函数了。下面代码是基于反射实现的这个函数。

```go
import (
    "errors"
    "reflect"
)

// Max 使用反射比较两个值（目前支持基本数字类型），返回较大的值以及可能的错误
func Max(a, b interface{}) (interface{}, error) {
    va := reflect.ValueOf(a)
    vb := reflect.ValueOf(b)

    // 检查类型是否一致且是支持的数字类型
    if va.Type() != vb.Type() {
        return nil, errors.New("a and b are not of equal type")
    }
    switch va.Kind() {
    case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
        if va.Int() > vb.Int() {
            return a, nil
        }
        return b, nil
    case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
        if va.Uint() > vb.Uint() {
            return a, nil
        }
        return b, nil
    case reflect.Float32, reflect.Float64:
        if va.Float() > vb.Float() {
            return a, nil
        }
        return b, nil
    default:
        return nil, errors.New("unsupported kind")
    }
}
```

它的核心逻辑是这样的。首先，我们通过 reflect.ValueOf 方法，获取 Value 类型的反射对象。紧接着，
我们利用 Value 对象的 Type 方法，分别获取变量 a 和 b 的类型，并进行对比。如果两者类型不同，
则抛出错误。随后，我们使用 Value 对象的 Kind 方法来识别变量的基础数据类型。Kind 方法返回
一个枚举值，它涵盖了 Golang 中所有可能的类型，包括 Bool、Int、Float64、String、Struct 等。
Kind 方法能够揭示一个值的底层类型，即使这个值被自定义类型所包装。例如，下面代码使用 TypeOf 函数
获取变量的类型信息，结果显示 myInt 的类型是 MyInt，而 Kind 方法获取的类型信息，结果显示的类型是 int。


```go
type MyInt int

func main() {
    var myInt MyInt = 42
    // 使用reflect.TypeOf()获取类型信息
    myIntType := reflect.TypeOf(myInt)
    // 使用reflect.ValueOf()获取值对象，并使用Kind()获取基础类型
    myIntValue := reflect.ValueOf(myInt)
    // 打印类型和基础类型
    fmt.Printf("Type of myInt: %s, Kind of myInt: %s\n", myIntType, myIntValue.Kind())
    // 输出 Type of myInt: main.MyInt, Kind of myInt: int
}
```

最后，基于 Kind 方法返回的不同类型，我们分别调用 Value 对象的 Int、Uint、Float 等方法来获取数值变量的实际数值，
并进行比较。通过这种方式，我们就实现了一个能够处理多种数值类型的最大值函数。尽管上面借助反射，我们成功实现了支持
多种数值类型的最大值函数，但反射的实现方式存在下面几个问题，我们也要特别留意。

## 2.1 反射存在的问题

### 2.1.1 类型安全问题

首先是类型安全问题。当我们向这个函数传入字符串时，编译阶段无法提前察觉错误，只有在程序运行调用这个函数时才会报错，
使得我们无法预先发现这类问题。你可以参考一下后面的示例代码。

```go
func TestMax(t *testing.T) {
    a := "aaa"
    b := "bbb"
    _, err := Max(a, b)
    if err != nil {
        panic(err)
    }
}
```

```shell
// 输出
Running tool: /usr/local/go/bin/go test -timeout 30s -run ^TestMax$ server-go/18/reflection
=== RUN   TestMax
--- FAIL: TestMax (0.00s)
panic: unsupported kind [recovered]
        panic: unsupported kind
```

### 2.1.2 性能问题

反射机制需要在运行时解析类型信息来执行操作，相较于直接的类型操作，这个过程会产生更高的性能开销。我们可以用下面的
Benchmark 脚本，来测试反射实现的最大值函数和普通最大值函数两者的性能差异。

```go
// MaxInt函数benchmark
func BenchmarkRegular(b *testing.B) {
    for i := 0; i < b.N; i++ {
        regular.MaxInt(1, 2)
    }
}

// 反射实现的最大值函数benchmark
func BenchmarkReflection(b *testing.B) {
    for i := 0; i < b.N; i++ {
        reflection.Max(1, 2)
    }
}
```

测试结果出来了，两者在性能上的差异显著。借助反射机制求取两个整型的最大值，单次操作耗时约 9.5 ns，
而采用常规方式，同样的操作仅需 0.3 ns，性能差距可达 30 倍之多。

```shell
killianxu@KILLIANXU-MB0 18 % go test -bench . -benchmem
goos: darwin
goarch: amd64
pkg: server-go/18
cpu: Intel(R) Core(TM) i5-7360U CPU @ 2.30GHz
BenchmarkRegular-4              1000000000               0.3005 ns/op          0 B/op          0 allocs/op
BenchmarkReflection-4           121113453                9.541 ns/op           0 B/op          0 allocs/op
```

### 2.1.3 代码可读性问题

在我们准备的案例中，常规的 MaxInt 函数仅需 6 行代码，简洁明了。然而，通过反射实现的 Max 函数，代码量激增到 20 多行，
而且大量运用反射相关方法，这无疑极大地增加了理解难度，使得代码的可读性大打折扣。为了避免反射的这些问题，Go 在 1.18 
版本引入了泛型特性。当我们需要根据不同类型执行差异化逻辑时，反射机制是一个不错的选择。然而，如果不同类型所对应的
实现逻辑一致，那么泛型便是更优的选择。


# 3 泛型：如何实现多种类型对象的逻辑复用？

泛型允许我们在编写代码时使用类型参数，从而使代码能够适用于多种不同类型，而无需为每种类型单独编写特定的实现。
在 Go 语言中，泛型主要是通过类型参数和类型约束来实现的。以支持 int 和 float32 两种类型的最大值函数为例，
我们可以通过下面的代码来实现。这里的 T 就是类型参数，而 int | float32 就是类型约束。

```go
// Max使用泛型来比较两个同类型的值（要求类型是可比较的），并返回较大的值
func Max[T int | float32](a, b T) T {
    if a > b {
        return a
    }
    return b
}
```

需要留意的是，Golang 的泛型机制在编译阶段，会基于传入的实际参数类型，实例化出具体的函数。以下面的代码为例，
若两次调用分别传入 int 和 float32 类型，编译时就会实例化出类似 MaxInt 和 MaxFloat32 这样的函数。然而，
若传入 string 类型，编译时便会报错，这样一来，我们就能提前察觉类型安全问题。

```go
var a int = 1
var b int =1
Max[int](a,b) // 实例化出类似MaxInt的函数

var a float32 = 0.1
var b float32 = 0.2
Max[float32](a,b) // 实例化出类似MaxFloat32的函数

var a string = "aa"
var b string = "bb"

// 我们的实现里，不支持string类型，因此编译会报错
// string does not satisfy int | float32 (string missing in int | float32)
Max[string](a,b)
```

当然，上述关于泛型函数的实现与使用，仅仅是一个简易示例。实际上，为了给开发者提供更多便利，Golang 还具备更为强大的功能。
比如上面的最大值函数，如果我们希望它能支持更多类型，那么我们可以参考下面代码的做法，将类型约束放在一个单独的
interface 定义中。这样一来，就能有效避免在函数定义内出现冗长的类型约束列表，从而成功实现一个可支持多种数值
类型的最大值函数。

```go
type Ordered interface {
        ~int | ~int8 | ~int16 | ~int32 | ~int64 |
                ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64 | ~uintptr |
                ~float32 | ~float64 
               
}

// Max使用泛型来比较两个同类型的值（要求类型是可比较的），并返回较大的值
func Max[T Ordered](a, b T) T {
    if a > b {
        return a
    }
    return b
}
```

再比如，在实际使用过程中，我们无需显式传入类型参数。Golang 编译器具备类型推断能力，它能够依据传入的
具体参数，自动推断出相应的类型参数。

```go
var a int = 1
var b int =1
// 显示传入int类型
Max[int](a,b)

// 不传入int类型，由Go编译器推断
Max(a,b)
```

那么，通过泛型实现的最大值函数，是否解决了反射存在的三个缺点呢？接下来，我们就逐一分析看看。首先是类型安全问题。
泛型在编译阶段，依据传入的具体类型进行实例化。这意味着，一旦存在类型方面的问题，在编译时便会被察觉，于是就有效
规避了运行时可能出现的类型安全隐患。

接着是性能问题。泛型减少了对大量反射方法的调用，所以在性能上更具优势。我们可以借助下面的 Benchmark 脚本进行测试。

```go
// 泛型实现的最大值函数benchmark
func BenchmarkGenerics(b *testing.B) {
    for i := 0; i < b.N; i++ {
        generics.Max(1, 2)
    }
}
```

测试结果出来了，采用泛型实现的函数，性能与常规类型的函数大致相当，然而，相较于使用反射实现的函数，它的性能高出几十倍。

```shell
go test -benchmem . -bench="^Bench"
goos: darwin
goarch: amd64
pkg: go-notes/goprincipleandpractise/generics/performance
cpu: Intel(R) Core(TM) i9-9880H CPU @ 2.30GHz
BenchmarkRegular-16             1000000000               0.2822 ns/op          0 B/op          0 allocs/op
BenchmarkReflection-16          142170075                8.185 ns/op           0 B/op          0 allocs/op
BenchmarkGenerics-16            1000000000               0.2350 ns/op          0 B/op          0 allocs/op
PASS
ok      go-notes/goprincipleandpractise/generics/performance 4.141s
```

最后是可读性问题。泛型的逻辑简明直观，它规避了很多反射方法的繁杂调用，显著提升了代码的可读性。


# 4 泛型进阶

## 4.1 内置约束：any与comparable

Go提供了两个内置的类型约束，使用频率极高：

- **any**：`interface{}`的别名，表示任意类型，不对类型做任何限制
- **comparable**：表示支持`==`和`!=`运算的类型，常用于map的key或需要判等的场景

```go
// any: 接受任意类型
func PrintSlice[T any](s []T) {
    for _, v := range s {
        fmt.Println(v)
    }
}

// comparable: 要求类型可判等，适用于map key或去重场景
func Contains[T comparable](s []T, target T) bool {
    for _, v := range s {
        if v == target {
            return true
        }
    }
    return false
}

func Unique[T comparable](s []T) []T {
    seen := make(map[T]bool)
    var result []T
    for _, v := range s {
        if !seen[v] {
            seen[v] = true
            result = append(result, v)
        }
    }
    return result
}
```

注意：切片、map、函数类型不满足comparable约束，因为它们不支持==比较。

## 4.2 泛型类型

泛型不仅可以用于函数，还可以用于定义类型。这在实现通用数据结构时尤为有用：

```go
// 泛型栈
type Stack[T any] struct {
    items []T
}

func (s *Stack[T]) Push(item T) {
    s.items = append(s.items, item)
}

func (s *Stack[T]) Pop() (T, bool) {
    var zero T
    if len(s.items) == 0 {
        return zero, false
    }
    item := s.items[len(s.items)-1]
    s.items = s.items[:len(s.items)-1]
    return item, true
}

func (s *Stack[T]) Len() int {
    return len(s.items)
}
```

使用方式：

```go
intStack := Stack[int]{}
intStack.Push(1)
intStack.Push(2)
val, _ := intStack.Pop() // val = 2

strStack := Stack[string]{}
strStack.Push("hello")
```

注意上面`Pop`方法中`var zero T`的用法——当需要返回泛型类型的零值时，声明一个该类型的变量即可获得零值。

## 4.3 多类型参数

一个泛型函数或类型可以有多个类型参数，类型参数之间用逗号分隔：

```go
// Map：将 []T 转换为 []U
func Map[T, U any](s []T, f func(T) U) []U {
    result := make([]U, len(s))
    for i, v := range s {
        result[i] = f(v)
    }
    return result
}

// 使用示例
names := []string{"alice", "bob", "charlie"}
lengths := Map(names, func(s string) int {
    return len(s)
})
// lengths = [5, 3, 7]
```

```go
// 泛型Pair，两个类型参数可以不同
type Pair[K comparable, V any] struct {
    Key   K
    Value V
}

func NewPair[K comparable, V any](k K, v V) Pair[K, V] {
    return Pair[K, V]{Key: k, Value: v}
}
```

## 4.4 约束中混合方法与类型集

接口约束不仅可以列举类型（类型集），还可以包含方法要求，两者可以混合使用：

```go
// 要求类型既是数值类型，又实现了String()方法
type FormattableNumber interface {
    ~int | ~float64
    String() string
}
```

更实用的例子——要求类型实现特定方法：

```go
type Sizer interface {
    Size() int
}

func SumSizes[T Sizer](items []T) int {
    total := 0
    for _, item := range items {
        total += item.Size()
    }
    return total
}
```

这种约束方式比反射更安全：如果传入的类型没有实现`Size()`方法，编译器会直接报错。


# 5 类型约束设计

类型约束是泛型的核心机制。设计好的约束能让泛型代码既灵活又安全，设计不当则会导致约束过松（运行时panic）或过紧（无法复用）。

## 5.1 `~T` 底层类型约束

`~T` 表示底层类型（underlying type）为 T 的所有类型，这是处理自定义类型的关键：

```go
// 不使用 ~：只接受 int 本身
type StrictInt interface {
    int
}

// 使用 ~：接受底层类型为 int 的所有类型
type FlexInt interface {
    ~int
}

type UserID int
type Score int

// StrictInt 不接受 UserID 和 Score，因为它们不是 int
// FlexInt 接受 UserID 和 Score，因为它们的底层类型是 int

func Double[T FlexInt](v T) T {
    return v * 2
}

var id UserID = 42
Double(id) // 合法，UserID 底层类型是 int
```

**设计原则：除非你有明确理由只接受原始类型，否则约束中应该始终使用 `~T` 而非 `T`。** 实际工程中，自定义类型（如 `type Money int64`）非常常见，不使用 `~` 会导致这些类型无法使用你的泛型函数。

## 5.2 约束组合：从小到大

好的约束设计应该像接口设计一样——小而专注，按需组合：

```go
// 基础约束：各自关注一个能力
type Ordered interface {
    ~int | ~int8 | ~int16 | ~int32 | ~int64 |
        ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64 |
        ~float32 | ~float64 | ~string
}

type Hashable interface {
    comparable
}

// 组合约束：通过嵌入组合多个约束
type OrderedHashable interface {
    Ordered
    comparable
}
```

这种组合方式的好处：
- **单一职责**：每个基础约束只描述一种能力
- **灵活复用**：函数按需选择最小约束
- **易于理解**：约束名自文档化

```go
// 只需要排序能力
func Sort[T Ordered](s []T) { /* ... */ }

// 需要排序 + 判等能力（如排序后去重）
func SortUnique[T OrderedHashable](s []T) []T { /* ... */ }

// 只需要判等能力
func Contains[T comparable](s []T, target T) bool { /* ... */ }
```

## 5.3 方法约束 vs 类型集约束

Go 的接口约束支持两种形式，适用场景不同：

```go
// 类型集约束：限定允许的具体类型
// 适用场景：需要使用运算符（+, -, *, <, > 等）
type Numeric interface {
    ~int | ~int64 | ~float64
}

func Sum[T Numeric](nums []T) T {
    var total T
    for _, n := range nums {
        total += n  // 需要 + 运算符，必须用类型集约束
    }
    return total
}

// 方法约束：要求类型实现特定方法
// 适用场景：通过方法操作类型，不关心底层类型
type Stringer interface {
    String() string
}

func JoinStrings[T Stringer](items []T) string {
    var parts []string
    for _, item := range items {
        parts = append(parts, item.String())
    }
    return strings.Join(parts, ", ")
}
```

**选择原则：**

| 场景 | 选择 | 原因 |
|------|------|------|
| 使用运算符（`+`, `-`, `<`, `>`, `==`） | 类型集约束 | 运算符只能通过类型集启用 |
| 调用方法 | 方法约束 | 更灵活，任何实现该方法的类型都可用 |
| 既要运算符又要方法 | 混合约束 | 两者可以在一个接口中组合 |

## 5.4 约束设计的常见错误

```go
// ❌ 约束过松：any 允许一切，但函数内部无法做任何有用的操作
func BadSort[T any](s []T) {
    // 无法比较：T 可能不支持 < 运算符
    // 编译错误！
}

// ❌ 约束过紧：列举了过多具体类型
type TooSpecific interface {
    int | int64  // 排除了 uint、float 等合理类型
}

// ✅ 约束恰到好处：使用标准库或社区公认的约束
func GoodSort[T cmp.Ordered](s []T) {
    slices.Sort(s)
}
```

**约束设计清单：**
1. 先问自己：函数体内需要对 T 做什么操作？
2. 需要运算符？→ 使用类型集约束
3. 需要调用方法？→ 使用方法约束
4. 标准库有现成约束？→ 优先使用（`cmp.Ordered`、`comparable`、`any`）
5. 是否使用了 `~`？→ 大多数情况都应该用


# 6 标准库中的泛型

Go 1.21引入了多个基于泛型的标准库包，极大地减少了日常开发中的样板代码。

## 6.1 slices包

`slices`包提供了针对切片的通用操作，替代了以前需要手写循环或使用`sort.Slice`的场景：

```go
import "slices"

nums := []int{3, 1, 4, 1, 5, 9}

// 排序
slices.Sort(nums)
// nums = [1, 1, 3, 4, 5, 9]

// 查找
idx, found := slices.BinarySearch(nums, 4)
// idx = 3, found = true

// 判断是否包含
slices.Contains(nums, 5) // true

// 去重（需先排序）
nums = slices.Compact(nums)
// nums = [1, 3, 4, 5, 9]

// 自定义排序
people := []string{"Charlie", "Alice", "Bob"}
slices.SortFunc(people, func(a, b string) int {
    return strings.Compare(a, b)
})
```

## 6.2 maps包

`maps`包提供了针对map的通用操作：

```go
import "maps"

m1 := map[string]int{"a": 1, "b": 2}
m2 := map[string]int{"a": 1, "b": 2}

// 判断两个map是否相等
maps.Equal(m1, m2) // true

// 获取所有key
keys := slices.Collect(maps.Keys(m1))

// 复制map
m3 := maps.Clone(m1)
```

## 6.3 cmp包与cmp.Ordered

`cmp`包提供了`Ordered`约束和比较函数，取代了自己定义Ordered接口的需要：

```go
import "cmp"

// cmp.Ordered 已包含所有可比较大小的内置类型
// 不再需要自己定义 type Ordered interface { ~int | ~float64 | ... }

func Max[T cmp.Ordered](a, b T) T {
    if a > b {
        return a
    }
    return b
}

// cmp.Compare 返回 -1, 0, 1
cmp.Compare(1, 2)       // -1
cmp.Compare("b", "a")   // 1

// cmp.Or 返回第一个非零值（类似于其他语言的 coalesce）
name := cmp.Or(userInput, envDefault, "fallback")
```

实际上，本文第3节中自定义的`Ordered`接口与`cmp.Ordered`功能一致。在实际工程中，应直接使用标准库的`cmp.Ordered`。


# 7 泛型的局限性

尽管泛型很强大，但Go的泛型实现有一些刻意的限制，了解这些限制有助于避免踩坑。

## 7.1 方法不能有类型参数

Go允许类型有类型参数，但方法不能引入新的类型参数：

```go
type Container[T any] struct {
    items []T
}

// 合法：方法使用类型定义时的类型参数T
func (c *Container[T]) Add(item T) {
    c.items = append(c.items, item)
}

// 非法：方法不能引入新的类型参数U
// func (c *Container[T]) Convert[U any](f func(T) U) []U { ... }
// 编译错误: method must have no type parameters
```

如果需要这种功能，应使用顶层泛型函数代替：

```go
// 用顶层函数替代
func Convert[T, U any](c *Container[T], f func(T) U) []U {
    result := make([]U, len(c.items))
    for i, item := range c.items {
        result[i] = f(item)
    }
    return result
}
```

## 7.2 类型推断的限制

类型推断并非万能，某些场景下编译器无法自动推断类型参数，需要显式指定：

```go
// 返回值类型无法从参数推断时，需要显式指定
func Zero[T any]() T {
    var zero T
    return zero
}

// 必须显式传入类型参数
n := Zero[int]()     // 0
s := Zero[string]()  // ""
```

## 7.3 不支持特化

Go不支持针对特定类型提供特殊实现（即模板特化），所有满足约束的类型共享相同的实现逻辑。
如果确实需要对不同类型执行不同逻辑，应使用接口多态或反射，而非泛型。

## 7.4 编译时开销

泛型并非"免费的午餐"。Go 编译器需要为泛型代码做额外工作，理解这些开销有助于做出更好的设计决策。

### Go 的泛型实现策略：GCShape stenciling + dictionaries

Go 并没有像 C++ 模板那样为每个具体类型生成完全独立的代码（完全单态化），也没有像 Java 那样完全依赖类型擦除。Go 采用了一种折中方案：**GCShape stenciling + dictionaries**（GC形状模板 + 字典）。

核心思路：
1. **GCShape 分组**：将所有具有相同内存布局（GC shape）的类型归为一组。例如，`int64`、`uint64`、所有指针类型各自为一组
2. **按组生成代码**：同一 GCShape 组内的类型共享一份生成的代码
3. **字典传递差异**：组内类型的差异（如方法调用）通过运行时传递的"字典"来处理

```
// 概念示意：编译器如何处理泛型函数
func Max[T cmp.Ordered](a, b T) T { ... }

// 调用 Max[int](1, 2) 和 Max[int64](1, 2)
// 因为 int 和 int64 可能 GCShape 不同，会生成两份代码

// 调用 Max[*User](a, b) 和 Max[*Order](a, b)
// 所有指针类型 GCShape 相同，共享一份代码 + 字典
```

### 编译时间影响

泛型对编译时间的影响主要体现在：

| 因素 | 影响程度 | 说明 |
|------|---------|------|
| 类型检查 | 低 | 约束检查在编译前端完成，开销可控 |
| 代码生成 | 中 | 每个 GCShape 组生成一份代码，组数通常不多 |
| 二进制大小 | 低-中 | 比完全单态化小，比类型擦除略大 |
| 大量类型实例化 | 中-高 | 若同一泛型函数被几十种不同 GCShape 的类型调用，编译和二进制都会膨胀 |

### 运行时性能特征

```
直接调用具体函数 ≈ 泛型调用（同 GCShape 首次）> 泛型调用（需查字典）>> 反射
```

实际测量（来自本项目 performance/ 目录的 benchmark）：
- **具体类型函数**：~0.28 ns/op（零开销）
- **泛型函数**：~0.24 ns/op（编译器优化后可能等同甚至更快）
- **反射函数**：~8.19 ns/op（约 30 倍慢）

对于值类型（int、float64 等），泛型几乎没有运行时开销。对于指针类型，可能有微小的字典查找开销，但在绝大多数场景中可忽略不计。

### 实践建议

1. **不要因为编译开销而回避泛型**——对于消除重复代码的场景，泛型的收益远大于编译开销
2. **避免"泛型爆炸"**——如果一个泛型函数被几十种完全不同布局的类型调用，考虑是否设计有问题
3. **热路径上的极致性能**——如果 benchmark 显示泛型版本比具体类型版本慢，可以为热路径提供具体类型的实现


# 8 泛型 vs 接口：何时选择哪个？

这是 Go 开发者最常见的困惑之一。泛型和接口都能实现"一份代码处理多种类型"，但它们的机制和适用场景完全不同。

## 8.1 核心区别

```
接口（interface）：运行时多态
  - 不同类型可以有不同的行为（方法实现不同）
  - 调用者不关心具体类型，只关心"能做什么"
  - 通过 vtable 实现动态分派

泛型（generics）：编译时多态
  - 不同类型共享完全相同的逻辑
  - 调用者需要指定具体类型
  - 编译时实例化为具体代码
```

一句话总结：**接口抽象行为，泛型抽象类型。**

## 8.2 决策矩阵

| 判断维度 | 选接口 | 选泛型 |
|---------|--------|--------|
| 不同类型的处理逻辑是否相同？ | 不同（各自实现方法） | 相同（只是类型不同） |
| 是否需要运算符（`+`, `-`, `<`）？ | 不适用 | 适用（接口无法启用运算符） |
| 是否需要返回与输入相同的类型？ | 困难（返回 interface） | 自然（`func F[T](x T) T`） |
| 是否需要类型安全的容器？ | 需要类型断言 | 编译时保证 |
| 是否需要在运行时替换实现？ | 适用（依赖注入） | 不适用 |
| 是否涉及 I/O 或外部依赖？ | 适用（方便 mock） | 不适用 |

## 8.3 典型场景对比

### 场景一：数据处理 → 选泛型

所有类型的处理逻辑完全一致，只是数据类型不同：

```go
// ✅ 泛型：逻辑对所有类型一致
func Filter[T any](s []T, pred func(T) bool) []T {
    var result []T
    for _, v := range s {
        if pred(v) {
            result = append(result, v)
        }
    }
    return result
}

// 使用：类型安全，零类型断言
ints := Filter([]int{1, 2, 3, 4}, func(n int) bool { return n > 2 })
strs := Filter([]string{"a", "bb", "ccc"}, func(s string) bool { return len(s) > 1 })
```

### 场景二：存储抽象 → 选接口

不同实现有不同的行为逻辑：

```go
// ✅ 接口：不同存储有完全不同的实现
type UserRepository interface {
    FindByID(ctx context.Context, id string) (*User, error)
    Save(ctx context.Context, user *User) error
}

// MySQL 实现：SQL 查询
type MySQLUserRepo struct { db *sql.DB }
func (r *MySQLUserRepo) FindByID(ctx context.Context, id string) (*User, error) {
    return r.db.QueryRowContext(ctx, "SELECT ...") // SQL
}

// Redis 实现：KV 查询
type RedisUserRepo struct { client *redis.Client }
func (r *RedisUserRepo) FindByID(ctx context.Context, id string) (*User, error) {
    return r.client.Get(ctx, "user:"+id) // Redis command
}

// ❌ 泛型不适合这个场景：不同存储的逻辑完全不同，无法共享
```

### 场景三：泛型 + 接口协作

很多实际场景需要两者配合：

```go
// 接口：定义行为
type Validator interface {
    Validate() error
}

// 泛型 + 接口约束：对所有实现了 Validator 的类型，执行相同的批量验证逻辑
func ValidateAll[T Validator](items []T) error {
    var errs []error
    for i, item := range items {
        if err := item.Validate(); err != nil {
            errs = append(errs, fmt.Errorf("item %d: %w", i, err))
        }
    }
    return errors.Join(errs...)
}

// 不同类型各自实现 Validate，但批量验证的逻辑是通用的
type User struct { Name, Email string }
func (u User) Validate() error { /* ... */ }

type Order struct { ID string; Amount float64 }
func (o Order) Validate() error { /* ... */ }

// 类型安全地使用
ValidateAll([]User{{Name: "alice"}})
ValidateAll([]Order{{ID: "001", Amount: 99.9}})
```

## 8.4 快速判断流程

```
需要处理多种类型？
├─ 不同类型逻辑不同？ → 接口
├─ 不同类型逻辑相同？
│  ├─ 需要运算符？ → 泛型（类型集约束）
│  ├─ 需要调用方法？ → 泛型 + 方法约束
│  └─ 只是容器/数据传递？ → 泛型（any 约束）
└─ 需要运行时替换实现？ → 接口（依赖注入）
```


# 9 使用建议

泛型是一个强大的工具，但并非所有场景都适合使用。以下是一些实践建议：

**适合使用泛型的场景：**
- 通用数据结构（栈、队列、链表、树等）
- 通用算法（排序、过滤、映射、归约等）
- 多种类型共享完全相同的逻辑
- 需要类型安全的容器，避免 `interface{}` + 类型断言
- 需要返回值类型与输入类型一致（`func F[T](x T) T`）

**不适合使用泛型的场景：**
- 不同类型需要不同的处理逻辑 → 使用接口多态
- 只有一两种类型需要支持 → 直接写具体类型即可
- 为了"通用"而通用 → 过度设计，增加理解成本
- 需要运行时动态替换实现 → 使用接口 + 依赖注入
- 涉及 I/O 或外部依赖的抽象 → 使用接口（方便 mock 和测试）

**约束设计原则：**
- 优先使用标准库约束：`any`、`comparable`、`cmp.Ordered`
- 约束中使用 `~T` 以支持自定义类型
- 约束应尽量小——函数需要什么能力，就约束什么能力
- 复杂约束拆分为多个小接口，按需组合

**核心原则：** 如果使用泛型后代码变得更复杂而非更简单，那就不该使用泛型。泛型的目的是消除重复，而非展示技巧。接口抽象行为，泛型抽象类型——两者是互补关系，不是替代关系。