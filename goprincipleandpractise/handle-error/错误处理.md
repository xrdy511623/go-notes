
---
错误处理
---

# 1 基础error

## 1.1 error接口
error是一种内建的接口类型，内建意味着不需要import任何包就可以直接使用，使用起来就像int、string一样自然。

```golang
type error interface {
    Error() string
}
```

error接口只声明了一个Error()方法，任何实现了该方法的结构体都可以作为error来使用。error的实例代表一种异常状态，
Error()方法用于描述该异常状态，值为nil的error代表没有异常。

标准库errors包中的errorString就是实现error接口的一个例子：

```golang
type errorString struct {
    s string
}

func (e *errorString) Error() string {
    return e.s
}
```

errorString是errors包的私有类型，对外不可见，只能通过对应的公开接口才可以创建errorString实例。

## 1.2 创建error

标准库提供了两种创建error的方法:
errors.New()
fmt.Errorf()


> errors.New()

errors.New()的实现极其简单，只是简单地构造一个errorString实例便返回：
```golang
func New(text string) error {
	return &errorString{text}
}
```

> fmt.Errorf()

errors.New()单调地接收一个字符串参数来构造error，而实际场景中往往需要使用fmt.Sprintf()生成字符串，这时可以直接使用fmt.Errorf()

```golang
package fmt

func Errorf(format string, a ...interface{}) error {
    return errors.New(Sprintf(format, a...))
} 
```

可以看到，fmt.Errorf()只是针对 errors.New()的简单封装，使用fmt.Errorf()可以使代码更简洁:

```golang
errStr := fmt.Sprintf("file not found, file name: %s", fileName)
err := errors.New(errStr)

//或
err := errors.New(fmt.Sprintf("file not found, file name: %s", fileName))

// 可以替换为:

err := fmt.Errorf("file not found, file name: %s", fileName)
```

总体而言，fmt.Errorf()适用于需要格式化输出错误字符串的场景，如果不需要格式化字符串，则建议直接使用errors.New().


## 1.3 自定义error

任何实现error接口的类型都可以称为error。比如标准库os中的PathError就是一个典型例子：

```golang
// PathError records an error and the operation and file path that caused it.
type PathError struct {
	Op   string
	Path string
	Err  error
}

func (e *PathError) Error() string { return e.Op + " " + e.Path + ": " + e.Err.Error() }
```

> 异常处理

针对error而言，异常处理包括如何检查错误、如何传递错误。

> 检查error

最常见的检查error的方式是与nil值进行比较：

```golang
if err != nil {
    // something went wrong
}
```

有时也会与一些预定义的error进行比较:

```golang
// 标准库os包中定义了一些常见的错误
ErrPermission = errors.New("permission denied")

if err == os.ErrPermission {
    // permission denied 
}
```

由于任何实现了error接口的类型均可以作为error来处理，所以往往也会使用类型断言来检查error:

```golang

func AssertError (err error) {
    if e, ok := err.(*os.PathError); ok {
        fmt.Printf("it`s an os.PathError, operation: %s, path: %s, msg: %v", e.Op, e.Path, e.Err)
    }
}
```

上面代码中的断言，如果err是os.PathError类型，则可以使用e来访问os.PathError中的成员。


> 传递error

在一个函数中收到一个error，往往需要附加一些上下文信息再把error继续向上层抛。
最常见的添加附加上下文信息的方法是使用fmt.Errorf():

```golang
if err != nil {
    return fmt.Errorf("decompress %v: %v", name, err)
}
```

这种方式抛出的error有一个糟糕的问题，那就是原error信息和附加的信息被糅合到一起了。比如下面的函数，就会把
os.ErrPermission 和附加信息糅合到一起:

```golang
func WriteFile(fileName string) error {
    if fileName == "a.txt" {
        return fmt.Errorf("write file error: %v", os.ErrPermission)
    }

    return nil
}
```

为了解决这个问题，我们可以自定义error类型，就像os.PathError那样，上下文信息与原error信息分开存放:

```golang
type PathError struct {
	Op   string    // 上下文
	Path string   // 上下文
	Err  error   //  原error
}

```

这样，对于一个os.PathError类型的error, 我们可以检测它到底是不是一个权限不足的错误:

```golang
if e, ok := err.(*os.PathError); ok && e.Err == os.ErrPermission {
    fmt.Println("permission denied")
}
```

在上面的例子中，使用fmt.Errorf()传递一个error最大的问题是原error信息和附加的信息被糅合到一起了，而使用自定义error又会有不得不使用
断言的烦恼。
Go 1.13很好地解决了上面的问题和烦恼，它提供了一个错误链传递和检查机制。


# 2 链式error

在Go 1.13以前，使用fmt.Errorf()传递捕获的error并为error增加上下文信息时，原error将和上下文信息混杂在一起，
这样便无法获取原始的error。为此Go 1.13引入了一套解决方案，本节称其为链式error，因为error在函数间传递时，上下文
信息好像链条一样把各个error连接起来。

Go 1.13中针对error的优化，主要有:
> 新的error类型 wrapError；
> 增强了fmt.Errorf()以便通过%w创建wrapError；
> 引入了errors.Unwrap()以便拆解wrapError；
> 引入了errors.Is()用于检查error链条中是否包含指定的错误值；
> 引入了errors.As()用于检查error链条中是否包含指定的错误类型。

## 2.1 wrapError

```golang
type wrapError struct {
	msg string
	err error
}

func (e *wrapError) Error() string {
	return e.msg
}

func (e *wrapError) Unwrap() error {
	return e.err
}
```

wrapError初看起来很像前面介绍的os.PathError，os.PathError通过os.PathError.Op和os.PathError.Path保存上下文信息，
而wrapError的msg成员则把原error和上下文保存到一起，通过err成员保存原始的error。

此处的wrapError与之前的errorString相比，还额外实现了Unwrap()接口，用于返回原始的error。

## 2.2 fmt.Errorf()

在Go 1.13中，fmt.Errorf()新增了格式动词%w(wrap)用于生成wrapError示例，并且兼容原有格式动词。其实现源码如下:

```golang

func Errorf(format string, a ...any) error {
	p := newPrinter()
	p.wrapErrs = true
    // 解析格式，如果发现%w动词并且提供了合法的error参数，则把error放到p.wrappedErr成员中
	p.doPrintf(format, a)
	s := string(p.buf)
	var err error
    // 没有%w动词, 生成基础error
	if p.wrappedErr == nil {
		err = errors.New(s)
	} else {
        // 有%w动词, 生成wrapError
		err = &wrapError{s, p.wrappedErr}
	}
	p.free()
	return err
}
```

fmt.Errorf()将根据格式动词来动态决定生成wrapError还是errorString。使用%v格式动词生成的error类型仍是errorString,
(没有实现Unwrap接口)。

而使用%w格式动词生成的error类型将自动变成wrapError(实现了Unwrap接口)。

如此，当error在函数间传递时，error之间好像被组织成一个链式结构，如下图所示:





![chain-error.png](images%2Fchain-error.png)





使用fmt.Errorf()生成wrapError有两个限制:
每次生成wrapError时只能使用一次%w动词（Go 1.13限制，Go 1.20已解除，详见第3节）；
%w动词只能匹配实现了error接口的参数。

```golang
permissionErr := errors.New("permission not allowed")
wrapErr := fmt.Errorf("some context: %w", permissionErr)
```

另外需要注意的是，虽然wrapError实现了Unwrap()接口，但由于error接口仍然只定义了一个Error()方法，所以使用
fmt.Errorf()生成的error，不能直接调用自身的Unwrap()接口获得原始error，而需要使用errors包中提供的Unwrap()
方法。


## 2.3 errors.Unwrap()

Unwrap()函数很形象地揭示了其作用，如果把error比作一件衣服，fmt.Errorf() (使用%w)就好比给error增加了一件外套，
而Unwrap()函数则是脱掉外套。

```golang
func Unwrap(err error) error {
    // 检查是否实现了Unwrap函数
	u, ok := err.(interface {
		Unwrap() error
	})
    // 没有实现Unwrap函数，不支持Unwrap
	if !ok {
		return nil
	}
	return u.Unwrap()
}
```

如果参数err没有实现Unwrap()函数，则说明是基础error，直接返回nil，否则调用原err实现的Unwrap()函数并返回。

对于自定义的error类型，在实现Error()函数的基础上，需要额外实现Unwrap函数，可以升级成链式error，如os.PathError

```golang
type PathError struct {
	Op   string
	Path string
	Err  error
}

func (e *PathError) Error() string { return e.Op + " " + e.Path + ": " + e.Err.Error() }

func (e *PathError) Unwrap() error { return e.Err }
```

使用Unwrap获取原始error并进行比较的例子如下:

```golang
func ExampleUnwrap() {
    err := fmt.Errorf("write file error:%w", os.ErrPermission)
    if errors.Unwrap(err) == os.ErrPermission {
        fmt.Println("permission denied")
    }
    // Output:
    // permission denied
}
```

在上面的例子中原始的error(os.ErrPermission)只被包裹了一层，我们可以使用Unwrap()函数获取原始的error。在实际的
应用中，原始的error可能在层层的函数调用中被包裹了多层，那该怎么判断呢？

对此，我们可以循环调用Unwrap()函数来逐层检查，但是这样太过繁琐，errors包的Is()方法对此提供了更好的支持。


## 2.4 errors.Is()

errors.Is()用于检查特定的error链条中是否包含指定的error值(target)。
其实现逻辑是: errors.Is()逐层拆解参数err并与参数target对比，如果发现相等则返回true，否则返回false。对于自定义
error类型来说，如果实现了自己的Is()方法，则此处在比较时会先调用自身的Is()方法。


```golang
func ExampleIs() {
    err1 := fmt.Errorf("write file error:%w", os.ErrPermission)
    err2 := fmt.Errorf("write file error:%w", err1)
    if errors.Is(err2, os.ErrPermission)  {
        fmt.Println("permission denied")
    }
    // Output:
    // permission denied
}
```

## 2.5 errors.As()

errors.As() 用于从一个error链中查找是否有指定的类型出现，如有，则把error转换成该类型。
其实现逻辑与Is()的实现非常类似，As()会逐层拆解error链并尝试匹配指定类型，如果类型匹配，则将err值写入参数
target。同时，如果error实现了As()函数，那么也会尝试调用自身的As()函数。

```golang
func ExampleAs() {
    // 模拟一个被包装的 PathError
    originalErr := &os.PathError{Op: "open", Path: "/etc/passwd", Err: os.ErrPermission}
    wrappedErr := fmt.Errorf("failed to read config: %w", originalErr)

    // 使用 errors.As() 从 error 链中提取 *os.PathError
    var pathErr *os.PathError
    if errors.As(wrappedErr, &pathErr) {
        fmt.Println("Op:", pathErr.Op)
        fmt.Println("Path:", pathErr.Path)
        fmt.Println("Err:", pathErr.Err)
    }
    // Output:
    // Op: open
    // Path: /etc/passwd
    // Err: permission denied
}
```

errors.As()与类型断言的区别在于：类型断言只能检查error本身的类型，而errors.As()会沿着整个error链逐层查找，
即使目标类型被包装了多层也能正确匹配。

## 2.6 工程迁移

细心的读者也许会发现，几乎每个版本的Release Notes中都有一句话:
"We expect almost all Go programs to continue to compile and run as before"。

Go语言的每个版本都严格遵循兼容性规则，在Go 1时代，每个小版本发布都会兼容旧版本的程序。对于Go 1.13引入的error
优化来讲也不例外，使用老版本Go语言开发的程序(下称旧工程)，仍然可以编译并运行，并且行为依旧。如果想要链式error，
那么仍需要对旧工程做一些适当的适配。

适配无非从以下几个场景入手:
> 创建error时，fmt.Errorf()格式化动词由%v改为%w；
> 等值(==)检查可以使用errors.Is()替代；
> error类型断言可以使用errors.As()替代(注意:类型断言替换成errors.As()时需要先声明一个目标类型的指针变量)；
> 自定义类型额外实现Unwrap()方法；
> 自定义类型额外实现As()方法(可选)；
> 自定义类型额外实现Is()方法(可选)；

在实际场景中，几乎不需要实现As()和Is()这两个接口，我们可以根据自身需要决定是否需要实现。


# 3 多错误包装（Go 1.20）

Go 1.13引入的%w动词每次只能包装一个error。在实际工程中，一个操作可能同时产生多个错误，例如并发任务的错误收集、
多项校验的批量失败等。Go 1.20对此进行了增强，主要体现在两方面：

## 3.1 errors.Join

errors.Join()接收多个error参数，返回一个包含所有非nil error的聚合error。如果所有参数均为nil，则返回nil。

```golang
func ExampleJoin() {
    err1 := errors.New("file not found")
    err2 := errors.New("permission denied")
    err3 := errors.New("disk full")

    err := errors.Join(err1, err2, err3)
    fmt.Println(err)
    // Output:
    // file not found
    // permission denied
    // disk full
}
```

errors.Join()返回的error实现了`Unwrap() []error`接口（注意返回的是切片），errors.Is()和errors.As()
均能正确遍历其中的每一个error：

```golang
func ExampleJoinIs() {
    err1 := errors.New("file not found")
    err2 := os.ErrPermission

    joined := errors.Join(err1, err2)

    fmt.Println(errors.Is(joined, os.ErrPermission)) // true
    fmt.Println(errors.Is(joined, err1))              // true
    // Output:
    // true
    // true
}
```

errors.Join()在并发场景下尤为实用：

```golang
func validateAll(fields []Field) error {
    var errs []error
    for _, f := range fields {
        if err := f.Validate(); err != nil {
            errs = append(errs, err)
        }
    }
    return errors.Join(errs...)
}
```

## 3.2 多%w动词

Go 1.20同时解除了fmt.Errorf()中只能使用一次%w的限制，现在可以在一次调用中使用多个%w同时包装多个error：

```golang
func ExampleMultiWrap() {
    err1 := errors.New("network timeout")
    err2 := errors.New("context canceled")

    err := fmt.Errorf("operation failed: %w, %w", err1, err2)
    fmt.Println(errors.Is(err, err1)) // true
    fmt.Println(errors.Is(err, err2)) // true
    // Output:
    // true
    // true
}
```

使用多%w时，fmt.Errorf()返回的error同样实现了`Unwrap() []error`接口，errors.Is()和errors.As()能正确匹配
其中的任意一个error。

## 3.3 errors.Join vs 多%w

两者的选择取决于是否需要附加上下文信息：

| 场景 | 推荐方式 |
|------|---------|
| 纯粹聚合多个error，无需额外描述 | `errors.Join(err1, err2)` |
| 聚合的同时需要添加上下文 | `fmt.Errorf("操作失败: %w, %w", err1, err2)` |
| 循环中收集错误 | `errors.Join(errs...)` |


# 4 panic与recover

## 4.1 panic

panic是Go的内建函数，用于触发运行时恐慌。当panic被调用时，当前函数的正常执行流程立即终止，已注册的defer函数
会按LIFO顺序执行，然后panic沿调用栈向上传播，直到程序崩溃并打印堆栈信息。

**常见触发场景：**

```golang
// 1. 显式调用
panic("something went terribly wrong")

// 2. 运行时错误自动触发
var s []int
_ = s[10]  // index out of range → panic

var m map[string]int
m["key"] = 1  // assignment to nil map → panic

var p *int
_ = *p  // nil pointer dereference → panic
```

## 4.2 recover

recover是与panic配对使用的内建函数，**只能在defer函数中调用**。它用于捕获panic的值并恢复正常执行流程。
在defer函数之外调用recover始终返回nil。

```golang
func safeDiv(a, b int) (result int, err error) {
    defer func() {
        if r := recover(); r != nil {
            err = fmt.Errorf("recovered panic: %v", r)
        }
    }()
    return a / b, nil
}

func main() {
    result, err := safeDiv(10, 0)
    if err != nil {
        fmt.Println(err) // recovered panic: runtime error: integer divide by zero
    }
    fmt.Println(result) // 0
}
```

**recover的工作原理：**
- recover()捕获panic的值并终止panic的传播
- 包含recover的defer函数正常返回后，调用panic的函数也正常返回（而非继续崩溃）
- recover只能捕获当前goroutine的panic，无法跨goroutine捕获

## 4.3 panic vs error

Go推崇使用error进行错误处理，panic应仅用于真正不可恢复的异常情况。

**使用error的场景（绝大多数情况）：**
- 文件不存在、网络超时、权限不足等可预期的失败
- 用户输入校验失败
- 业务逻辑中的异常分支

**使用panic的场景（极少数情况）：**
- 程序初始化阶段的致命错误（如配置缺失、数据库连接失败）
- 不可能到达的代码路径（表示程序有bug）
- 标准库中某些"Must"系列函数（如`regexp.MustCompile`、`template.Must`）

```golang
// Must模式：将error转化为panic，适用于初始化阶段
func MustCompileRegex(pattern string) *regexp.Regexp {
    re, err := regexp.Compile(pattern)
    if err != nil {
        panic(fmt.Sprintf("invalid regex %q: %v", pattern, err))
    }
    return re
}

// 在init或全局变量中使用
var emailRegex = MustCompileRegex(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`)
```

**服务端recover的典型用法：** 在HTTP服务器等长期运行的程序中，通常在顶层使用recover防止单个请求的panic导致
整个服务崩溃：

```golang
func recoveryMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        defer func() {
            if err := recover(); err != nil {
                log.Printf("panic recovered: %v\n%s", err, debug.Stack())
                http.Error(w, "Internal Server Error", http.StatusInternalServerError)
            }
        }()
        next.ServeHTTP(w, r)
    })
}
```


# 5 错误处理最佳实践

## 5.1 哨兵error命名规范

预定义的哨兵error（sentinel error）应以`Err`为前缀，使用`errors.New()`创建，作为包级变量导出：

```golang
var (
    ErrNotFound     = errors.New("not found")
    ErrUnauthorized = errors.New("unauthorized")
    ErrTimeout      = errors.New("operation timed out")
)
```

## 5.2 何时用哨兵error vs 自定义类型 vs %w包装

| 方式 | 适用场景 | 示例 |
|------|---------|------|
| 哨兵error | 调用方只需判断错误种类，不需要额外信息 | `io.EOF`、`sql.ErrNoRows` |
| 自定义error类型 | 调用方需要从error中提取结构化信息 | `*os.PathError`、`*net.OpError` |
| %w包装 | 为底层error添加上下文，保留原始error可追溯 | `fmt.Errorf("查询用户失败: %w", err)` |

## 5.3 层级策略

错误处理的核心原则是：**底层包装，顶层处理**。

```
┌──────────────┐
│   顶层(main)  │  ← 记录日志 / 返回HTTP响应 / 终止程序
├──────────────┤
│   业务层      │  ← fmt.Errorf("业务上下文: %w", err) 向上传递
├──────────────┤
│   数据层      │  ← fmt.Errorf("查询失败: %w", err) 向上传递
├──────────────┤
│   基础设施    │  ← 产生原始error
└──────────────┘
```

- **底层函数**：使用%w包装error并附加上下文信息，然后return
- **中间层**：继续包装，添加本层的上下文信息
- **顶层**：统一处理error（记录日志、返回响应等）

## 5.4 避免log-and-return反模式

一个error应该只在一个地方被处理（记录日志或返回给调用方），不要两者都做：

```golang
// 反模式：log-and-return，导致同一个错误在日志中重复出现
func bad(id string) error {
    result, err := queryDB(id)
    if err != nil {
        log.Printf("query failed: %v", err) // 记录了一次
        return fmt.Errorf("query failed: %w", err) // 调用方可能再记录一次
    }
    // ...
}

// 正确：只包装并返回，由顶层统一记录日志
func good(id string) error {
    result, err := queryDB(id)
    if err != nil {
        return fmt.Errorf("query user %s: %w", id, err)
    }
    // ...
}
```

## 5.5 error处理清单

- 始终检查error返回值，不要使用`_`忽略
- 使用%w包装error以保留error链
- 包装时添加有意义的上下文（哪个操作、哪个参数失败了）
- 不要在每一层都记录日志，只在最终处理点记录
- 优先使用errors.Is()和errors.As()，而非==比较和类型断言
- 使用panic仅限于不可恢复的程序错误，业务逻辑一律使用error