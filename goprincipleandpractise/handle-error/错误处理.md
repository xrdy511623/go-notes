
---
错误处理
---

# 1 基础error

## 1.1 error接口
error是一种内建的接口类型，内建意味着不需要import任何包就可以直接使用，使用起来就像int、string一样自然。

```golang
type error interface {
    Error() string
}
```

error接口只声明了一个Error()方法，任何实现了该方法的结构体都可以作为error来使用。error的实例代表一种异常状态，
Error()方法用于描述该异常状态，值为nil的error代表没有异常。

标准库errors包中的errorString就是实现error接口的一个例子：

```golang
type errorString struct {
    s string
}

func (e *errorString) Error() string {
    return e.s
}
```

errorString是errors包的私有类型，对外不可见，只能通过对应的公开接口才可以创建errorString实例。

## 1.2 创建error

标准库提供了两种创建error的方法:
errors.New()
fmt.Errorf()


> errors.New()

errors.New()的实现极其简单，只是简单地构造一个errorString实例便返回：
```golang
func New(text string) error {
	return &errorString{text}
}
```

> fmt.Errorf()

errors.New()单调地接收一个字符串参数来构造error，而实际场景中往往需要使用fmt.Sprintf()生成字符串，这时可以直接使用fmt.Errorf()

```golang
package fmt

func Errorf(format string, a ...interface{}) error {
    return errors.New(Sprintf(format, a...))
} 
```

可以看到，fmt.Errorf()只是针对 errors.New()的简单封装，使用fmt.Errorf()可以使代码更简洁:

```golang
errStr := fmt.Sprintf("file not found, file name: %s", fileName)
err := errors.New(errStr)

//或
err := errors.New(fmt.Sprintf("file not found, file name: %s", fileName))

// 可以替换为:

err := fmt.Errorf("file not found, file name: %s", fileName)
```

总体而言，fmt.Errorf()适用于需要格式化输出错误字符串的场景，如果不需要格式化字符串，则建议直接使用errors.New().


## 1.3 自定义error

任何实现error接口的类型都可以称为error。比如标准库os中的PathError就是一个典型例子：

```golang
// PathError records an error and the operation and file path that caused it.
type PathError struct {
	Op   string
	Path string
	Err  error
}

func (e *PathError) Error() string { return e.Op + " " + e.Path + ": " + e.Err.Error() }
```

> 异常处理

针对error而言，异常处理包括如何检查错误、如何传递错误。

> 检查error

最常见的检查error的方式是与nil值进行比较：

```golang
if err != nil {
    // something went wrong
}
```

有时也会与一些预定义的error进行比较:

```golang
// 标准库os包中定义了一些常见的错误
ErrPermission = errors.New("permission denied")

if err == os.ErrPermission {
    // permission denied 
}
```

由于任何实现了error接口的类型均可以作为error来处理，所以往往也会使用类型断言来检查error:

```golang

func AssertError (err error) {
    if e, ok := err.(*os.PathError); ok {
        fmt.Printf("it`s an os.PathError, operation: %s, path: %s, msg: %v", e.Op, e.Path, e.Err)
    }
}
```

上面代码中的断言，如果err是os.PathError类型，则可以使用e来访问os.PathError中的成员。


> 传递error

在一个函数中收到一个error，往往需要附加一些上下文信息再把error继续向上层抛。
最常见的添加附加上下文信息的方法是使用fmt.Errorf():

```golang
if err != nil {
    return fmt.Errorf("decompress %v: %v", name, err)
}
```

这种方式抛出的error有一个糟糕的问题，那就是原error信息和附加的信息被糅合到一起了。比如下面的函数，就会把
os.ErrPermission 和附加信息糅合到一起:

```golang
func WriteFile(fileName string) error {
    if fileName == "a.txt" {
        return fmt.Errorf("write file error: %v", os.ErrPermission)
    }

    return nil
}
```

为了解决这个问题，我们可以自定义error类型，就像os.PathError那样，上下文信息与原error信息分开存放:

```golang
type PathError struct {
	Op   string    // 上下文
	Path string   // 上下文
	Err  error   //  原error
}

```

这样，对于一个os.PathError类型的error, 我们可以检测它到底是不是一个权限不足的错误:

```golang
if e, ok := err.(*os.PathError); ok && e.Err == os.ErrPermission {
    fmt.Println("permission denied")
}
```

在上面的例子中，使用fmt.Errorf()传递一个error最大的问题是原error信息和附加的信息被糅合到一起了，而使用自定义error又会有不得不使用
断言的烦恼。
Go 1.13很好地解决了上面的问题和烦恼，它提供了一个错误链传递和检查机制。


# 2 链式error

在Go 1.13以前，使用fmt.Errorf()传递捕获的error并为error增加上下文信息时，原error将和上下文信息混杂在一起，
这样便无法获取原始的error。为此Go 1.13引入了一套解决方案，本节称其为链式error，因为error在函数间传递时，上下文
信息好像链条一样把各个error连接起来。

Go 1.13中针对error的优化，主要有:
> 新的error类型 wrapError；
> 增强了fmt.Errorf()以便通过%w创建wrapError；
> 引入了errors.Unwrap()以便拆解wrapError；
> 引入了errors.Is()用于检查error链条中是否包含指定的错误值；
> 引入了errors.As()用于检查error链条中是否包含指定的错误类型。

## 2.1 wrapError

```golang
type wrapError struct {
	msg string
	err error
}

func (e *wrapError) Error() string {
	return e.msg
}

func (e *wrapError) Unwrap() error {
	return e.err
}
```

wrapError初看起来很像前面介绍的os.PathError，os.PathError通过os.PathError.Op和os.PathError.Path保存上下文信息，
而wrapError的msg成员则把原error和上下文保存到一起，通过err成员保存原始的error。

此处的wrapError与之前的errorString相比，还额外实现了Unwrap()接口，用于返回原始的error。

## 2.2 fmt.Errorf()

在Go 1.13中，fmt.Errorf()新增了格式动词%w(wrap)用于生成wrapError示例，并且兼容原有格式动词。其实现源码如下:

```golang

func Errorf(format string, a ...any) error {
	p := newPrinter()
	p.wrapErrs = true
    // 解析格式，如果发现%w动词并且提供了合法的error参数，则把error放到p.wrappedErr成员中
	p.doPrintf(format, a)
	s := string(p.buf)
	var err error
    // 没有%w动词, 生成基础error
	if p.wrappedErr == nil {
		err = errors.New(s)
	} else {
        // 有%w动词, 生成wrapError
		err = &wrapError{s, p.wrappedErr}
	}
	p.free()
	return err
}
```

fmt.Errorf()将根据格式动词来动态决定生成wrapError还是errorString。使用%v格式动词生成的error类型仍是errorString,
(没有实现Unwrap接口)。

而使用%w格式动词生成的error类型将自动变成wrapError(实现了Unwrap接口)。

如此，当error在函数间传递时，error之间好像被组织成一个链式结构，如下图所示:





![chain-error.png](images%2Fchain-error.png)





使用fmt.Errorf()生成wrapError有两个限制:
每次生成wrapError时只能使用一次%w动词（Go 1.13限制，Go 1.20已解除，详见第3节）；
%w动词只能匹配实现了error接口的参数。

```golang
permissionErr := errors.New("permission not allowed")
wrapErr := fmt.Errorf("some context: %w", permissionErr)
```

另外需要注意的是，虽然wrapError实现了Unwrap()接口，但由于error接口仍然只定义了一个Error()方法，所以使用
fmt.Errorf()生成的error，不能直接调用自身的Unwrap()接口获得原始error，而需要使用errors包中提供的Unwrap()
方法。


## 2.3 errors.Unwrap()

Unwrap()函数很形象地揭示了其作用，如果把error比作一件衣服，fmt.Errorf() (使用%w)就好比给error增加了一件外套，
而Unwrap()函数则是脱掉外套。

```golang
func Unwrap(err error) error {
    // 检查是否实现了Unwrap函数
	u, ok := err.(interface {
		Unwrap() error
	})
    // 没有实现Unwrap函数，不支持Unwrap
	if !ok {
		return nil
	}
	return u.Unwrap()
}
```

如果参数err没有实现Unwrap()函数，则说明是基础error，直接返回nil，否则调用原err实现的Unwrap()函数并返回。

对于自定义的error类型，在实现Error()函数的基础上，需要额外实现Unwrap函数，可以升级成链式error，如os.PathError

```golang
type PathError struct {
	Op   string
	Path string
	Err  error
}

func (e *PathError) Error() string { return e.Op + " " + e.Path + ": " + e.Err.Error() }

func (e *PathError) Unwrap() error { return e.Err }
```

使用Unwrap获取原始error并进行比较的例子如下:

```golang
func ExampleUnwrap() {
    err := fmt.Errorf("write file error:%w", os.ErrPermission)
    if errors.Unwrap(err) == os.ErrPermission {
        fmt.Println("permission denied")
    }
    // Output:
    // permission denied
}
```

在上面的例子中原始的error(os.ErrPermission)只被包裹了一层，我们可以使用Unwrap()函数获取原始的error。在实际的
应用中，原始的error可能在层层的函数调用中被包裹了多层，那该怎么判断呢？

对此，我们可以循环调用Unwrap()函数来逐层检查，但是这样太过繁琐，errors包的Is()方法对此提供了更好的支持。


## 2.4 errors.Is()

errors.Is()用于检查特定的error链条中是否包含指定的error值(target)。
其实现逻辑是: errors.Is()逐层拆解参数err并与参数target对比，如果发现相等则返回true，否则返回false。对于自定义
error类型来说，如果实现了自己的Is()方法，则此处在比较时会先调用自身的Is()方法。


```golang
func ExampleIs() {
    err1 := fmt.Errorf("write file error:%w", os.ErrPermission)
    err2 := fmt.Errorf("write file error:%w", err1)
    if errors.Is(err2, os.ErrPermission)  {
        fmt.Println("permission denied")
    }
    // Output:
    // permission denied
}
```

## 2.5 errors.As()

errors.As() 用于从一个error链中查找是否有指定的类型出现，如有，则把error转换成该类型。
其实现逻辑与Is()的实现非常类似，As()会逐层拆解error链并尝试匹配指定类型，如果类型匹配，则将err值写入参数
target。同时，如果error实现了As()函数，那么也会尝试调用自身的As()函数。

```golang
func ExampleAs() {
    // 模拟一个被包装的 PathError
    originalErr := &os.PathError{Op: "open", Path: "/etc/passwd", Err: os.ErrPermission}
    wrappedErr := fmt.Errorf("failed to read config: %w", originalErr)

    // 使用 errors.As() 从 error 链中提取 *os.PathError
    var pathErr *os.PathError
    if errors.As(wrappedErr, &pathErr) {
        fmt.Println("Op:", pathErr.Op)
        fmt.Println("Path:", pathErr.Path)
        fmt.Println("Err:", pathErr.Err)
    }
    // Output:
    // Op: open
    // Path: /etc/passwd
    // Err: permission denied
}
```

errors.As()与类型断言的区别在于：类型断言只能检查error本身的类型，而errors.As()会沿着整个error链逐层查找，
即使目标类型被包装了多层也能正确匹配。

## 2.6 工程迁移

细心的读者也许会发现，几乎每个版本的Release Notes中都有一句话:
"We expect almost all Go programs to continue to compile and run as before"。

Go语言的每个版本都严格遵循兼容性规则，在Go 1时代，每个小版本发布都会兼容旧版本的程序。对于Go 1.13引入的error
优化来讲也不例外，使用老版本Go语言开发的程序(下称旧工程)，仍然可以编译并运行，并且行为依旧。如果想要链式error，
那么仍需要对旧工程做一些适当的适配。

适配无非从以下几个场景入手:
> 创建error时，fmt.Errorf()格式化动词由%v改为%w；
> 等值(==)检查可以使用errors.Is()替代；
> error类型断言可以使用errors.As()替代(注意:类型断言替换成errors.As()时需要先声明一个目标类型的指针变量)；
> 自定义类型额外实现Unwrap()方法；
> 自定义类型额外实现As()方法(可选)；
> 自定义类型额外实现Is()方法(可选)；

在实际场景中，几乎不需要实现As()和Is()这两个接口，我们可以根据自身需要决定是否需要实现。


# 3 多错误包装（Go 1.20）

Go 1.13引入的%w动词每次只能包装一个error。在实际工程中，一个操作可能同时产生多个错误，例如并发任务的错误收集、
多项校验的批量失败等。Go 1.20对此进行了增强，主要体现在两方面：

## 3.1 errors.Join

errors.Join()接收多个error参数，返回一个包含所有非nil error的聚合error。如果所有参数均为nil，则返回nil。

```golang
func ExampleJoin() {
    err1 := errors.New("file not found")
    err2 := errors.New("permission denied")
    err3 := errors.New("disk full")

    err := errors.Join(err1, err2, err3)
    fmt.Println(err)
    // Output:
    // file not found
    // permission denied
    // disk full
}
```

errors.Join()返回的error实现了`Unwrap() []error`接口（注意返回的是切片），errors.Is()和errors.As()
均能正确遍历其中的每一个error：

```golang
func ExampleJoinIs() {
    err1 := errors.New("file not found")
    err2 := os.ErrPermission

    joined := errors.Join(err1, err2)

    fmt.Println(errors.Is(joined, os.ErrPermission)) // true
    fmt.Println(errors.Is(joined, err1))              // true
    // Output:
    // true
    // true
}
```

errors.Join()在并发场景下尤为实用：

```golang
func validateAll(fields []Field) error {
    var errs []error
    for _, f := range fields {
        if err := f.Validate(); err != nil {
            errs = append(errs, err)
        }
    }
    return errors.Join(errs...)
}
```

## 3.2 多%w动词

Go 1.20同时解除了fmt.Errorf()中只能使用一次%w的限制，现在可以在一次调用中使用多个%w同时包装多个error：

```golang
func ExampleMultiWrap() {
    err1 := errors.New("network timeout")
    err2 := errors.New("context canceled")

    err := fmt.Errorf("operation failed: %w, %w", err1, err2)
    fmt.Println(errors.Is(err, err1)) // true
    fmt.Println(errors.Is(err, err2)) // true
    // Output:
    // true
    // true
}
```

使用多%w时，fmt.Errorf()返回的error同样实现了`Unwrap() []error`接口，errors.Is()和errors.As()能正确匹配
其中的任意一个error。

## 3.3 errors.Join vs 多%w

两者的选择取决于是否需要附加上下文信息：

| 场景 | 推荐方式 |
|------|---------|
| 纯粹聚合多个error，无需额外描述 | `errors.Join(err1, err2)` |
| 聚合的同时需要添加上下文 | `fmt.Errorf("操作失败: %w, %w", err1, err2)` |
| 循环中收集错误 | `errors.Join(errs...)` |


# 4 panic与recover

## 4.1 panic

panic是Go的内建函数，用于触发运行时恐慌。当panic被调用时，当前函数的正常执行流程立即终止，已注册的defer函数
会按LIFO顺序执行，然后panic沿调用栈向上传播，直到程序崩溃并打印堆栈信息。

**常见触发场景：**

```golang
// 1. 显式调用
panic("something went terribly wrong")

// 2. 运行时错误自动触发
var s []int
_ = s[10]  // index out of range → panic

var m map[string]int
m["key"] = 1  // assignment to nil map → panic

var p *int
_ = *p  // nil pointer dereference → panic
```

## 4.2 recover

recover是与panic配对使用的内建函数，**只能在defer函数中调用**。它用于捕获panic的值并恢复正常执行流程。
在defer函数之外调用recover始终返回nil。

```golang
func safeDiv(a, b int) (result int, err error) {
    defer func() {
        if r := recover(); r != nil {
            err = fmt.Errorf("recovered panic: %v", r)
        }
    }()
    return a / b, nil
}

func main() {
    result, err := safeDiv(10, 0)
    if err != nil {
        fmt.Println(err) // recovered panic: runtime error: integer divide by zero
    }
    fmt.Println(result) // 0
}
```

**recover的工作原理：**
- recover()捕获panic的值并终止panic的传播
- 包含recover的defer函数正常返回后，调用panic的函数也正常返回（而非继续崩溃）
- recover只能捕获当前goroutine的panic，无法跨goroutine捕获

## 4.3 panic vs error

Go推崇使用error进行错误处理，panic应仅用于真正不可恢复的异常情况。

**使用error的场景（绝大多数情况）：**
- 文件不存在、网络超时、权限不足等可预期的失败
- 用户输入校验失败
- 业务逻辑中的异常分支

**使用panic的场景（极少数情况）：**
- 程序初始化阶段的致命错误（如配置缺失、数据库连接失败）
- 不可能到达的代码路径（表示程序有bug）
- 标准库中某些"Must"系列函数（如`regexp.MustCompile`、`template.Must`）

```golang
// Must模式：将error转化为panic，适用于初始化阶段
func MustCompileRegex(pattern string) *regexp.Regexp {
    re, err := regexp.Compile(pattern)
    if err != nil {
        panic(fmt.Sprintf("invalid regex %q: %v", pattern, err))
    }
    return re
}

// 在init或全局变量中使用
var emailRegex = MustCompileRegex(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`)
```

**服务端recover的典型用法：** 在HTTP服务器等长期运行的程序中，通常在顶层使用recover防止单个请求的panic导致
整个服务崩溃：

```golang
func recoveryMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        defer func() {
            if err := recover(); err != nil {
                log.Printf("panic recovered: %v\n%s", err, debug.Stack())
                http.Error(w, "Internal Server Error", http.StatusInternalServerError)
            }
        }()
        next.ServeHTTP(w, r)
    })
}
```


# 5 错误处理最佳实践

## 5.1 哨兵error命名规范

预定义的哨兵error（sentinel error）应以`Err`为前缀，使用`errors.New()`创建，作为包级变量导出：

```golang
var (
    ErrNotFound     = errors.New("not found")
    ErrUnauthorized = errors.New("unauthorized")
    ErrTimeout      = errors.New("operation timed out")
)
```

## 5.2 何时用哨兵error vs 自定义类型 vs %w包装

| 方式 | 适用场景 | 示例 |
|------|---------|------|
| 哨兵error | 调用方只需判断错误种类，不需要额外信息 | `io.EOF`、`sql.ErrNoRows` |
| 自定义error类型 | 调用方需要从error中提取结构化信息 | `*os.PathError`、`*net.OpError` |
| %w包装 | 为底层error添加上下文，保留原始error可追溯 | `fmt.Errorf("查询用户失败: %w", err)` |

## 5.3 层级策略

错误处理的核心原则是：**底层包装，顶层处理**。

```
┌──────────────┐
│   顶层(main)  │  ← 记录日志 / 返回HTTP响应 / 终止程序
├──────────────┤
│   业务层      │  ← fmt.Errorf("业务上下文: %w", err) 向上传递
├──────────────┤
│   数据层      │  ← fmt.Errorf("查询失败: %w", err) 向上传递
├──────────────┤
│   基础设施    │  ← 产生原始error
└──────────────┘
```

- **底层函数**：使用%w包装error并附加上下文信息，然后return
- **中间层**：继续包装，添加本层的上下文信息
- **顶层**：统一处理error（记录日志、返回响应等）

## 5.4 避免log-and-return反模式

一个error应该只在一个地方被处理（记录日志或返回给调用方），不要两者都做：

```golang
// 反模式：log-and-return，导致同一个错误在日志中重复出现
func bad(id string) error {
    result, err := queryDB(id)
    if err != nil {
        log.Printf("query failed: %v", err) // 记录了一次
        return fmt.Errorf("query failed: %w", err) // 调用方可能再记录一次
    }
    // ...
}

// 正确：只包装并返回，由顶层统一记录日志
func good(id string) error {
    result, err := queryDB(id)
    if err != nil {
        return fmt.Errorf("query user %s: %w", id, err)
    }
    // ...
}
```

## 5.5 error处理清单

- 始终检查error返回值，不要使用`_`忽略
- 使用%w包装error以保留error链
- 包装时添加有意义的上下文（哪个操作、哪个参数失败了）
- 不要在每一层都记录日志，只在最终处理点记录
- 优先使用errors.Is()和errors.As()，而非==比较和类型断言
- 使用panic仅限于不可恢复的程序错误，业务逻辑一律使用error
- 对外接口优先返回稳定错误码，错误文案可读但不作为契约
- 控制error包装层数，避免上下文重复导致错误信息膨胀

## 5.6 错误码体系设计哲学

错误码的本质是**系统对调用方的稳定契约**，不是日志字符串。设计错误码时，建议遵循以下哲学：

1. **机器可判定优先于人类可读**
   - 调用方应基于`code`分支处理，而不是匹配`message`
   - `message`可以优化措辞，但`code`一旦公开就应保持稳定

2. **一类问题一个码（One Code, One Semantics）**
   - 同一个错误码必须始终表达同一种语义
   - 不同语义不要复用同一个码，否则客户端会出现错误分流

3. **分层抽象，边界收敛**
   - 底层可保留原始error（如`sql.ErrNoRows`、`context.DeadlineExceeded`）
   - 在服务边界统一映射为业务错误码，避免把数据库/第三方细节泄漏给调用方

4. **可演进但不破坏兼容**
   - 可以新增错误码，不要重用或改变已发布错误码含义
   - 废弃错误码时保留兼容窗口，逐步迁移客户端

5. **错误码与可观测性解耦**
   - 对外：`code + 简洁message + request_id`
   - 对内日志：保留完整error链、调用栈、关键上下文字段

一个常见的结构化错误定义如下：

```golang
type CodedError interface {
    error
    Code() string
}

type AppError struct {
    code string
    msg  string
    err  error
}

func (e *AppError) Error() string { return e.msg + ": " + e.err.Error() }
func (e *AppError) Unwrap() error { return e.err }
func (e *AppError) Code() string  { return e.code }
```

映射建议：

| 层 | 关注点 | 输出 |
|---|---|---|
| 基础设施层 | 保留原始失败原因 | 原始error / wrapped error |
| 业务层 | 归一化业务语义 | `CodedError` |
| 接口层（HTTP/gRPC） | 协议映射与脱敏 | 状态码 + 业务错误码 + request_id |

## 5.7 error wrapping层数控制（避免过度包装）

error wrapping的目的，是补充**新增且必要**的上下文，而不是把同一信息重复写很多层。过度包装会导致：
- 错误字符串过长，日志可读性下降
- 同一字段重复出现，排障效率变低
- 上下游重复记录，噪音显著增加

建议的层数控制策略：

1. **默认预算：2~3层语义包装**
   - 一般覆盖“数据访问层 -> 业务层 -> 接口层（可选）”
   - 顶层若已要返回协议错误，通常不再继续包装文本

2. **只在“新增信息”时包装**
   - 仅透传：`return err`
   - 需要增加新上下文：`return fmt.Errorf("query user id=%s: %w", id, err)`
   - 只是改写同义句时，不要再次包装

3. **跨边界包装，同层少包装**
   - 穿越模块边界（DAO->Service、Service->Handler）可包装一次
   - 同一层函数间转发，若无新增信息则直接透传

4. **日志与包装分离**
   - 中低层以返回error为主，不记录最终错误日志
   - 顶层统一记录一次完整链路，避免log-and-return

示例：

```golang
// 反例：每层都包装类似信息，字符串快速膨胀
func badA(id string) error {
    if err := badB(id); err != nil {
        return fmt.Errorf("service failed: %w", err)
    }
    return nil
}

func badB(id string) error {
    if err := badC(id); err != nil {
        return fmt.Errorf("query failed: %w", err)
    }
    return nil
}

// 正例：仅在新增关键信息时包装
func goodRepo(id string) error {
    if err := query(id); err != nil {
        return fmt.Errorf("repo query user id=%s: %w", id, err)
    }
    return nil
}

func goodService(id string) error {
    if err := goodRepo(id); err != nil {
        return fmt.Errorf("service load user id=%s: %w", id, err)
    }
    return nil
}
```

如果你的项目错误链经常超过预算层数，可以考虑提供统一包装函数，超过阈值后改为透传：

```golang
const maxWrapDepth = 3

func WrapWithBudget(err error, msg string) error {
    if err == nil {
        return nil
    }
    if wrapDepth(err) >= maxWrapDepth {
        return err
    }
    return fmt.Errorf("%s: %w", msg, err)
}

func wrapDepth(err error) int {
    depth := 0
    for err != nil {
        depth++
        u, ok := err.(interface{ Unwrap() error })
        if !ok {
            break
        }
        err = u.Unwrap()
    }
    return depth
}
```


# 6 错误降级策略（Error Downgrading）

错误降级是指在非核心路径失败时，不中断主流程，而是用降级方案（缓存兜底、默认值、跳过）保证系统可用性。

## 6.1 降级 vs 重试 vs 熔断

| 策略 | 触发条件 | 行为 | 适用场景 |
|------|---------|------|---------|
| 降级 | 依赖不可用，但有替代方案 | 使用缓存/默认值/跳过 | 推荐系统、缓存层 |
| 重试 | 瞬时故障（超时、网络抖动） | 等待后重试同一操作 | 网络请求、数据库连接 |
| 熔断 | 持续失败率超过阈值 | 快速失败，不再请求 | 下游服务不可用 |

三者不互斥，通常组合使用：**重试 → 熔断 → 降级**。

## 6.2 降级模式

**缓存兜底**：
```golang
func GetUserProfile(ctx context.Context, userID string) (*Profile, error) {
    profile, err := userService.Get(ctx, userID)
    if err != nil {
        // 主路径失败，尝试缓存兜底
        cached, cacheErr := cache.Get(ctx, "profile:"+userID)
        if cacheErr == nil {
            log.Warn("degraded to cache", "userID", userID, "originalErr", err)
            return cached, nil // 返回缓存数据，不返回error
        }
        return nil, fmt.Errorf("get user profile (cache also missed): %w", err)
    }
    // 正常路径：回写缓存
    _ = cache.Set(ctx, "profile:"+userID, profile, 5*time.Minute)
    return profile, nil
}
```

**默认值降级**：
```golang
func GetRecommendations(ctx context.Context, userID string) ([]Item, error) {
    items, err := recommendService.Personalized(ctx, userID)
    if err != nil {
        log.Warn("recommendation degraded to default", "userID", userID, "err", err)
        return defaultHotItems(), nil // 返回热门榜单作为降级
    }
    return items, nil
}
```

**跳过非关键步骤**：
```golang
func CreateOrder(ctx context.Context, order *Order) error {
    if err := orderRepo.Save(ctx, order); err != nil {
        return fmt.Errorf("save order: %w", err) // 核心路径，不降级
    }
    // 非核心：发送通知，失败不影响下单
    if err := notifyService.Send(ctx, order.UserID, "下单成功"); err != nil {
        log.Warn("notification skipped", "orderID", order.ID, "err", err)
        // 不 return err，继续执行
    }
    return nil
}
```

## 6.3 降级标记与可观测性

降级发生时，必须留下可观测的痕迹，否则"静默降级"会掩盖问题：

```golang
// DegradedError 标记一个已降级的错误，用于 metrics 和告警
type DegradedError struct {
    Service  string // 哪个依赖降级了
    Fallback string // 降级方案（cache/default/skip）
    Original error  // 原始错误
}

func (e *DegradedError) Error() string {
    return fmt.Sprintf("degraded %s (fallback=%s): %v", e.Service, e.Fallback, e.Original)
}

func (e *DegradedError) Unwrap() error { return e.Original }

// 使用示例
func GetPrice(ctx context.Context, sku string) (int, error) {
    price, err := priceService.Query(ctx, sku)
    if err != nil {
        cached, _ := cache.GetPrice(ctx, sku)
        if cached > 0 {
            // 记录降级 metric
            metrics.IncrCounter("price.degraded", "service", "price", "fallback", "cache")
            return cached, &DegradedError{
                Service: "price-service", Fallback: "cache", Original: err,
            }
        }
        return 0, fmt.Errorf("get price for %s: %w", sku, err)
    }
    return price, nil
}
```

调用方可以选择性地检查是否发生了降级：

```golang
price, err := GetPrice(ctx, sku)
if err != nil {
    var de *DegradedError
    if errors.As(err, &de) {
        // 降级了，但仍有可用数据，继续处理
        log.Warn("using degraded price", "sku", sku, "fallback", de.Fallback)
    } else {
        // 彻底失败
        return fmt.Errorf("price unavailable: %w", err)
    }
}
```


# 7 Structured Error 与可观测性整合

## 7.1 为什么 error.Error() 字符串不够

`error.Error()` 返回的纯文本字符串存在以下问题：

| 问题 | 影响 |
|------|------|
| 无法机器解析 | 告警规则只能用正则匹配字符串，脆弱 |
| 丢失结构化字段 | 日志中无法按 userID、orderID 聚合 |
| 无法关联 trace | error 和分布式追踪断开 |
| 重复信息 | 多层包装后字符串膨胀，可读性差 |

解决方案：让 error 携带结构化字段，在日志/metrics/trace 中分别输出。

## 7.2 结构化 error 设计

```golang
// StructuredError 携带结构化上下文，供可观测性系统消费
type StructuredError struct {
    Code    string            // 业务错误码
    Message string            // 人类可读描述
    Fields  map[string]string // 结构化字段（用于日志和 metrics label）
    Cause   error             // 原始 error
}

func (e *StructuredError) Error() string {
    return fmt.Sprintf("[%s] %s: %v", e.Code, e.Message, e.Cause)
}

func (e *StructuredError) Unwrap() error { return e.Cause }

// NewStructuredError 创建结构化 error
func NewStructuredError(code, msg string, cause error, fields map[string]string) *StructuredError {
    return &StructuredError{Code: code, Message: msg, Fields: fields, Cause: cause}
}
```

## 7.3 与 slog 集成

Go 1.21 引入的 `log/slog` 天然支持结构化日志，可以把 StructuredError 的字段自动展开：

```golang
func LogError(logger *slog.Logger, msg string, err error) {
    attrs := []slog.Attr{
        slog.String("error", err.Error()),
    }

    // 提取结构化字段
    var se *StructuredError
    if errors.As(err, &se) {
        attrs = append(attrs,
            slog.String("error_code", se.Code),
            slog.String("error_message", se.Message),
        )
        for k, v := range se.Fields {
            attrs = append(attrs, slog.String(k, v))
        }
    }

    logger.LogAttrs(context.Background(), slog.LevelError, msg, attrs...)
}
```

输出效果（JSON 格式）：
```json
{
  "time": "2024-01-15T10:30:00Z",
  "level": "ERROR",
  "msg": "order creation failed",
  "error": "[ORDER_STOCK_INSUFFICIENT] 库存不足: stock check failed",
  "error_code": "ORDER_STOCK_INSUFFICIENT",
  "error_message": "库存不足",
  "order_id": "ORD-12345",
  "sku": "SKU-67890",
  "requested_qty": "10"
}
```

## 7.4 与 OpenTelemetry Trace 集成

将 error 信息注入 span，实现 error 与分布式追踪的关联：

```golang
import (
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/trace"
)

func RecordError(span trace.Span, err error) {
    if err == nil {
        return
    }

    span.SetStatus(codes.Error, err.Error())
    span.RecordError(err) // 自动记录 error 事件和堆栈

    // 注入结构化字段作为 span attributes
    var se *StructuredError
    if errors.As(err, &se) {
        span.SetAttributes(
            attribute.String("error.code", se.Code),
            attribute.String("error.message", se.Message),
        )
        for k, v := range se.Fields {
            span.SetAttributes(attribute.String("error."+k, v))
        }
    }
}

// 使用示例
func GetOrder(ctx context.Context, orderID string) (*Order, error) {
    ctx, span := tracer.Start(ctx, "GetOrder")
    defer span.End()

    order, err := orderRepo.FindByID(ctx, orderID)
    if err != nil {
        RecordError(span, err)
        return nil, fmt.Errorf("get order %s: %w", orderID, err)
    }
    return order, nil
}
```

## 7.5 Metrics 打点

基于 error code 的 metrics 比基于字符串匹配的告警更可靠：

```golang
func RecordErrorMetric(err error) {
    if err == nil {
        return
    }
    code := "UNKNOWN"
    var se *StructuredError
    if errors.As(err, &se) {
        code = se.Code
    }
    // Prometheus counter
    errorCounter.WithLabelValues(code).Inc()
}
```

可观测性三件套整合小结：

```
error 发生
  ├── Logging (slog)   → 结构化字段展开，便于检索和聚合
  ├── Tracing (OTel)   → span.RecordError + attributes，链路追踪
  └── Metrics (Prom)   → 按 error_code 分桶计数，驱动告警
```


# 8 跨服务边界的 Error 传播（gRPC Status Code 映射）

## 8.1 问题：error 不能直接跨进程传递

Go 的 error 是进程内概念，当 error 需要通过 gRPC/HTTP 传递给调用方时，必须进行协议映射。
直接把 `err.Error()` 字符串透传有严重问题：

- 泄漏内部实现细节（SQL 语句、文件路径、堆栈）
- 调用方无法基于字符串做可靠的分支判断
- 不同语言的客户端无法解析 Go 特有的 error 格式

## 8.2 gRPC Status Code 映射表

gRPC 定义了 16 个标准 status code，Go 业务 error 应在服务边界统一映射：

| 业务场景 | gRPC Code | HTTP 等价 | Go error 示例 |
|---------|-----------|-----------|--------------|
| 资源不存在 | `NotFound` | 404 | `sql.ErrNoRows` |
| 参数校验失败 | `InvalidArgument` | 400 | 自定义校验 error |
| 未认证 | `Unauthenticated` | 401 | token 过期/缺失 |
| 无权限 | `PermissionDenied` | 403 | RBAC 拒绝 |
| 资源冲突 | `AlreadyExists` | 409 | 唯一键冲突 |
| 前置条件不满足 | `FailedPrecondition` | 400 | 库存不足、余额不够 |
| 超时 | `DeadlineExceeded` | 504 | `context.DeadlineExceeded` |
| 取消 | `Cancelled` | 499 | `context.Canceled` |
| 内部错误 | `Internal` | 500 | 未预期的 panic/bug |
| 不可用 | `Unavailable` | 503 | 下游熔断、限流 |
| 资源耗尽 | `ResourceExhausted` | 429 | 限流、配额用完 |

## 8.3 映射实现

```golang
import (
    "google.golang.org/grpc/codes"
    "google.golang.org/grpc/status"
)

// ToGRPCError 将业务 error 映射为 gRPC status
func ToGRPCError(err error) error {
    if err == nil {
        return nil
    }

    // 1. 已经是 gRPC status，直接返回
    if _, ok := status.FromError(err); ok {
        return err
    }

    // 2. 检查标准库 error
    switch {
    case errors.Is(err, context.DeadlineExceeded):
        return status.Error(codes.DeadlineExceeded, "request timeout")
    case errors.Is(err, context.Canceled):
        return status.Error(codes.Canceled, "request canceled")
    }

    // 3. 检查业务 error code
    var ce CodedError
    if errors.As(err, &ce) {
        code, msg := mapCodeToGRPC(ce.Code())
        return status.Error(code, msg)
    }

    // 4. 兜底：Internal
    // 注意：不暴露 err.Error() 原始内容，防止信息泄漏
    return status.Error(codes.Internal, "internal error")
}

func mapCodeToGRPC(bizCode string) (codes.Code, string) {
    switch bizCode {
    case "USER_NOT_FOUND", "ORDER_NOT_FOUND":
        return codes.NotFound, "resource not found"
    case "INVALID_PARAM":
        return codes.InvalidArgument, "invalid parameter"
    case "UNAUTHORIZED":
        return codes.Unauthenticated, "authentication required"
    case "FORBIDDEN":
        return codes.PermissionDenied, "permission denied"
    case "DUPLICATE":
        return codes.AlreadyExists, "resource already exists"
    case "STOCK_INSUFFICIENT":
        return codes.FailedPrecondition, "precondition failed"
    case "RATE_LIMITED":
        return codes.ResourceExhausted, "rate limit exceeded"
    default:
        return codes.Internal, "internal error"
    }
}
```

## 8.4 gRPC 拦截器统一处理

将映射逻辑放在 gRPC 拦截器中，避免每个 RPC 方法手动转换：

```golang
func ErrorMappingInterceptor() grpc.UnaryServerInterceptor {
    return func(
        ctx context.Context,
        req any,
        info *grpc.UnaryServerInfo,
        handler grpc.UnaryHandler,
    ) (any, error) {
        resp, err := handler(ctx, req)
        if err != nil {
            // 记录完整 error（对内）
            slog.ErrorContext(ctx, "rpc failed",
                "method", info.FullMethod,
                "error", err.Error(),
            )
            // 映射为安全的 gRPC status（对外）
            return nil, ToGRPCError(err)
        }
        return resp, nil
    }
}

// 注册拦截器
server := grpc.NewServer(
    grpc.UnaryInterceptor(ErrorMappingInterceptor()),
)
```

## 8.5 客户端还原

客户端收到 gRPC error 后，可以根据 status code 做对应处理：

```golang
resp, err := client.GetUser(ctx, req)
if err != nil {
    st, ok := status.FromError(err)
    if !ok {
        return fmt.Errorf("non-gRPC error: %w", err)
    }
    switch st.Code() {
    case codes.NotFound:
        return ErrUserNotFound
    case codes.DeadlineExceeded:
        return fmt.Errorf("upstream timeout: %w", err)
    case codes.Unavailable:
        // 可重试
        return fmt.Errorf("service unavailable (retryable): %w", err)
    default:
        return fmt.Errorf("rpc failed [%s]: %s", st.Code(), st.Message())
    }
}
```

## 8.6 Error 传播原则

```
服务 A（调用方）                    服务 B（被调方）
                                ┌─────────────────────────┐
                                │ 业务逻辑产生 error        │
                                │   ↓                      │
                                │ 包装上下文 (fmt.Errorf %w) │
                                │   ↓                      │
                                │ 拦截器：完整日志 + 映射     │
                                │   ↓                      │
                                │ gRPC status (脱敏)  ──────┼──→ 网络传输
                                └─────────────────────────┘
    ┌───────────────────┐
    │ 收到 gRPC status   │ ←──────────────────────────────
    │   ↓               │
    │ 按 code 分支处理    │
    │   ↓               │
    │ 包装为本地 error    │
    └───────────────────┘
```

核心原则：
- **对内保留完整链路**：error wrapping + 结构化日志 + trace
- **对外脱敏收敛**：只暴露 status code + 安全 message
- **不透传原始 error**：防止泄漏 SQL、文件路径、堆栈等内部信息
- **status code 是契约**：客户端基于 code 而非 message 做分支判断


# 9 错误重试策略（Backoff / Jitter）

## 9.1 哪些错误值得重试

不是所有 error 都应该重试，盲目重试反而加剧故障（重试风暴）：

| 类型 | 是否重试 | 示例 |
|------|---------|------|
| 瞬时故障 | ✅ 重试 | 网络超时、连接重置、503 |
| 限流 | ✅ 重试（加退避） | 429 Too Many Requests |
| 客户端错误 | ❌ 不重试 | 参数错误(400)、未认证(401) |
| 资源不存在 | ❌ 不重试 | 404 Not Found |
| 业务逻辑失败 | ❌ 不重试 | 库存不足、余额不够 |
| 非幂等操作 | ⚠️ 谨慎 | POST 创建订单（需幂等键） |

```golang
// IsRetryable 判断 error 是否值得重试
func IsRetryable(err error) bool {
    if err == nil {
        return false
    }
    // context 超时/取消 → 可重试
    if errors.Is(err, context.DeadlineExceeded) {
        return true
    }
    // 不重试已取消的请求（调用方主动取消）
    if errors.Is(err, context.Canceled) {
        return false
    }
    // gRPC status code 判断
    st, ok := status.FromError(err)
    if ok {
        switch st.Code() {
        case codes.Unavailable, codes.DeadlineExceeded, codes.ResourceExhausted:
            return true
        case codes.InvalidArgument, codes.NotFound, codes.PermissionDenied,
             codes.Unauthenticated, codes.AlreadyExists:
            return false
        }
    }
    return false
}
```

## 9.2 退避策略

**固定间隔**：每次等待固定时间，简单但容易造成请求同步（thundering herd）。

**指数退避（Exponential Backoff）**：等待时间按指数增长，减轻下游压力。

**指数退避 + Jitter**：在指数退避基础上加入随机抖动，打散重试请求，避免多个客户端同时重试。

```
固定间隔:     1s → 1s → 1s → 1s
指数退避:     1s → 2s → 4s → 8s
指数退避+Jitter: 0.8s → 2.3s → 3.1s → 9.2s  (随机化)
```

## 9.3 实现

```golang
// RetryConfig 重试配置
type RetryConfig struct {
    MaxAttempts  int           // 最大重试次数（含首次）
    InitialDelay time.Duration // 初始等待时间
    MaxDelay     time.Duration // 最大等待时间
    Multiplier   float64       // 退避倍数
    JitterFactor float64       // 抖动因子 (0~1)
}

// DefaultRetryConfig 默认配置
func DefaultRetryConfig() RetryConfig {
    return RetryConfig{
        MaxAttempts:  3,
        InitialDelay: 100 * time.Millisecond,
        MaxDelay:     5 * time.Second,
        Multiplier:   2.0,
        JitterFactor: 0.2, // ±20% 抖动
    }
}

// RetryWithBackoff 带退避的重试
func RetryWithBackoff(ctx context.Context, cfg RetryConfig, op func(ctx context.Context) error) error {
    var lastErr error
    delay := cfg.InitialDelay

    for attempt := 0; attempt < cfg.MaxAttempts; attempt++ {
        lastErr = op(ctx)
        if lastErr == nil {
            return nil
        }

        // 判断是否值得重试
        if !IsRetryable(lastErr) {
            return lastErr
        }

        // 最后一次尝试，不等待
        if attempt == cfg.MaxAttempts-1 {
            break
        }

        // 计算等待时间（指数退避 + jitter）
        jitter := 1.0 + cfg.JitterFactor*(2*rand.Float64()-1) // [1-factor, 1+factor]
        wait := time.Duration(float64(delay) * jitter)
        if wait > cfg.MaxDelay {
            wait = cfg.MaxDelay
        }

        select {
        case <-ctx.Done():
            return fmt.Errorf("retry canceled after %d attempts: %w", attempt+1, ctx.Err())
        case <-time.After(wait):
        }

        delay = time.Duration(float64(delay) * cfg.Multiplier)
    }

    return fmt.Errorf("all %d attempts failed: %w", cfg.MaxAttempts, lastErr)
}
```

## 9.4 使用示例

```golang
func GetUserWithRetry(ctx context.Context, userID string) (*User, error) {
    var user *User
    err := RetryWithBackoff(ctx, DefaultRetryConfig(), func(ctx context.Context) error {
        var err error
        user, err = userClient.Get(ctx, &pb.GetUserRequest{Id: userID})
        return err
    })
    if err != nil {
        return nil, fmt.Errorf("get user %s (with retry): %w", userID, err)
    }
    return user, nil
}
```

## 9.5 重试与幂等性

重试的前提是操作幂等——多次执行产生同样的结果。对于非幂等操作，必须引入幂等键：

```golang
// 创建订单（非幂等操作），通过幂等键保证安全重试
func CreateOrderWithRetry(ctx context.Context, req *CreateOrderRequest) (*Order, error) {
    // 生成幂等键，所有重试共享同一个 key
    idempotencyKey := uuid.New().String()

    var order *Order
    err := RetryWithBackoff(ctx, DefaultRetryConfig(), func(ctx context.Context) error {
        var err error
        order, err = orderClient.Create(ctx, &pb.CreateOrderRequest{
            IdempotencyKey: idempotencyKey, // 服务端据此去重
            Items:          req.Items,
        })
        return err
    })
    return order, err
}
```

## 9.6 重试预算（Retry Budget）

无限制的重试会造成"重试风暴"——当下游已经过载时，重试请求进一步加剧压力，形成恶性循环。

解决方案：限制重试占总请求量的比例。

```golang
// RetryBudget 控制重试占比，防止重试风暴
type RetryBudget struct {
    mu          sync.Mutex
    totalCalls  int64 // 总请求数
    retryCalls  int64 // 重试请求数
    maxRatio    float64 // 最大重试占比（如 0.1 = 10%）
    window      time.Duration
    lastReset   time.Time
}

func NewRetryBudget(maxRatio float64, window time.Duration) *RetryBudget {
    return &RetryBudget{
        maxRatio:  maxRatio,
        window:    window,
        lastReset: time.Now(),
    }
}

// AllowRetry 判断是否还有重试预算
func (b *RetryBudget) AllowRetry() bool {
    b.mu.Lock()
    defer b.mu.Unlock()

    // 窗口重置
    if time.Since(b.lastReset) > b.window {
        b.totalCalls = 0
        b.retryCalls = 0
        b.lastReset = time.Now()
    }

    if b.totalCalls == 0 {
        return true
    }
    return float64(b.retryCalls)/float64(b.totalCalls) < b.maxRatio
}

// RecordCall 记录一次调用
func (b *RetryBudget) RecordCall(isRetry bool) {
    b.mu.Lock()
    defer b.mu.Unlock()
    b.totalCalls++
    if isRetry {
        b.retryCalls++
    }
}
```

## 9.7 错误重试清单

- 只重试瞬时故障，不重试业务逻辑错误
- 必须设置最大重试次数和最大等待时间
- 使用指数退避 + jitter，避免 thundering herd
- 尊重 context 取消信号，不在 ctx.Done() 后继续重试
- 非幂等操作必须引入幂等键
- 使用重试预算限制重试占比（通常 ≤10%）
- 记录每次重试的 metrics（`retry.count`、`retry.exhausted`）
