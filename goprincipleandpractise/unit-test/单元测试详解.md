
---
单元测试详解
---

# 1 什么是单元测试？

所谓单元测试（unit testing），是指对软件中的最小可测试单元进行检查和验证，在 Golang 编程语境里，这通常具体指代
单个函数。单元测试遵循着 AAA（Arrange-Act-Assert）的代码组织结构，就像下面的代码一样。

```go
func TestAdd(t *testing.T) {
    // Arrange(安排）
    a := 5
    b := 3
    expected := 8

    // Act（行动）
    result := Add(a, b)

    // Assert（断言）
    assert.Equal(t, expected, result)
}
```

首先在 Arrange 部分，我们需要准备测试所需的所有前置条件，比如初始化被测试对象、准备输入数据、创建模拟对象
（如果有外部依赖）等。接着，在 Act 部分，我们需要调用被测试的函数或方法，触发实际的行为。最后在 Assert 部分，
需要验证调用的结果是否符合预期。由于单元测试是针对单个函数的细粒度测试，所以一旦某个用例未能通过测试，我们就
能迅速将问题锁定在这个函数的内部，从而更高效地定位问题根源。

不过，根据阿里巴巴 Java 手册的规范，一个好的单元测试在宏观层面必须遵循下面的 AIR 原则。

首先是 Automatic（自动化）原则。单元测试必须自动运行，不能手动检查结果。例如，我们不能通过打印输出来检查，
而应该使用断言（assert）来验证结果是否正确。

接着是 Independent（独立性）原则。每个测试用例应该独立运行，不依赖其他测试用例。如果测试用例相互依赖，
一旦某个测试失败，其他依赖它的测试也可能失败，导致我们难以确定问题所在。比如就像下面的代码，
TestMultiplyBySum 依赖 TestAdd 的结果，如果 TestAdd 失败或未执行，会导致 TestMultiplyBySum 的结果不准确。


```go
var sumResult int

func TestAdd(t *testing.T) {
    result := Add(2, 3)
    sumResult = result
    expected = 5
    assert.Equal(t, expected, result)
}

func TestMultiplyBySum(t *testing.T) {
    // 依赖 TestAdd 测试的结果
    result := MultiplyBySum(2, 3, 4)
    expected := sumResult * 4
    assert.Equal(t, expected, result)
}
```

最后是 Repeatable（可重复）原则。单元测试在任何时间和环境下执行，结果都应该一致，不受外部环境影响。在持续集成中，
频繁执行的测试如果结果不稳定，会降低开发人员对测试结果的信任度，也难以定位和修复问题。为避免依赖外部资源，我们可以
用 Mock 框架模拟第三方资源，比如用 Mock 框架模拟外部 API 响应来进行测试。

如果要让单元测试切实遵循这三大原则，断言库与 Mock 框架的支持是不可或缺的。

# 2 为什么要写单元测试？

## 2.1 单元测试是将 Bug 控制在编码阶段的唯一手段

![bug_during_test_stages.png](images%2Fbug_during_test_stages.png)

上图出自 Capers Jones 在 1996 年出版的 《Applied Software Measurement》，它是一张经典图表，展示了软件开发生命周期中
的缺陷发现和修复成本。这张图在软件工程领域非常有影响力，经常被用来说明“尽早测试、尽早发现问题”的重要性。那接下来，我们就一起来
分析这张图上的重要信息。从这张图上，我们可以总结出缺陷分布的规律：编码阶段发现缺陷的比例最高（约 85%）, 后续阶段发现缺陷的比例
逐渐降低。我们注意到，85% 的缺陷 Bug 都是在编码阶段出现的。
这里的 Bug 不仅局限于语法错误这种简单问题，还包括业务逻辑错误、配置不合理等。对于那些声称“我写的代码不会出错，用不着单元测试”的
开发同学，我只能说盲目自信带来的只能是“世界级”的灾难。因此，在业务功能开发过程中，我们应当保持一种“悲观”的心态，按照代码行数
百分比来预估你的缺陷数量。比如这次功能开发完成，我们使用了 1000 行代码。此时，我们可以按照每 200 行出现一个 Bug 的频率进行预估
（这个数值应该根据自身的经验值调整）。你心里需要有个数，对于这个功能，至少有 5 个 Bug 需要自己和测试同学一起查出来。此外，这张
图还告诉我们：Bug 修复的成本随着时间推移越来越高。我们可以看到：黑色曲线表示修复缺陷的成本（$）。曲线显示越晚发现缺陷，修复成本越高，
从编码阶段的 $25 上升到发布后的 $16000。

我们可以把一个业务看成一架飞机，如果没有完备的单元测试，就像在组装这架飞机时，各个组件没有经过严格的检验，只是单纯地将它组装完成，
然后通过试飞来检验飞机是否正常运行。平时，这架飞机看起来或许可以正常飞行。但恐怖的是，我们根本无法预知什么时候飞机会出问题，
又会在什么时候发生解体。等到飞机进入生产环境，一旦发生解体，后果就是机毁人亡，由此带来的成本和代价无疑是极其巨大的。所以我才说，
单元测试是将 Bug 控制在编码阶段的唯一手段！

单元测试是所有测试中最底层的一类测试，是第一个环节，也是最重要的一个环节，是唯一一次能够保证代码覆盖率达到 100% 的测试。
作为开发人员，同时也是单元测试的主要执行者，在交付生产环境代码时，你就应该编写足够的单元测试，以便将 Bug 控制在编码阶段，
避免后期在生产环境中出现无可挽回的事故。

## 2.2  测试金字塔
![test_pyramid.png](images%2Ftest_pyramid.png)

测试金字塔的最底层是单元测试，它是对代码进行测试。再上一层是集成测试，它是对一个服务的接口进行测试。再上一层是端到端的测试，
我也称它为链路测试，它负责从一个链路的入口输入测试用例，将测试运行在链路上的多个服务中，以此来验证整个链路的运行结果。位于
顶层的是我们最常用的 UI 测试，即测试同学在 UI 界面上根据功能进行点击，以此来完成测试。

那如果不编写单元测试，后面的集成测试能够帮我测试出问题吗？

从测试的角度来看，后面进行的集成测试、全链路测试、UI 测试都属于黑盒测试。 对于测试同学来说，代码就是一个无法看到内部的黑盒。
由于业务的逻辑代码繁多且分支错综复杂，测试同学是无法设计出完善的集成测试用例的，一定会存在覆盖不到的分支。而这些覆盖不到的
分支产生的严重后果，不应该只有测试同学来承担，其实更多是开发同学没有完备的单元测试导致的。而且这种思想也是一种懒惰的表现，
并且逐渐和现在的大厂业务模式相背离。现在的大厂越来越推崇 DevOps 的开发模式，在这种模式下，开发同学会承担越来越多的角色，
开发、测试、运维这些角色的职责都集中在开发同学身上。DevOps 推崇开发同学对自己的代码负责，同时对代码运行在生产环境中的
运维情况负责。记住，自己的代码质量，永远不要依赖他人，包括测试同学。

# 3 如何写可测试的代码

我们要明白，并不是所有的代码都叫做“可测试的代码”。编写可测试的代码是软件开发的一个重要前提，对任何语言都是如此。所以接下来，
我们给出一系列编写可测试代码的最佳实践。

## 3.1  避免全局状态
尽量避免使用全局变量，因为它们会使测试变得复杂。如果必须使用全局状态，可以考虑使用其他方式来控制全局状态。比如下面这段代码：

```go
var GlobalPrice = 1
func Foo() bool { 
	if GlobalPrice > 1 { 
		return true 
	} 
	return false
}
```

这段代码中的 Foo 函数依赖了全局变量 Global，这个函数的可测试性很低，因为 Foo 函数的返回值依赖一个全局变量 GlobalPrice，
而我们不知道这个全局变量在 Foo 函数调用之前是否被其他函数修改过。相对比较好的代码是：

```go
var GlobalPrice = 1
...
func Foo(price int) bool {
  if price > 1 {
    return true
  }  
  return false
}

```

## 3.2 函数要有稳定地输入和输出
函数应该接收参数并返回结果，并且这种输出是稳定的，不是有随机性的。比如下面的代码：

```go
func Foo() bool {
  if time.Now().Timestamp() % 10 > 3 {
    return true
  }  
  return false
}
```

这段代码返回的结构和当前运行的时间有关，即使每次输入一样，返回值也是不一样的，有一定随机性，所以这样的函数是无法测试的。

## 3.3 依赖注入
使用依赖注入将外部依赖（如数据库连接、HTTP 客户端等）传递给函数或结构体，而不是在函数内部创建这些依赖。这使得我们在测试阶段
可以传入模拟（Mock）对象。我们在定义一个结构体的时候，尽量将它的外部依赖项，比如它依赖什么存储、什么缓存，作为结构体的元素。
下面的结构体就比较合适：

```go
// 缓存服务
type CacheService struct {
  redisClient *redis.Client
}


// 初始化
func NewCacheService(redisClient *redis.Client) *CacheService {
    return &CacheService{
      redisClient: redisClient
    }
}


// 从缓存中获取个数
func (s *CacheService) GetCount(ctx context.Context) (uint64, err) {
  return s.redisClient.Get("foo:count")
}
```

在测试这个 GetCount 方法时，我们可以 mock 一个 redisClient，然后使用 NewCacheService 的方法初始化一个 CacheService 进行测试。
你可以比较下面这个函数：

```go
// 缓存服务
type CacheService struct {
}


// 初始化
func NewCacheService() *CacheService {
    return &CacheService{ }
}


// 从缓存中获取个数
func (s *CacheService) GetCount(ctx context.Context) (uint64, err) {
    redisClient := client.NewConnect("username", "password")
    redisClient.connect()
  return redisClient.Get("foo:count")
}

```

这个代码中的 GetCount 函数，在函数内部直接初始化了一个 Redis 的连接，所以，当我们在用这个函数写测试用例时，如果想用 mock redis 
来执行这个函数是无能为力的。这就是一种不好的函数实现方式。写出可以“依赖注入”的代码对于单元测试非常重要。

## 3.4 小函数和单一职责
将代码拆分成小函数，每个函数只做一件事。这样可以更容易地编写单元测试，并且测试覆盖率更高。这个原则其实不只是为了代码可测性，
对于代码可读性等都有裨益。我演示一个很差的代码函数你就能理解了。

```go
// bad_example.go
func ProcessOrder(userID int64, items []OrderItem, couponCode string, addressID int64) error {
    // 一个大函数包含了所有逻辑
    db, err := sql.Open("mysql", "user:password@/dbname")
    if err != nil {
        return fmt.Errorf("数据库连接失败: %w", err)
    }
    defer db.Close()


    // 查询用户信息
    var user User
    err = db.QueryRow("SELECT id, email, balance FROM users WHERE id = ?", userID).
        Scan(&user.ID, &user.Email, &user.Balance)
    if err != nil {
        return fmt.Errorf("查询用户失败: %w", err)
    }


    // 计算商品总价
    var total float64
    for _, item := range items {
        var price float64
        var stock int
        err = db.QueryRow("SELECT price, stock FROM products WHERE id = ?", item.ProductID).
            Scan(&price, &stock)
        if err != nil {
            return fmt.Errorf("查询商品失败: %w", err)
        }
        
        if stock < item.Quantity {
            return fmt.Errorf("商品 %d 库存不足", item.ProductID)
        }
        
        total += price * float64(item.Quantity)
    }


    // 优惠券处理
    if couponCode != "" {
        var discount float64
        var minAmount float64
        var used bool
        err = db.QueryRow(`
            SELECT discount, min_amount, used 
            FROM coupons 
            WHERE code = ? AND user_id = ? AND expire_time > NOW()`,
            couponCode, userID).
            Scan(&discount, &minAmount, &used)
        
        if err != nil {
            return fmt.Errorf("查询优惠券失败: %w", err)
        }
        
        if used {
            return errors.New("优惠券已使用")
        }
        
        if total < minAmount {
            return fmt.Errorf("订单金额未达到优惠券使用门槛 %.2f", minAmount)
        }
        
        total = total * (1 - discount)
    }


    // 检查用户余额
    if user.Balance < total {
        return errors.New("用户余额不足")
    }


    // 查询收货地址
    var address Address
    err = db.QueryRow("SELECT province, city, detail FROM addresses WHERE id = ? AND user_id = ?",
        addressID, userID).
        Scan(&address.Province, &address.City, &address.Detail)
    if err != nil {
        return fmt.Errorf("查询地址失败: %w", err)
    }


    // 开启事务
    tx, err := db.Begin()
    if err != nil {
        return fmt.Errorf("开启事务失败: %w", err)
    }
    defer tx.Rollback()


    // 扣减库存
    for _, item := range items {
        _, err = tx.Exec("UPDATE products SET stock = stock - ? WHERE id = ?",
            item.Quantity, item.ProductID)
        if err != nil {
            return fmt.Errorf("更新库存失败: %w", err)
        }
    }


    // 扣减余额
    _, err = tx.Exec("UPDATE users SET balance = balance - ? WHERE id = ?",
        total, userID)
    if err != nil {
        return fmt.Errorf("扣减余额失败: %w", err)
    }


    // 标记优惠券已使用
    if couponCode != "" {
        _, err = tx.Exec("UPDATE coupons SET used = true WHERE code = ?",
            couponCode)
        if err != nil {
            return fmt.Errorf("更新优惠券状态失败: %w", err)
        }
    }


    // 创建订单
    orderResult, err := tx.Exec(`
        INSERT INTO orders (user_id, total_amount, address_id, status, created_at)
        VALUES (?, ?, ?, 'pending', NOW())`,
        userID, total, addressID)
    if err != nil {
        return fmt.Errorf("创建订单失败: %w", err)
    }


    orderID, _ := orderResult.LastInsertId()


    // 创建订单详情
    for _, item := range items {
        _, err = tx.Exec(`
            INSERT INTO order_items (order_id, product_id, quantity, price)
            VALUES (?, ?, ?, ?)`,
            orderID, item.ProductID, item.Quantity, item.Price)
        if err != nil {
            return fmt.Errorf("创建订单详情失败: %w", err)
        }
    }


    // 提交事务
    if err = tx.Commit(); err != nil {
        return fmt.Errorf("提交事务失败: %w", err)
    }


    // 发送订单确认邮件
    smtp.SendMail("smtp.example.com:587", nil,
        "shop@example.com", []string{user.Email},
        []byte(fmt.Sprintf("您的订单 %d 已创建,总金额: %.2f", orderID, total)))


    // 发送通知给库存系统
    kafka.Send("stock_update", map[string]interface{}{
        "order_id": orderID,
        "items":    items,
    })


    return nil
}

```

这个函数有 150 行左右，其中包括了订单的所有流程，同时涉及多个 SQL 请求和一个大事务。遇到这种函数时，你一定会产生这样的想法：这怎么写测试用例啊？
确实，这不是你的问题，而是这个函数过于庞大导致的。它应该将其中逻辑相近的几个子步骤合并，进而抽象出子函数。这样不仅可读性变高，这些子函数的测试用例
也就可以写了。

# 4 断言：如何判断结果符合预期？
在 Go 的实践中，testify 和 goconvey 两个断言库使用较为广泛。testify 的断言风格和其它编程语言中的断言库类似，
测试用例结构简单，对于开发者而言，极易上手。就像下面这段代码所展示的，借助 testify 库 assert 包里的断言函数，
我们就能够直接针对结果进行断言检查。

```go
import (
    "testing"

    "github.com/stretchr/testify/assert"
)

func TestAddWithTestify(t *testing.T) {
    a := 3
    b := 5
    result := Add(a, b)
    expected := 7

    // Assert
    assert.Equal(t, expected, result, "Add(3, 5) should return 8")
}
```

而 goconvey 库的功能更为强大，不过相应地，它的学习成本也相对较高。goconvey 库的核心在于 Convey 和 So 这两个函数。
Convey 函数主要用于描述测试场景，而 So 则负责对结果进行断言。值得一提的是，goconvey 还支持分组嵌套测试的代码组织结构，
这种特性使它在大型项目中表现出色，能够更好地组织和管理复杂的测试用例。

以下面的代码为例。这段代码最外层的 Convey 函数描述了整个测试的主题是 “关于 Add 函数的测试”。第一层嵌套的 Convey 
分别描述了 “正常情况的测试” 和 “边界情况的测试” 这两个分组。第二层嵌套的 Convey 针对每个分组下的具体测试场景进行
描述，并在每个场景中调用 Add 函数，使用 So 进行断言验证结果是否符合预期。


```go
import (
    . "github.com/smartystreets/goconvey/convey"
)
func TestAddWithConvey(t *testing.T) {
    Convey("关于Add函数的测试", t, func() {
        Convey("正常情况的测试", func() {
            Convey("两个正数相加", func() {
                result := Add(2, 3)
                So(result, ShouldEqual, 5)
            })
            Convey("一个正数和一个负数相加", func() {
                result := Add(5, -3)
                So(result, ShouldEqual, 2)
            })
        })
        Convey("边界情况的测试", func() {
            Convey("两个零相加", func() {
                result := Add(0, 0)
                So(result, ShouldEqual, 0)
            })
            Convey("一个数与最大整数相加", func() {
                result := Add(int(math.MaxInt32), 1)
                So(result, ShouldEqual, int(math.MaxInt32)+1)
            })
        })
    })
}
```

# 5 Mock：如何去除不稳定依赖？

在 Go 实践中，我们可以使用应用广泛的 gomonkey 库来实现 mock 功能。gomonkey 库通过 Monkey patch 技术，在程序
运行时巧妙地改写函数指令，达到 mock 的目的。以下面代码为例，我们使用 ApplyFunc 函数，对不稳定的 HTTP 调用进行
mock 替换，这样可以有效规避违反单元测试 Repeatable 原则的风险。


```go
import (
    "github.com/agiledragon/gomonkey/v2"
)

// 发送HTTP GET请求并返回响应的函数
func httpGetRequest(url string) ([]byte, error) {
    resp, err := http.Get(url)
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()
    return io.ReadAll(resp.Body)
}

// 依赖httpGetRequest函数获取用户信息的函数
func fetchUserInfo(userID string) (string, error) {
    url := "https://example.com/api/user/" + userID
    data, err := httpGetRequest(url)
    if err != nil {
        return "", err
    }
    return string(data), nil
}

func TestMock(t *testing.T) {
    // 使用gomonkey mock函数httpGetRequest的返回
    mockData := []byte(`{"name":"killianxu","age":32}`)
    patch := gomonkey.ApplyFunc(httpGetRequest, func(url string) ([]byte, error) {
        return mockData, nil
    })
    defer patch.Reset()

    // 底层httpGetRequest的函数调用返回，会被mock
    mockUserInfo, _ := fetchUserInfo("123")

    fmt.Printf("mocked user info: %s\n", mockUserInfo)
}

// 输出
killianxu@KILLIANXU-MB0 mock % go test -gcflags=all=-l
mocked user info: {"name":"killianxu","age":32}
```


# 6 单元测试的组织结构

## 6.1   子测试：化整为零，提升测试粒度与可读性
Go 1.7 引入的 t.Run 方法允许我们在一个顶层测试函数（TestXxx）内部创建和运行独立的、命名的子测试。每个子测试都有自己的 *testing.T 实例，可以独立地报告成功、失败或跳过。

那么，为何需要子测试？原因如下：
隔离失败：一个子测试的失败不会影响其他子测试的执行。
更清晰的测试报告：go test -v 的输出会清晰显示层级和名称（如 TestMyFunction/SubTestA/Case1），便于定位。清晰的子测试命名对于使测试失败易读至关重要。
共享 Setup/Teardown 逻辑：可以在父测试中执行通用设置和清理。
逻辑分组：将相关测试组织在同一个父测试下。

## 6.2  表驱动测试: 数据与逻辑分离的最佳实践
表驱动测试是 Go 社区广为推崇的一种测试模式，它完美体现了“将测试用例与测试逻辑分开”的测试惯例。其核心思想是将一系列测试用例的输入数据和期望输出组织在一个“表”（通常是结构体切片）中，然后编写一段通用的测试逻辑来遍历这个表，对每一行（即每一个测试用例）执行测试。

表驱动测试的核心思想与结构是这样的：
定义测试用例结构体：通常包含 name（string，用于子测试命名和描述）、输入参数字段、期望输出字段、期望错误类型等。
创建测试用例表：一个该结构体的切片实例。
循环执行：遍历切片，对每个测试用例：
使用 t.Run(testCase.name, func(t *testing.T) { ... }) 创建子测试。清晰的 testCase.name 是保证测试失败信息易读的关键。
在子测试内部执行被测逻辑，并进行断言。

## 6.3  利用子测试规划包内测试的层次布局
当一个包内有多个相关的函数，或者一个类型有多个方法需要测试时，如何组织这些测试，使其在 go test -v 的输出中逻辑清晰、易于定位，是一个值得思考的问题。子测试在这里能发挥巨大作用，帮助我们构建清晰的测试层次。利用子测试规划包内测试的层次布局的策略如下：

按被测单元组织顶层测试函数：为主要类型或功能模块创建顶层 TestXxx 函数。
例如，对于一个 customerimage service 类型，我们可以创建一个 TestCustomerImageService(t *testing.T)
作为其所有方法测试的入口。

```go
func TestCustomerImageService(t *testing.T) {
    t.Run("GetCustomerImageByID", runGetCustomerImageByIDTests)
    t.Run("AddCustomerImage", runAddCustomerImageTests)
    t.Run("DeleteCustomerImage", runDeleteCustomerImageTests)
    t.Run("GetCustomerAvatarByID", runGetCustomerAvatarByIDTests)
    t.Run("AddCustomerAvatar", runAddCustomerAvatarTests)
}
```

在顶层测试函数中使用 t.Run 为每个方法或主要功能点创建子测试分组：在 TestCustomerImageService 内部，为
GetCustomerImageByID,AddCustomerImage,DeleteCustomerImage,GetCustomerAvatarByID,AddCustomerAvatar等
每个公开方法创建一个子测试。这形成了测试报告的第一层逻辑分组，使得报告更易读，例如 TestCustomerImageService/GetCustomerImageByID。

在方法 / 子功能级别的子测试内，再使用表驱动测试或进一步的子测试来覆盖不同场景：对于每个方法的测试（如 GetCustomerImageByID 的子测试），
内部再使用表驱动测试来覆盖该方法的各种输入场景和边界条件。表驱动的每一行又可以通过 t.Run 变成更下一级的子测试，例如
TestCustomerImageService/GetCustomerImageByID/CustomerNotFound。

```go
func runGetCustomerImageByIDTests(t *testing.T) {
    t.Helper()

    type expectedValues struct {
       front    string
       back     string
       avatar   string
       extraOne string
    }

    tests := []struct {
       name               string
       cacheStub          *stubImmutableCache
       repoStub           *stubCustomerImageRepo
       customerID         int64
       expectErr          string
       expectCode         code.ErrorCode
       expectedCustomerID int64
       expectedValues     expectedValues
       cacheCalled        *bool
       repoCalled         *bool
    }{
       {
          name:        "customer not found",
          customerID:  123,
          cacheStub:   &stubImmutableCache{result: nil},
          repoStub:    &stubCustomerImageRepo{},
          expectCode:  code.DataNotFound,
          cacheCalled: boolPtr(true),
          repoCalled:  boolPtr(false),
       },
       ...
    }

    for _, tt := range tests {
       tt := tt
       t.Run(tt.name, func(t *testing.T) {
          svc := &service{customerImageRepo: tt.repoStub, customerImmutableCache: tt.cacheStub}
          resp, err := svc.GetCustomerImageByID(context.Background(), tt.customerID)

          if tt.cacheCalled != nil && *tt.cacheCalled != tt.cacheStub.called {
             t.Fatalf("cache called mismatch: got %t, want %t", tt.cacheStub.called, *tt.cacheCalled)
          }
          if tt.repoCalled != nil && *tt.repoCalled != tt.repoStub.called {
             t.Fatalf("repo called mismatch: got %t, want %t", tt.repoStub.called, *tt.repoCalled)
          }

          if tt.expectCode != "" {
             var ue *apperror.UssAeError
             if !errors.As(err, &ue) || ue.ErrorCode != tt.expectCode {
                t.Fatalf("expected UssAeError %s, got %v", tt.expectCode, err)
             }
             return
          }

          if tt.expectErr != "" {
             if err == nil || err.Error() != tt.expectErr {
                t.Fatalf("expected error %q, got %v", tt.expectErr, err)
             }
             return
          }

          if err != nil {
             t.Fatalf("unexpected error: %v", err)
          }

          img, ok := resp.Value.(dto.CustomerImage)
          if !ok {
             t.Fatalf("response type mismatch: %T", resp.Value)
          }
          if tt.expectedCustomerID != 0 && img.CustomerID != tt.expectedCustomerID {
             t.Fatalf("unexpected CustomerID: %d, want %d", img.CustomerID, tt.expectedCustomerID)
          }
          if tt.expectedValues.front != "" {
             assertStringValue(t, img.IDCardFront, tt.expectedValues.front)
          }
          if tt.expectedValues.back != "" {
             assertStringValue(t, img.IDCardBack, tt.expectedValues.back)
          }
          if tt.expectedValues.avatar != "" {
             assertStringValue(t, img.Avatar, tt.expectedValues.avatar)
          }
          if tt.expectedValues.extraOne != "" {
             assertStringValue(t, img.ExtraImageOne, tt.expectedValues.extraOne)
          }
       })
    }
}
```

测试结果输出:

```shell
--- PASS: TestCustomerImageService (0.00s)
    --- PASS: TestCustomerImageService/GetCustomerImageByID (0.00s)
        --- PASS: TestCustomerImageService/GetCustomerImageByID/success_with_data (0.00s)
        --- PASS: TestCustomerImageService/GetCustomerImageByID/defaults_missing_ID_to_request_ID (0.00s)
        --- PASS: TestCustomerImageService/GetCustomerImageByID/propagates_cache_error (0.00s)
        --- PASS: TestCustomerImageService/GetCustomerImageByID/customer_not_found (0.00s)
        --- PASS: TestCustomerImageService/GetCustomerImageByID/propagates_repo_error (0.00s)
    --- PASS: TestCustomerImageService/AddCustomerImage (0.00s)
        --- PASS: TestCustomerImageService/AddCustomerImage/updates_existing_and_publishes (0.00s)
        --- PASS: TestCustomerImageService/AddCustomerImage/inserts_when_missing (0.00s)
        --- PASS: TestCustomerImageService/AddCustomerImage/no_images_is_no-op_success (0.00s)
        --- PASS: TestCustomerImageService/AddCustomerImage/extra_image_only_publishes_but_does_not_write (0.00s)
        --- PASS: TestCustomerImageService/AddCustomerImage/cache_error_bubbles (0.00s)
        --- PASS: TestCustomerImageService/AddCustomerImage/customer_missing (0.00s)
        --- PASS: TestCustomerImageService/AddCustomerImage/profile_error_bubbles (0.00s)
        --- PASS: TestCustomerImageService/AddCustomerImage/rejects_verified_ID_changes (0.00s)
        --- PASS: TestCustomerImageService/AddCustomerImage/find_existing_image_error_bubbles (0.00s)
        --- PASS: TestCustomerImageService/AddCustomerImage/update_error_bubbles (0.00s)
        --- PASS: TestCustomerImageService/AddCustomerImage/insert_error_bubbles (0.00s)
        --- PASS: TestCustomerImageService/AddCustomerImage/publish_send_error_logs_but_succeeds (0.00s)
        --- PASS: TestCustomerImageService/AddCustomerImage/merchant_lookup_error_logs_but_succeeds (0.00s)
    --- PASS: TestCustomerImageService/DeleteCustomerImage (0.00s)
        --- PASS: TestCustomerImageService/DeleteCustomerImage/deletes_existing_image_and_resets_verification (0.00s)
        --- PASS: TestCustomerImageService/DeleteCustomerImage/missing_image_still_resets_verification (0.00s)
        --- PASS: TestCustomerImageService/DeleteCustomerImage/cache_error_bubbles (0.00s)
        --- PASS: TestCustomerImageService/DeleteCustomerImage/customer_missing (0.00s)
        --- PASS: TestCustomerImageService/DeleteCustomerImage/find_image_error_bubbles (0.00s)
        --- PASS: TestCustomerImageService/DeleteCustomerImage/update_image_error_bubbles (0.00s)
        --- PASS: TestCustomerImageService/DeleteCustomerImage/profile_find_error_bubbles (0.00s)
        --- PASS: TestCustomerImageService/DeleteCustomerImage/update_verification_error_bubbles (0.00s)
        --- PASS: TestCustomerImageService/DeleteCustomerImage/transaction_begin_error_bubbles (0.00s)
    --- PASS: TestCustomerImageService/GetCustomerAvatarByID (0.00s)
        --- PASS: TestCustomerImageService/GetCustomerAvatarByID/uses_custom_avatar_when_present (0.00s)
        --- PASS: TestCustomerImageService/GetCustomerAvatarByID/falls_back_to_static_icon_when_no_custom_avatar (0.00s)
        --- PASS: TestCustomerImageService/GetCustomerAvatarByID/cache_reports_missing_customer (0.00s)
        --- PASS: TestCustomerImageService/GetCustomerAvatarByID/repo_error_bubbles (0.00s)
    --- PASS: TestCustomerImageService/AddCustomerAvatar (0.00s)
        --- PASS: TestCustomerImageService/AddCustomerAvatar/custom_avatar_updates_existing (0.00s)
        --- PASS: TestCustomerImageService/AddCustomerAvatar/custom_avatar_inserts_when_missing (0.00s)
        --- PASS: TestCustomerImageService/AddCustomerAvatar/customer_missing (0.00s)
        --- PASS: TestCustomerImageService/AddCustomerAvatar/find_error_bubbles (0.00s)
        --- PASS: TestCustomerImageService/AddCustomerAvatar/update_avatar_error_bubbles (0.00s)
        --- PASS: TestCustomerImageService/AddCustomerAvatar/insert_avatar_error_bubbles (0.00s)
        --- PASS: TestCustomerImageService/AddCustomerAvatar/static_avatar_updates_icon (0.00s)
        --- PASS: TestCustomerImageService/AddCustomerAvatar/static_avatar_same_icon_skips_update (0.00s)
        --- PASS: TestCustomerImageService/AddCustomerAvatar/static_avatar_clear_fails (0.00s)
        --- PASS: TestCustomerImageService/AddCustomerAvatar/static_avatar_profile_fetch_fails (0.00s)
        --- PASS: TestCustomerImageService/AddCustomerAvatar/static_avatar_update_icon_fails (0.00s)
        --- PASS: TestCustomerImageService/AddCustomerAvatar/personal_info_error_bubbles (0.00s)
        --- PASS: TestCustomerImageService/AddCustomerAvatar/publish_failure_still_succeeds (0.00s)
PASS
ok      tcg-uss-ae-go-sp/internal/apiserver/service/customerimage       0.261s
```

通过上面的示例，我们可以看到这种测试分层组织方式的优点如下：
测试报告结构清晰：输出结果按 TestType/Method/CaseName 的层次组织，非常易于定位具体哪个场景的测试失败。
逻辑聚合：将与同一类型或功能相关的所有测试都聚合在一个顶层测试函数下，方便管理和理解。
可共享 Setup/Teardown：可以在顶层 TestUserService 函数级别执行一次性的设置（如创建service 实例、初始化依赖等），并通过 t.Cleanup 注册清理逻辑。这些设置对所有子测试可见。

这种分层组织方式，使得即便是包含大量测试用例的包，其测试结构也能保持清晰和易于导航。


# 6.4 如何提升单测覆盖率？

掌握了单元测试的原则和相关工具后，紧接着我们需要思考的另一个重要问题是——当完成单元测试的编写之后，我们依据什么来判断代码
得到了充分的测试呢？在实际应用中，我们一般通过单元测试覆盖率指标来衡量单元测试对代码的覆盖程度。对于 Go 语言，我们能够
借助 go test 命令，通过下面的步骤，来统计在测试执行期间，源代码中实际运行的语句数量占所有可执行语句的比例，并生成详细
的覆盖率报告。首先，就像下面的示例一样，我们可以借助 go test  命令，并指定  -coverprofile  参数来生成详细的覆盖率
数据文件，同时它也会输出覆盖率的统计数据。

```shell
go test -coverprofile=coverage.out               
PASS
coverage: 100.0% of statements
ok      go-notes/goprincipleandpractise/unit-test    1.672s

```

接着，我们可以 go tool cover 来生成 HTML 格式的覆盖率报告。

```shell
go tool cover -html=coverage.out -o coverage.html
```

最后，打开 HTML 文件，我们就能看到单测覆盖率的详细情况了，展示内容如下。


![unit_test_coverage.png](images%2Funit_test_coverage.png)


为了提高单测覆盖率，除了依赖研发人员自觉编写更全面的测试用例外，我们还可以将单元测试集成到持续集成（CI）流程中。
通过这种方式，每次代码提交时，单元测试会自动运行，并检查覆盖率。如果覆盖率未达到预设的阈值，系统将阻止代码合并。
以 GitLab CI/CD 为例，为了实现单元测试覆盖率卡控，我们可以在项目的 .gitlab-ci.yml 文件中添加相应的配置节点，
并设置一个规则，当单元测试覆盖率低于 80% 时，测试将被标记为失败，不允许进行代码合并。具体可以参考后面的代码。


```shell
# 定义用于运行CI任务的Docker镜像，这里选择最新的Go语言镜像
# 该镜像将提供运行Go项目测试所需的环境
image: golang:latest  

# 定义CI/CD的阶段，这里只设置了一个test阶段用于执行单元测试
stages:  
  - test  

# test阶段的具体配置
test:  
  # 此阶段名称为test，用于执行单元测试任务
  stage: test  
  script:  
    # 更新项目的依赖项，确保所有依赖都是最新且正确的
    - go mod tidy  
    # 运行单元测试，并将覆盖率信息输出到coverage.out文件中
    - go test -coverprofile=coverage.out  
    # 提取并检查覆盖率信息
    # 首先，使用go tool cover -func=coverage.out命令获取覆盖率的详细信息
    # 然后，通过grep命令筛选出包含“total:”及覆盖率数值的行
    # 接着，使用awk命令提取出覆盖率数值
    # 最后，再次使用awk命令检查覆盖率是否低于80%，如果低于则使脚本以非零状态码退出，导致CI任务失败
    - go tool cover -func=coverage.out | grep -E "total:.*\d+.\d+%" | awk '{print $3}' | awk -F '%' '{if ($1 < 80) {exit 1}}'  
  allow_failure: false  
  # 设置为false表示此阶段任务不允许失败，如果单元测试失败或覆盖率不达标，整个CI流程将失败
```

## 6.5 测试覆盖率的真正意义

它衡量的是“执行过”，而非“验证过”：覆盖率工具只能告诉你哪些代码行在测试过程中被执行了，并不能判断这些代码行的逻辑是否被充分、正确地验证了。
一行代码可能被执行了，但相关的断言可能是缺失的或错误的。

高覆盖率是必要条件，但不是充分条件：
必要性：低覆盖率（例如，低于 70-80%）通常明确地指示测试不充分，有大量代码未经任何测试执行，存在潜在的 Bug 风险。追求一个合理的高覆盖率
（例如，80-90% 以上，具体目标因项目和团队而异）是应该的，它可以驱动我们思考如何测试到那些被遗漏的分支和逻辑。
非充分性：即使达到 100% 的语句覆盖率，也绝不意味着代码是无懈可击的。

### 6.5.1 覆盖率的局限性与误区

**100% 覆盖率的陷阱**
- 逻辑错误：覆盖率无法发现代码中的逻辑错误。如果代码的逻辑本身就是错的，即使 100% 覆盖，错误依然存在。
- 边界条件遗漏：测试可能覆盖了主要路径，但遗漏了关键的边界值、nil 输入、空集合、超大数据等可能引发问题的场景。
- 并发问题：语句覆盖率通常无法揭示数据竞争、死锁等并发缺陷。这些需要专门的并发测试策略和 -race 检测器。
- 性能问题、安全漏洞、可用性问题等也无法通过简单的代码覆盖率来衡量。
- 依赖外部系统的交互：如果对外部依赖使用了 Mock，Mock 本身的代码会被覆盖，但与真实外部系统交互的潜在问题
（如 API 变更、网络问题）则无法通过单元测试覆盖率反映。

**只追求数字的危险**
如果团队将覆盖率百分比作为唯一的、强制性的 KPI，可能会导致开发者为了“刷数据”而编写大量低质量、无实际验证意义的测试
（例如，只调用函数，不检查返回值或副作用）。这种测试不仅浪费时间，还会给人一种虚假的安全感。

**无法覆盖或难以覆盖的场景**
- 某些极端的错误处理路径（例如，模拟磁盘满、网络完全断开、硬件故障等）在单元测试中可能非常难以或不值得去模拟和覆盖。
- 直接调用 os.Exit() 或 panic 且未被恢复（recover）的代码路径。
- 某些与特定操作系统或环境强相关的代码。

### 6.5.2 科学地看待和使用覆盖率

- 将其作为发现测试盲点的工具，而非最终目标：
当覆盖率报告显示某些代码块是红色（未覆盖）时，这应该促使你去分析：为什么这部分代码没有被测试到？是测试用例设计不全，还是
这部分代码确实难以通过单元测试覆盖（可能需要集成测试）？或者，这部分代码甚至是“死代码”（dead code）？

- 结合代码审查、逻辑分析和业务场景理解
在评估测试充分性时，不能只看覆盖率数字。需要结合对代码逻辑的理解、对业务需求的掌握，以及通过代码审查来判断测试用例是否
覆盖了所有重要的场景、边界条件和潜在的错误路径。关注覆盖率的变化趋势，并设定合理的目标：对于新代码，要求有较高的初始覆盖率。
对于遗留代码，逐步提升覆盖率。设定一个团队共同认可的、合理的覆盖率目标（例如，85%），并将其作为质量门禁之一，但不要唯数字论。

- 不要为了 100% 而 100%
追求最后几个百分点的覆盖率，其投入产出比可能会非常低。将精力投入到测试那些业务关键、逻辑复杂、易出错的模块上，可能比死磕一些
无关紧要的边缘代码覆盖率更有价值。

总之，测试覆盖率是一个有用的工具，但绝不是衡量测试质量的唯一标准，更不是代码质量的等价物。它需要与其他测试实践、代码质量保障手段
（比如静态代码检查、代码审查、手动测试等）结合使用，才能发挥其最大价值。