
---
单元测试详解
---

# 1 什么是单元测试？

所谓单元测试（unit testing），是指对软件中的最小可测试单元进行检查和验证，在 Golang 编程语境里，这通常具体指代
单个函数。单元测试遵循着 AAA（Arrange-Act-Assert）的代码组织结构，就像下面的代码一样。

```go
func TestAdd(t *testing.T) {
    // Arrange(安排）
    a := 5
    b := 3
    expected := 8

    // Act（行动）
    result := Add(a, b)

    // Assert（断言）
    assert.Equal(t, expected, result)
}
```

首先在 Arrange 部分，我们需要准备测试所需的所有前置条件，比如初始化被测试对象、准备输入数据、创建模拟对象
（如果有外部依赖）等。接着，在 Act 部分，我们需要调用被测试的函数或方法，触发实际的行为。最后在 Assert 部分，
需要验证调用的结果是否符合预期。由于单元测试是针对单个函数的细粒度测试，所以一旦某个用例未能通过测试，我们就
能迅速将问题锁定在这个函数的内部，从而更高效地定位问题根源。

不过，根据阿里巴巴 Java 手册的规范，一个好的单元测试在宏观层面必须遵循下面的 AIR 原则。

首先是 Automatic（自动化）原则。单元测试必须自动运行，不能手动检查结果。例如，我们不能通过打印输出来检查，
而应该使用断言（assert）来验证结果是否正确。

接着是 Independent（独立性）原则。每个测试用例应该独立运行，不依赖其他测试用例。如果测试用例相互依赖，
一旦某个测试失败，其他依赖它的测试也可能失败，导致我们难以确定问题所在。比如就像下面的代码，
TestMultiplyBySum 依赖 TestAdd 的结果，如果 TestAdd 失败或未执行，会导致 TestMultiplyBySum 的结果不准确。


```go
var sumResult int

func TestAdd(t *testing.T) {
    result := Add(2, 3)
    sumResult = result
    expected = 5
    assert.Equal(t, expected, result)
}

func TestMultiplyBySum(t *testing.T) {
    // 依赖 TestAdd 测试的结果
    result := MultiplyBySum(2, 3, 4)
    expected := sumResult * 4
    assert.Equal(t, expected, result)
}
```

最后是 Repeatable（可重复）原则。单元测试在任何时间和环境下执行，结果都应该一致，不受外部环境影响。在持续集成中，
频繁执行的测试如果结果不稳定，会降低开发人员对测试结果的信任度，也难以定位和修复问题。为避免依赖外部资源，我们可以
用 Mock 框架模拟第三方资源，比如用 Mock 框架模拟外部 API 响应来进行测试。

如果要让单元测试切实遵循这三大原则，断言库与 Mock 框架的支持是不可或缺的。

# 2 为什么要写单元测试？

## 2.1 单元测试是将 Bug 控制在编码阶段的唯一手段

![bug_during_test_stages.png](images%2Fbug_during_test_stages.png)

上图出自 Capers Jones 在 1996 年出版的 《Applied Software Measurement》，它是一张经典图表，展示了软件开发生命周期中
的缺陷发现和修复成本。这张图在软件工程领域非常有影响力，经常被用来说明“尽早测试、尽早发现问题”的重要性。那接下来，我们就一起来
分析这张图上的重要信息。从这张图上，我们可以总结出缺陷分布的规律：编码阶段发现缺陷的比例最高（约 85%）, 后续阶段发现缺陷的比例
逐渐降低。我们注意到，85% 的缺陷 Bug 都是在编码阶段出现的。
这里的 Bug 不仅局限于语法错误这种简单问题，还包括业务逻辑错误、配置不合理等。对于那些声称“我写的代码不会出错，用不着单元测试”的
开发同学，我只能说盲目自信带来的只能是“世界级”的灾难。因此，在业务功能开发过程中，我们应当保持一种“悲观”的心态，按照代码行数
百分比来预估你的缺陷数量。比如这次功能开发完成，我们使用了 1000 行代码。此时，我们可以按照每 200 行出现一个 Bug 的频率进行预估
（这个数值应该根据自身的经验值调整）。你心里需要有个数，对于这个功能，至少有 5 个 Bug 需要自己和测试同学一起查出来。此外，这张
图还告诉我们：Bug 修复的成本随着时间推移越来越高。我们可以看到：黑色曲线表示修复缺陷的成本（$）。曲线显示越晚发现缺陷，修复成本越高，
从编码阶段的 $25 上升到发布后的 $16000。

我们可以把一个业务看成一架飞机，如果没有完备的单元测试，就像在组装这架飞机时，各个组件没有经过严格的检验，只是单纯地将它组装完成，
然后通过试飞来检验飞机是否正常运行。平时，这架飞机看起来或许可以正常飞行。但恐怖的是，我们根本无法预知什么时候飞机会出问题，
又会在什么时候发生解体。等到飞机进入生产环境，一旦发生解体，后果就是机毁人亡，由此带来的成本和代价无疑是极其巨大的。所以我才说，
单元测试是将 Bug 控制在编码阶段的唯一手段！

单元测试是所有测试中最底层的一类测试，是第一个环节，也是最重要的一个环节，是唯一一次能够保证代码覆盖率达到 100% 的测试。
作为开发人员，同时也是单元测试的主要执行者，在交付生产环境代码时，你就应该编写足够的单元测试，以便将 Bug 控制在编码阶段，
避免后期在生产环境中出现无可挽回的事故。

## 2.2  测试金字塔
![test_pyramid.png](images%2Ftest_pyramid.png)

测试金字塔的最底层是单元测试，它是对代码进行测试。再上一层是集成测试，它是对一个服务的接口进行测试。再上一层是端到端的测试，
我也称它为链路测试，它负责从一个链路的入口输入测试用例，将测试运行在链路上的多个服务中，以此来验证整个链路的运行结果。位于
顶层的是我们最常用的 UI 测试，即测试同学在 UI 界面上根据功能进行点击，以此来完成测试。

那如果不编写单元测试，后面的集成测试能够帮我测试出问题吗？

从测试的角度来看，后面进行的集成测试、全链路测试、UI 测试都属于黑盒测试。 对于测试同学来说，代码就是一个无法看到内部的黑盒。
由于业务的逻辑代码繁多且分支错综复杂，测试同学是无法设计出完善的集成测试用例的，一定会存在覆盖不到的分支。而这些覆盖不到的
分支产生的严重后果，不应该只有测试同学来承担，其实更多是开发同学没有完备的单元测试导致的。而且这种思想也是一种懒惰的表现，
并且逐渐和现在的大厂业务模式相背离。现在的大厂越来越推崇 DevOps 的开发模式，在这种模式下，开发同学会承担越来越多的角色，
开发、测试、运维这些角色的职责都集中在开发同学身上。DevOps 推崇开发同学对自己的代码负责，同时对代码运行在生产环境中的
运维情况负责。记住，自己的代码质量，永远不要依赖他人，包括测试同学。

# 3 如何写可测试的代码

我们要明白，并不是所有的代码都叫做“可测试的代码”。编写可测试的代码是软件开发的一个重要前提，对任何语言都是如此。所以接下来，
我们给出一系列编写可测试代码的最佳实践。

## 3.1  避免全局状态
尽量避免使用全局变量，因为它们会使测试变得复杂。如果必须使用全局状态，可以考虑使用其他方式来控制全局状态。比如下面这段代码：

```go
var GlobalPrice = 1
func Foo() bool { 
	if GlobalPrice > 1 { 
		return true 
	} 
	return false
}
```

这段代码中的 Foo 函数依赖了全局变量 Global，这个函数的可测试性很低，因为 Foo 函数的返回值依赖一个全局变量 GlobalPrice，
而我们不知道这个全局变量在 Foo 函数调用之前是否被其他函数修改过。相对比较好的代码是：

```go
var GlobalPrice = 1
...
func Foo(price int) bool {
  if price > 1 {
    return true
  }  
  return false
}

```

## 3.2 函数要有稳定的输入和输出
函数应该接收参数并返回结果，并且这种输出是稳定的，不是有随机性的。比如下面的代码：

```go
func Foo() bool {
  if time.Now().Timestamp() % 10 > 3 {
    return true
  }  
  return false
}
```

这段代码返回的结构和当前运行的时间有关，即使每次输入一样，返回值也是不一样的，有一定随机性，所以这样的函数是无法测试的。

## 3.3 依赖注入
使用依赖注入将外部依赖（如数据库连接、HTTP 客户端等）传递给函数或结构体，而不是在函数内部创建这些依赖。这使得我们在测试阶段
可以传入模拟（Mock）对象。我们在定义一个结构体的时候，尽量将它的外部依赖项，比如它依赖什么存储、什么缓存，作为结构体的元素。
下面的结构体就比较合适：

```go
// 缓存服务
type CacheService struct {
  redisClient *redis.Client
}


// 初始化
func NewCacheService(redisClient *redis.Client) *CacheService {
    return &CacheService{
      redisClient: redisClient
    }
}


// 从缓存中获取个数
func (s *CacheService) GetCount(ctx context.Context) (uint64, err) {
  return s.redisClient.Get("foo:count")
}
```

在测试这个 GetCount 方法时，我们可以 mock 一个 redisClient，然后使用 NewCacheService 的方法初始化一个 CacheService 进行测试。
你可以比较下面这个函数：

```go
// 缓存服务
type CacheService struct {
}


// 初始化
func NewCacheService() *CacheService {
    return &CacheService{ }
}


// 从缓存中获取个数
func (s *CacheService) GetCount(ctx context.Context) (uint64, err) {
    redisClient := client.NewConnect("username", "password")
    redisClient.connect()
  return redisClient.Get("foo:count")
}

```

这个代码中的 GetCount 函数，在函数内部直接初始化了一个 Redis 的连接，所以，当我们在用这个函数写测试用例时，如果想用 mock redis 
来执行这个函数是无能为力的。这就是一种不好的函数实现方式。写出可以“依赖注入”的代码对于单元测试非常重要。

## 3.4 小函数和单一职责
将代码拆分成小函数，每个函数只做一件事。这样可以更容易地编写单元测试，并且测试覆盖率更高。这个原则其实不只是为了代码可测性，
对于代码可读性等都有裨益。我演示一个很差的代码函数你就能理解了。

```go
// bad_example.go
func ProcessOrder(userID int64, items []OrderItem, couponCode string, addressID int64) error {
    // 一个大函数包含了所有逻辑
    db, err := sql.Open("mysql", "user:password@/dbname")
    if err != nil {
        return fmt.Errorf("数据库连接失败: %w", err)
    }
    defer db.Close()


    // 查询用户信息
    var user User
    err = db.QueryRow("SELECT id, email, balance FROM users WHERE id = ?", userID).
        Scan(&user.ID, &user.Email, &user.Balance)
    if err != nil {
        return fmt.Errorf("查询用户失败: %w", err)
    }


    // 计算商品总价
    var total float64
    for _, item := range items {
        var price float64
        var stock int
        err = db.QueryRow("SELECT price, stock FROM products WHERE id = ?", item.ProductID).
            Scan(&price, &stock)
        if err != nil {
            return fmt.Errorf("查询商品失败: %w", err)
        }
        
        if stock < item.Quantity {
            return fmt.Errorf("商品 %d 库存不足", item.ProductID)
        }
        
        total += price * float64(item.Quantity)
    }


    // 优惠券处理
    if couponCode != "" {
        var discount float64
        var minAmount float64
        var used bool
        err = db.QueryRow(`
            SELECT discount, min_amount, used 
            FROM coupons 
            WHERE code = ? AND user_id = ? AND expire_time > NOW()`,
            couponCode, userID).
            Scan(&discount, &minAmount, &used)
        
        if err != nil {
            return fmt.Errorf("查询优惠券失败: %w", err)
        }
        
        if used {
            return errors.New("优惠券已使用")
        }
        
        if total < minAmount {
            return fmt.Errorf("订单金额未达到优惠券使用门槛 %.2f", minAmount)
        }
        
        total = total * (1 - discount)
    }


    // 检查用户余额
    if user.Balance < total {
        return errors.New("用户余额不足")
    }


    // 查询收货地址
    var address Address
    err = db.QueryRow("SELECT province, city, detail FROM addresses WHERE id = ? AND user_id = ?",
        addressID, userID).
        Scan(&address.Province, &address.City, &address.Detail)
    if err != nil {
        return fmt.Errorf("查询地址失败: %w", err)
    }


    // 开启事务
    tx, err := db.Begin()
    if err != nil {
        return fmt.Errorf("开启事务失败: %w", err)
    }
    defer tx.Rollback()


    // 扣减库存
    for _, item := range items {
        _, err = tx.Exec("UPDATE products SET stock = stock - ? WHERE id = ?",
            item.Quantity, item.ProductID)
        if err != nil {
            return fmt.Errorf("更新库存失败: %w", err)
        }
    }


    // 扣减余额
    _, err = tx.Exec("UPDATE users SET balance = balance - ? WHERE id = ?",
        total, userID)
    if err != nil {
        return fmt.Errorf("扣减余额失败: %w", err)
    }


    // 标记优惠券已使用
    if couponCode != "" {
        _, err = tx.Exec("UPDATE coupons SET used = true WHERE code = ?",
            couponCode)
        if err != nil {
            return fmt.Errorf("更新优惠券状态失败: %w", err)
        }
    }


    // 创建订单
    orderResult, err := tx.Exec(`
        INSERT INTO orders (user_id, total_amount, address_id, status, created_at)
        VALUES (?, ?, ?, 'pending', NOW())`,
        userID, total, addressID)
    if err != nil {
        return fmt.Errorf("创建订单失败: %w", err)
    }


    orderID, _ := orderResult.LastInsertId()


    // 创建订单详情
    for _, item := range items {
        _, err = tx.Exec(`
            INSERT INTO order_items (order_id, product_id, quantity, price)
            VALUES (?, ?, ?, ?)`,
            orderID, item.ProductID, item.Quantity, item.Price)
        if err != nil {
            return fmt.Errorf("创建订单详情失败: %w", err)
        }
    }


    // 提交事务
    if err = tx.Commit(); err != nil {
        return fmt.Errorf("提交事务失败: %w", err)
    }


    // 发送订单确认邮件
    smtp.SendMail("smtp.example.com:587", nil,
        "shop@example.com", []string{user.Email},
        []byte(fmt.Sprintf("您的订单 %d 已创建,总金额: %.2f", orderID, total)))


    // 发送通知给库存系统
    kafka.Send("stock_update", map[string]interface{}{
        "order_id": orderID,
        "items":    items,
    })


    return nil
}

```

这个函数有 150 行左右，其中包括了订单的所有流程，同时涉及多个 SQL 请求和一个大事务。遇到这种函数时，你一定会产生这样的想法：这怎么写测试用例啊？
确实，这不是你的问题，而是这个函数过于庞大导致的。它应该将其中逻辑相近的几个子步骤合并，进而抽象出子函数。这样不仅可读性变高，这些子函数的测试用例
也就可以写了。

# 4 断言：如何判断结果符合预期？
在 Go 的实践中，testify 和 goconvey 两个断言库使用较为广泛。testify 的断言风格和其它编程语言中的断言库类似，
测试用例结构简单，对于开发者而言，极易上手。就像下面这段代码所展示的，借助 testify 库 assert 包里的断言函数，
我们就能够直接针对结果进行断言检查。

```go
import (
    "testing"

    "github.com/stretchr/testify/assert"
)

func TestAddWithTestify(t *testing.T) {
    a := 3
    b := 5
    result := Add(a, b)
    expected := 7

    // Assert
    assert.Equal(t, expected, result, "Add(3, 5) should return 8")
}
```

而 goconvey 库的功能更为强大，不过相应地，它的学习成本也相对较高。goconvey 库的核心在于 Convey 和 So 这两个函数。
Convey 函数主要用于描述测试场景，而 So 则负责对结果进行断言。值得一提的是，goconvey 还支持分组嵌套测试的代码组织结构，
这种特性使它在大型项目中表现出色，能够更好地组织和管理复杂的测试用例。

以下面的代码为例。这段代码最外层的 Convey 函数描述了整个测试的主题是 “关于 Add 函数的测试”。第一层嵌套的 Convey 
分别描述了 “正常情况的测试” 和 “边界情况的测试” 这两个分组。第二层嵌套的 Convey 针对每个分组下的具体测试场景进行
描述，并在每个场景中调用 Add 函数，使用 So 进行断言验证结果是否符合预期。


```go
import (
    . "github.com/smartystreets/goconvey/convey"
)
func TestAddWithConvey(t *testing.T) {
    Convey("关于Add函数的测试", t, func() {
        Convey("正常情况的测试", func() {
            Convey("两个正数相加", func() {
                result := Add(2, 3)
                So(result, ShouldEqual, 5)
            })
            Convey("一个正数和一个负数相加", func() {
                result := Add(5, -3)
                So(result, ShouldEqual, 2)
            })
        })
        Convey("边界情况的测试", func() {
            Convey("两个零相加", func() {
                result := Add(0, 0)
                So(result, ShouldEqual, 0)
            })
            Convey("一个数与最大整数相加", func() {
                result := Add(int(math.MaxInt32), 1)
                So(result, ShouldEqual, int(math.MaxInt32)+1)
            })
        })
    })
}
```

# 5 Mock：如何去除不稳定依赖？

在 Go 实践中，我们可以使用应用广泛的 gomonkey 库来实现 mock 功能。gomonkey 库通过 Monkey patch 技术，在程序
运行时巧妙地改写函数指令，达到 mock 的目的。以下面代码为例，我们使用 ApplyFunc 函数，对不稳定的 HTTP 调用进行
mock 替换，这样可以有效规避违反单元测试 Repeatable 原则的风险。


```go
import (
    "github.com/agiledragon/gomonkey/v2"
)

// 发送HTTP GET请求并返回响应的函数
func httpGetRequest(url string) ([]byte, error) {
    resp, err := http.Get(url)
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()
    return io.ReadAll(resp.Body)
}

// 依赖httpGetRequest函数获取用户信息的函数
func fetchUserInfo(userID string) (string, error) {
    url := "https://example.com/api/user/" + userID
    data, err := httpGetRequest(url)
    if err != nil {
        return "", err
    }
    return string(data), nil
}

func TestMock(t *testing.T) {
    // 使用gomonkey mock函数httpGetRequest的返回
    mockData := []byte(`{"name":"killianxu","age":32}`)
    patch := gomonkey.ApplyFunc(httpGetRequest, func(url string) ([]byte, error) {
        return mockData, nil
    })
    defer patch.Reset()

    // 底层httpGetRequest的函数调用返回，会被mock
    mockUserInfo, _ := fetchUserInfo("123")

    fmt.Printf("mocked user info: %s\n", mockUserInfo)
}

// 输出
killianxu@KILLIANXU-MB0 mock % go test -gcflags=all=-l
mocked user info: {"name":"killianxu","age":32}
```

# 6 如何提升单测覆盖率？

掌握了单元测试的原则和相关工具后，紧接着我们需要思考的另一个重要问题是——当完成单元测试的编写之后，我们依据什么来判断代码
得到了充分的测试呢？在实际应用中，我们一般通过单元测试覆盖率指标来衡量单元测试对代码的覆盖程度。对于 Go 语言，我们能够
借助 go test 命令，通过下面的步骤，来统计在测试执行期间，源代码中实际运行的语句数量占所有可执行语句的比例，并生成详细
的覆盖率报告。首先，就像下面的示例一样，我们可以借助 go test  命令，并指定  -coverprofile  参数来生成详细的覆盖率
数据文件，同时它也会输出覆盖率的统计数据。

```shell
go test -coverprofile=coverage.out               
PASS
coverage: 100.0% of statements
ok      go-notes/goprincipleandpractise/unit-test    1.672s

```

接着，我们可以 go tool cover 来生成 HTML 格式的覆盖率报告。

```shell
go tool cover -html=coverage.out -o coverage.html
```

最后，打开 HTML 文件，我们就能看到单测覆盖率的详细情况了，展示内容如下。


![unit_test_coverage.png](images%2Funit_test_coverage.png)


为了提高单测覆盖率，除了依赖研发人员自觉编写更全面的测试用例外，我们还可以将单元测试集成到持续集成（CI）流程中。
通过这种方式，每次代码提交时，单元测试会自动运行，并检查覆盖率。如果覆盖率未达到预设的阈值，系统将阻止代码合并。
以 GitLab CI/CD 为例，为了实现单元测试覆盖率卡控，我们可以在项目的 .gitlab-ci.yml 文件中添加相应的配置节点，
并设置一个规则，当单元测试覆盖率低于 80% 时，测试将被标记为失败，不允许进行代码合并。具体你可以参考后面的代码。


```shell
# 定义用于运行CI任务的Docker镜像，这里选择最新的Go语言镜像
# 该镜像将提供运行Go项目测试所需的环境
image: golang:latest  

# 定义CI/CD的阶段，这里只设置了一个test阶段用于执行单元测试
stages:  
  - test  

# test阶段的具体配置
test:  
  # 此阶段名称为test，用于执行单元测试任务
  stage: test  
  script:  
    # 更新项目的依赖项，确保所有依赖都是最新且正确的
    - go mod tidy  
    # 运行单元测试，并将覆盖率信息输出到coverage.out文件中
    - go test -coverprofile=coverage.out  
    # 提取并检查覆盖率信息
    # 首先，使用go tool cover -func=coverage.out命令获取覆盖率的详细信息
    # 然后，通过grep命令筛选出包含“total:”及覆盖率数值的行
    # 接着，使用awk命令提取出覆盖率数值
    # 最后，再次使用awk命令检查覆盖率是否低于80%，如果低于则使脚本以非零状态码退出，导致CI任务失败
    - go tool cover -func=coverage.out | grep -E "total:.*\d+.\d+%" | awk '{print $3}' | awk -F '%' '{if ($1 < 80) {exit 1}}'  
  allow_failure: false  
  # 设置为false表示此阶段任务不允许失败，如果单元测试失败或覆盖率不达标，整个CI流程将失败
```

绝大多数开发人员都不愿意写单元测试，因为设计覆盖各种边界条件和异常情况的测试用例比较麻烦，往往单元测试的代码比业务代码
量还要大好几倍，但是要保障代码的质量，单元测试和code review是最有效的手段。而今，随着AI大模型的出现，尤其是具有
强大逻辑推理能力的AI工具的出现，无疑是我们程序员的福音。它不仅可以帮助我们厘清老代码的结构和思路，帮助我们排查bug，
定位问题，检查代码的可读性，维护性和可扩展性，为单元测试设计覆盖率高的测试用例更不在话下。

本节案例中的单元测试用例就是使用ChatGPT o3 minin模型自动生成的。