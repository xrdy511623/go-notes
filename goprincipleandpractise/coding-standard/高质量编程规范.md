
---
高质量编程
---

**什么是高质量?**
- 编写的代码能够达到正确可靠，简洁清晰的目标称之为高质量代码。
- 各种边界条件是否考虑完备；
- 异常情况处理，稳定性保证；
- 易读易维护。


# 1.1 编程原则
实际应用场景千变万化，各种语言的特性和语法各不相同，但是高质量编程遵循的原则是相通的。

**简单性**；
- 消除"多余的复杂性"，以简单清晰的逻辑编写代码。
- 不理解的代码无法修复改进。

**可读性**；
- 代码是写给人看的，而不是机器。
- 编写可维护的代码的第一步是确保代码可读。

**生产力**；
- 团队整体的工作效率非常重要。


# 1.2 编码规范
如何编写高质量的Go代码？

- [代码格式](#code-format)
- [注释](#comments)
- [命名规范](#naming)
- [控制流程](#control-flow)
- [错误和异常处理](#error-handling)
- [并发编程规范](#concurrency)
- [接口设计](#interface-design)
- [defer使用规范](#defer-guidelines)
- [context使用规范](#context-guidelines)

<a id="code-format"></a>
## 1.2.1 代码格式

推荐使用gofmt自动格式化代码。
Go语言官方提供的工具，能自动格式化Go语言代码为官方统一风格。
常见IDE都支持方便的配置

goimports也是Go语言官方提供的工具，实际等于gofmt加上依赖包管理，自动增删依赖包的引用，将依赖包按字母顺序排序并分类。

<a id="comments"></a>
## 1.2.2 注释

简介
注释应该做的：
**注释应该解释代码作用**

```golang
// Open opens the named file for reading. If successful, methods on
// the returned file can be used for reading; the associated file
// descriptor has mode O_RDONLY.
// If there is an error, it will be of type *PathError.
func Open(name string) (*File, error) {
	return OpenFile(name, O_RDONLY, 0)
}
```
适合注释公共符号

**注释应该解释代码是如何做的(实现逻辑)**

```golang
// Add the Referer header from the most recent
// request URL to the new one, if it's not https->http:
if ref := refererForURL(reqs[len(reqs)-1].URL, req.URL); ref != "" {
    req.Header.Set("Referer", ref)
}
```
适合注释实现过程

**注释应该解释代码实现的原因**

```golang
switch resp.StatusCode {
	// ...
	case 307, 308:
		redirectMethod = reqMethod
		shouldRedirect = true
		includeBody = true

		if ireq.GetBody == nil && ireq.outgoingLength() != 0 {
			// We had a request body, and 307/308 require
			// re-sending it, but GetBody is not defined. So just
			// return this response to the user instead of an
			// error, like we did in Go 1.7 and earlier.
			shouldRedirect = false
		}
	}
```
适合解释代码的外部因素;
提供额外的上下文。

**注释应该解释代码什么情况下会出错**
```golang
// parseTimeZone parses a time zone string and returns its length. Time zones
// are human-generated and unpredictable. We can't do precise error checking.
// On the other hand, for a correct parse there must be a time zone at the
// beginning of the string, so it's almost always true that there's one
// there. We look at the beginning of the string for a run of upper-case letters.
// If there are more than 5, it's an error.
// If there are 4 or 5 and the last is a T, it's a time zone.
// If there are 3, it's a time zone.
// Otherwise, other than special cases, it's not a time zone.
// GMT is special because it can have an hour offset.
func parseTimeZone(value string) (length int, ok bool) 
```
适合解释代码的限制条件

**公共符号始终要注释**

```golang
// ReadAll reads from r until an error or EOF and returns the data it read.
// A successful call returns err == nil, not err == EOF. Because ReadAll is
// defined to read from src until EOF, it does not treat an EOF from Read
// as an error to be reported.
func ReadAll(r Reader) ([]byte, error)
```
>包中声明的每个公共符号: 变量、常量、函数以及结构都需要添加注释。

```golang
// LimitReader returns a Reader that reads from r
// but stops with EOF after n bytes.
// The underlying implementation is a *LimitedReader.
func LimitReader(r Reader, n int64) Reader { return &LimitedReader{r, n} }

// A LimitedReader reads from R but limits the amount of
// data returned to just N bytes. Each call to Read
// updates N to reflect the new amount remaining.
// Read returns EOF when N <= 0 or when the underlying R returns EOF.
type LimitedReader struct {
	R Reader // underlying reader
	N int64  // max bytes remaining
}

func (l *LimitedReader) Read(p []byte) (n int, err error) {
	if l.N <= 0 {
		return 0, EOF
	}
	if int64(len(p)) > l.N {
		p = p[0:l.N]
	}
	n, err = l.R.Read(p)
	l.N -= int64(n)
	return
}
```
尽管LimitedReader.Read本身没有注释，但它紧跟LimitedReader结构的声明，明确它的作用。

有一个例外，不需要注释实现接口的方法。
- 任何既不明显也不简短的公共功能必须予以注释。
- 无论长度或复杂程度如何，对库中的任何函数都必须进行注释。

小结: 代码是最好的注释，注释应该提供代码未表达出的上下文信息。

<a id="naming"></a>
## 1.2.3 命名规范
**变量**
- 简洁胜于冗长；
- 缩略词全大写，但当其位于变量开头且不需要导出时，使用全小写。

例如使用ServeHTTP 而不是 ServeHttp。
使用XMLHTTPRequest 或者xmlHTTPRequest。

```golang
// bad
for index:=0;index<len(s);index++ {
	// do something
}

// good
for i:=0;i<len(s);i++ {
	// do something
}
```
i和index的作用域范围仅限于for循环内部时，index的额外冗长几乎没有增加对于程序的理解。

- 变量距离其被使用的地方越远，则需要携带越多的上下文信息。
- 全局变量在其名字中需要更多的上下文信息，使得在不同地方可以轻易辨认出其含义。

```golang
// good
func(c *Client) send(req *request, deadline time.Time)

// bad
func(c *Client) send(req *request, t time.Time)
```
将deadline替换成t降低了变量名的信息量
t常指代任意时间；
而deadline指截止时间，有特定含义。

**function**
- 函数名不携带包名的上下文信息，因为包名和函数名总是成对出现的。

譬如，标准库time中，会使用Now()而不是NowTime()来获取本地当前时间

- 函数名尽量简短

当名为foo的包的某个函数返回类型Foo时，可以省略类型信息而不导致歧义。
```golang
// Add returns the time t+d.
func (t Time) Add(d Duration) Time
```
标准库里的Add函数返回的是Time类型，所以函数名Add就省略了类型信息Time

当名为foo的包的某个函数返回类型T时(T并不是Foo)，可以在函数名中加入类型信息。
譬如，标准库time中，会使用ParseDuration()而不是Parse()来解析一个duration字符串，因为这个函数返回类型是Duration， 所以在函数名中加上了类型信息Duration。

```golang
// ParseDuration parses a duration string.
// A duration string is a possibly signed sequence of
// decimal numbers, each with optional fraction and a unit suffix,
// such as "300ms", "-1.5h" or "2h45m".
// Valid time units are "ns", "us" (or "µs"), "ms", "s", "m", "h".
func ParseDuration(s string) (Duration, error)
```

**package**
- 只由小写字母组成，不包含大写字母和下划线等字符。
- 简短并包含一定的上下文信息，例如schema、task等。
- 不要与标准库同名，例如不要使用sync或者strings。

以下规则尽量满足，以标准库包名为例
- 不使用常用变量名作为包名，例如使用bufio而不是buf。
- 使用单数而不是复数，例如使用encoding而不是encodings。
- 谨慎地使用缩写，例如使用fmt在不破坏上下文的情况下比format更加简短。

**小结**
- 核心目标是降低代码的阅读理解成本。
- 重点考虑上下文信息，设计简洁清晰的名称。

Good naming is like a joke, if you have to explain it,it`s not funny.

<a id="control-flow"></a>
## 1.2.4 控制流程

- 避免嵌套，保持正常流程清晰；
- 尽量保持正常代码路径为最小缩进；
- 优先处理错误情况/特殊情况，尽早返回或继续循环来减少嵌套；

```golang
// bad
if foo {
	return x
} else {
	return nil
}

// good
if foo {
	return x
}
return nil
```

```golang
// bad
func BadFunc() error {
	err := doSomething()
	if err == nil {
		err := doAnotherThing()
		if err == nil {
			// normal case
			return nil
       }
	   return err
    }
	return err
}
```

```golang
// good
func GoodFunc() error {
	if err := doSomething(); err != nil {
		return err
    }
	if err := doAnotherThing(); err != nil {
		return err
    }
    // normal case
	return nil
}
```

```golang
func (b *Reader) UnreadByte() error {
	if b.lastByte < 0 || b.r == 0 && b.w > 0 {
		return ErrInvalidUnreadByte
	}
	// b.r > 0 || b.w == 0
	if b.r > 0 {
		b.r--
	} else {
		// b.r == 0 && b.w == 0
		b.w = 1
	}
	b.buf[b.r] = byte(b.lastByte)
	b.lastByte = -1
	b.lastRuneSize = -1
	return nil
}
```


**小结**
- 线性原理，处理逻辑尽量走直线，避免复杂的嵌套分支；
- 正常流程代码沿着屏幕向下移动；
- 提升代码可维护性和可读性；
- 故障问题大多出现在复杂的条件语句和循环语句中。

<a id="error-handling"></a>
## 1.2.5 错误和异常处理

**简单错误**
- 简单的错误指的是仅出现一次的错误，且在其他地方不需要捕获该错误。
- 优先使用errors.New创建匿名变量来直接表示简单错误。
- 如果有格式化的需求，使用fmt.Errorf

```golang
func defaultCheckRedirect(req *Request, via []*Request) error {
	if len(via) >= 10 {
		return errors.New("stopped after 10 redirects")
	}
	return nil
}
```

**错误的Wrap和Unwrap**
错误的Wrap实际上是提供了一个error嵌套另一个error的能力，从而生成一个error的跟踪链。
在fmt.Errorf中使用: %w关键字来将一个错误关联至错误链中。

```golang
list, _, err := c.GetBytes(cache.Subkey(a.actionID, "srcfiles"))
	if err != nil {
		return fmt.Errorf("reading srcfiles list: %w", err)
	}
```

**错误判定**

判定一个错误是否为特定错误，使用errors.Is(判断被包装过的error是否包含指定错误)
不同于使用==，使用该方法可以判定错误链上的所有错误是否含有特定错误。

```golang
data, err = lockedfile.Read(targ)
if errors.Is(err, fs.ErrNotExist) {
    // Treat non-existent as empty, to bootstrap the "latest" file
    // the first time we connect to a given database.
    return []byte{}, nil
}
return data, err
```

在错误链上获取特定种类的错误，使用errors.As(判断被包装过的error是否为指定类型)

```golang
if _, err := os.Open("non-existing"); err != nil {
		var pathError *fs.PathError
		if errors.As(err, &pathError) {
			fmt.Println("Failed at path:", pathError.Path)
		} else {
			fmt.Println(err)
		}
}
```

**panic**
- 不建议在业务代码中使用panic。
- 如此，调用函数不包含recover会造成程序崩溃。
- 若问题可以被屏蔽或解决，建议使用error代替panic
- 当程序启动阶段发生不可逆转的错误时，可以在init或main函数中使用panic。

```golang
ctx, cancel := context.WithCancel(context.Background())
client, err := sarama.NewConsumerGroup(strings.Split(brokers, ","), group, config)
if err != nil {
    log.Panicf("Error creating consumer group client: %v", err)
}
```

**recover**
- recover只能在被defer的函数中使用
- 嵌套无法生效
- 只在当前goroutine生效
- defer的语句是后进先出。
- 如果需要更多的上下文信息，可以recover后在log中记录当前的调用栈。

- error尽可能提供简明的上下文信息链，方便定位问题。
- panic用于真正异常的情况。
- recover生效范围是在当前goroutine的被defer函数中生效。


<a id="concurrency"></a>
## 1.2.6 并发编程规范

Go的并发是其最核心的特性之一，但也是最容易出错的地方。

**goroutine管理**
- 启动goroutine时，必须清楚它何时以及如何退出，避免goroutine泄漏。
- 使用`context.Context`或`done channel`控制goroutine的生命周期。

```golang
// bad: goroutine可能永远不会退出
go func() {
	for {
		data := <-ch // 如果ch永远没有数据，goroutine泄漏
		process(data)
	}
}()

// good: 通过context控制退出
go func(ctx context.Context) {
	for {
		select {
		case <-ctx.Done():
			return
		case data := <-ch:
			process(data)
		}
	}
}(ctx)
```

**channel使用原则**
- 优先使用有缓冲的channel来减少goroutine阻塞。
- channel的发送方负责关闭channel，接收方不要关闭。
- 使用`select`同时监听多个channel，并始终包含超时或退出机制。

```golang
select {
case result := <-resultCh:
	handleResult(result)
case err := <-errCh:
	handleError(err)
case <-time.After(5 * time.Second):
	handleTimeout()
}
```

**sync包使用建议**
- `sync.Mutex`保护临界区应尽量小，减少持锁时间。
- 读多写少的场景优先使用`sync.RWMutex`。
- `sync.Once`用于确保初始化操作只执行一次。
- `sync.WaitGroup`用于等待一组goroutine完成。

```golang
var wg sync.WaitGroup
for _, item := range items {
	wg.Add(1)
	go func(it Item) {
		defer wg.Done()
		process(it)
	}(item)
}
wg.Wait()
```

**小结**
- 不要通过共享内存来通信，要通过通信来共享内存。
- 每个goroutine都必须有明确的退出机制。
- 并发访问共享资源必须加锁或使用channel序列化。


<a id="interface-design"></a>
## 1.2.7 接口设计

**Accept interfaces, return structs (接受接口，返回结构体)**

这是Go语言中最重要的设计原则之一：
- 函数参数使用接口类型，使函数更通用、更易测试。
- 函数返回具体的结构体类型，让调用方获得完整的类型信息。

```golang
// good: 参数是接口，返回具体类型
func NewUserService(repo UserRepository) *UserService {
	return &UserService{repo: repo}
}

// 接口由使用方定义
type UserRepository interface {
	FindByID(ctx context.Context, id string) (*User, error)
}
```

**保持接口小巧**
- 接口应该只包含1-3个方法，大接口难以实现和mock。
- Go标准库中最强大的接口只有1-2个方法：`io.Reader`、`io.Writer`、`fmt.Stringer`。

```golang
// good: 小接口，职责单一
type Reader interface {
	Read(p []byte) (n int, err error)
}

// bad: 接口过大，难以实现
type Repository interface {
	FindAll() ([]Item, error)
	FindByID(id string) (*Item, error)
	Create(item *Item) error
	Update(item *Item) error
	Delete(id string) error
	Count() (int, error)
	Search(query string) ([]Item, error)
}
```

**在使用方定义接口，而非实现方**
- 这与Java/C#等语言的习惯相反。
- 使用方最清楚自己需要什么能力，按需定义最小接口。

```golang
// 在service包中定义自己需要的接口
package service

type UserFinder interface {
	FindByID(ctx context.Context, id string) (*User, error)
}

// 任何实现了FindByID方法的类型都隐式满足此接口
```

**小结**
- 接口越小，抽象越精确，复用性越强。
- 不要为了定义接口而定义接口，先写具体实现，当需要多态或测试时再提取接口。


<a id="defer-guidelines"></a>
## 1.2.8 defer使用规范

defer用于确保函数退出时执行清理操作，是Go中管理资源释放的核心机制。

**资源释放的标准模式**
```golang
f, err := os.Open(filename)
if err != nil {
	return err
}
defer f.Close()
```

获取资源后立即使用defer注册释放操作，保证配对且不遗漏。

**defer在循环中的陷阱**
defer是在函数退出时执行，而不是在代码块退出时。在循环中使用defer可能导致资源堆积：

```golang
// bad: 所有文件句柄直到函数返回才关闭
func processFiles(filenames []string) error {
	for _, name := range filenames {
		f, err := os.Open(name)
		if err != nil {
			return err
		}
		defer f.Close() // 不会在每次循环结束时执行！
		// ...
	}
	return nil
}

// good: 提取到独立函数，每次调用结束即释放
func processFiles(filenames []string) error {
	for _, name := range filenames {
		if err := processFile(name); err != nil {
			return err
		}
	}
	return nil
}

func processFile(name string) error {
	f, err := os.Open(name)
	if err != nil {
		return err
	}
	defer f.Close()
	// ...
	return nil
}
```

**defer与闭包**
defer的函数参数在defer语句执行时求值，但闭包中引用的变量在实际调用时求值：

```golang
func example() {
	x := 0
	defer fmt.Println(x) // 输出 0（参数在defer时求值）

	defer func() {
		fmt.Println(x)   // 输出 1（闭包在调用时求值）
	}()

	x = 1
}
```

**defer的执行顺序**
多个defer按后进先出(LIFO)的顺序执行，类似栈的行为。

**小结**
- 获取资源后立即defer释放，保持配对。
- 避免在循环中使用defer，提取到独立函数。
- 注意defer参数求值与闭包变量引用的区别。


<a id="context-guidelines"></a>
## 1.2.9 context使用规范

`context.Context`是Go中传递请求级别数据、控制超时和取消的标准机制。

**context作为函数第一个参数**
```golang
// good
func GetUser(ctx context.Context, id string) (*User, error)

// bad: context不应放在结构体中
type Server struct {
	ctx context.Context // 不要这样做
}
```

**设置超时防止请求无限等待**
```golang
ctx, cancel := context.WithTimeout(ctx, 3*time.Second)
defer cancel() // 即使操作提前完成，也必须调用cancel释放资源

result, err := db.QueryContext(ctx, "SELECT ...")
```

**传播取消信号**
当父context被取消时，所有子context也会被取消。利用这个特性构建请求链路的超时控制：

```golang
func handleRequest(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context() // 获取请求级别的context

	result, err := fetchData(ctx)   // 传递给下游
	if err != nil {
		if errors.Is(err, context.DeadlineExceeded) {
			http.Error(w, "request timeout", http.StatusGatewayTimeout)
			return
		}
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
	// ...
}
```

**不要用context传递业务参数**
context.Value应仅用于传递请求范围的元数据（如traceID、认证信息），不要用来替代函数参数传递业务数据。

```golang
// bad: 用context传递业务参数
ctx = context.WithValue(ctx, "userID", userID)

// good: 业务参数显式传递
func GetOrders(ctx context.Context, userID string) ([]Order, error)
```

**小结**
- context作为第一个参数，不要存在结构体中。
- 始终调用cancel函数，通常与defer配合使用。
- context.Value仅用于请求级元数据，不替代函数参数。


# 1.3 性能优化建议
> 简介
性能优化的前提是满足正确可靠、简洁清晰等质量因素。
性能优化是综合评估，有时候时间效率和空间效率可能对立。
针对Go语言特性，介绍Go相关的性能优化建议。

## 1.3.1 性能优化建议-Benchmark
>如何使用
性能表现需要实际数据衡量。
Go语言提供了支持基准性能测试的benchmark工具。

基准测试函数以Benchmark开头，接受一个*testing.B参数：

```golang
func BenchmarkFib(b *testing.B) {
	for i := 0; i < b.N; i++ {
		Fib(10)
	}
}
```

运行方式：
```bash
# 运行当前目录的所有基准测试
go test -bench=. -benchmem

# 仅运行基准测试，跳过单元测试
go test -run='^$' -bench=. -benchmem

# 多次运行以获取稳定结果，结合benchstat分析
go test -bench=. -benchtime=3s -count=5 -benchmem | tee result.txt
benchstat result.txt
```

输出说明：
```
BenchmarkFib-8   5000000   250 ns/op   0 B/op   0 allocs/op
```
- `-8`：GOMAXPROCS的值
- `5000000`：执行次数
- `250 ns/op`：每次操作耗时
- `0 B/op`：每次操作内存分配字节数
- `0 allocs/op`：每次操作内存分配次数

如果需要在基准测试中排除初始化时间，可以使用`b.ResetTimer()`：
```golang
func BenchmarkComplexOp(b *testing.B) {
	data := initTestData() // 准备数据
	b.ResetTimer()         // 重置计时器，排除初始化时间
	for i := 0; i < b.N; i++ {
		complexOp(data)
	}
}
```

## 1.3.2 性能优化建议-Slice
>slice预分配内存
尽可能在使用make()初始化切片时提供容量信息

>另一个陷阱：大内存未释放
场景:
原切片较大，代码在原切片基础上新建小切片
原底层数组在内存中有引用，得不到释放
建议使用copy(深拷贝)替代re-slice


## 1.3.3 性能优化建议-Map
>map预分配内存
分析：
不断向map中添加元素的操作会触发map的扩容；
提前分配好空间可以减少内存拷贝和Rehash的消耗；
建议根据实际需求提前预估好需要的空间。

## 1.3.4 性能优化建议-字符串处理
**字符串拼接推荐使用strings.Builder**

使用+拼接性能最差
字符串在Go语言中是不可变类型，占用内存大小是固定的，当使用 + 拼接 2 个字符串时，生成一个新的字符串，那么
就需要开辟一段新的空间，新空间的大小是原来两个字符串的大小之和。拼接第三个字符串时，再开辟一段新空间，
新空间大小是三个字符串大小之和，以此类推。

使用strings.Builder和bytes.Buffer性能相近，但前者略快10%。
而 strings.Builder，bytes.Buffer，包括切片 []byte 的内存是以倍数申请的。例如，初始大小为 0，当第一次写入
大小为 10 byte 的字符串时，则会申请大小为 16 byte 的内存（恰好大于 10 byte 的 2 的指数），第二次写入
10 byte 时，内存不够，则申请 32 byte 的内存，第三次写入内存足够，则不申请新的，以此类推。
如此，可以大幅减少内存分配和拷贝开销。

strings.Builder 和 bytes.Buffer 底层都是 []byte 数组，但 strings.Builder 性能比 bytes.Buffer
略快约 10% 。一个比较重要的区别在于，bytes.Buffer 转化为字符串时重新申请了一块空间，存放生成的字符串变量，
而 strings.Builder 直接将底层的 []byte 转换成了字符串类型返回了回来。

## 1.3.5 性能优化建议-空结构体
使用空结构体节省内存
空结构体struct{}实例不占用任何内存空间
可作为各种场景下的占位符使用
节省资源
空结构体本身具备很强的语义，即这里不需要任何值，仅作为占位符使用.

实现Set，可以考虑用map来代替
对于这个场景，只需要用到map的键，而不需要值。
即使是将map的值设置为bool类型，也会多占据1个字节空间。

## 1.3.6 性能优化建议-atomic包

>使用atomic包
锁的实现是通过操作系统来实现，属于系统调用
atomic操作是通过硬件来实现，效率比锁高
sync.Mutex互斥锁应该用来保护一段逻辑，而不仅仅是用于保护一个变量。
对于非数值操作，可以使用atomic.Value，能承载一个interface{}

## 1.3.7 性能优化建议-sync.Pool

>使用sync.Pool复用临时对象
sync.Pool是一个临时对象池，用于缓存已分配但暂时不用的对象，减少内存分配和GC压力。

典型场景：高频创建和销毁的临时对象，如缓冲区、编解码器等。

```golang
var bufPool = sync.Pool{
	New: func() interface{} {
		return new(bytes.Buffer)
	},
}

func process(data []byte) string {
	buf := bufPool.Get().(*bytes.Buffer)
	defer func() {
		buf.Reset()
		bufPool.Put(buf)
	}()

	buf.Write(data)
	// ... 处理逻辑
	return buf.String()
}
```

标准库中`fmt`包和`encoding/json`包大量使用了sync.Pool来复用内部缓冲区。

注意事项：
- Pool中的对象可能在任何时候被GC回收，不要用于持久存储。
- 放回Pool前务必重置对象状态（如`buf.Reset()`），避免数据污染。
- 仅在benchmark证实有GC压力时才使用，不要过早优化。

**小结**
避免常见的性能陷阱可以保证大部分程序的性能。
普通应用代码，不要一味地追求程序的性能。
越高级的性能优化手段越容易出现问题。
在满足正确可靠、简洁清晰的质量要求的前提下提高程序性能。
