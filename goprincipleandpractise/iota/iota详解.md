
---
iota详解
---
实际上从编译器的角度看iota，其取值规则只有一条:
iota代表了const声明块的行索引(下标从0开始)。
const声明还有一个特点，即如果为常量指定了一个表达式，但后续的常量没有表达式，则继承上面的表达式。

接下来，我们根据这个规则来分析一个复杂的常量声明:

```shell
const (
  bit0, mask0 = 1 << iota, 1<<iota -1
  bit1, mask1
  _,_
  bit3,mask3
)
```
第0行表达式展开即bit0, mask0 = 1<<0, 1<<0-1，所以bit0=1，mask0=0;
第1行没有指定表达式，所以继承第一行，即bit1, mask1 = 1<<1, 1<<1-1，所以bit1=2，mask1=1;
第2行没有定义常量，但是iota代表const常量声明块的行索引还是会+1，此时iota=2;
第3行没有指定表达式，所以继承第一行，即bit3, mask3 = 1<<3, 1<<3-1，所以bit3=8，mask3=7;

总结:
单个const声明块中从0开始取值；
单个const声明块中，每增加一行声明，iota的取值增1，即便声明中没有使用iota也是如此；
单行声明语句中，即便出现多个iota，iota的取值也保持不变。
