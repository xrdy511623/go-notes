
---
静态代码分析：在编码阶段发现并修复Go潜在问题
---

静态代码分析（Static Code Analysis）是一种在不实际执行代码的情况下，对源代码进行分析和检查的技术。它就像一位经验丰富的代码审查员，能够自动扫描你的 Go 代码，并根据一系列预设的规则和模式，指出其中可能存在的各种问题。这些问题可能小到编码风格的不一致，大到潜在的安全漏洞或严重的逻辑缺陷。


# 1 为什么要做静态代码分析？
提交代码前一定要做静态代码检查，这有助于保持团队整体的代码风格一致，更重要的是，可以提高代码质量。

静态代码检查在不实际运行程序的前提下，对程序的源代码（或者有时是编译后的中间代码）进行自动化的分析和检查。它的目标是通过对代码的词法、语法、语义、控制流、数据流等多个层面进行扫描和推断，来识别其中可能存在的各种缺陷和改进点。这些潜在问题可以非常广泛，

包括但不限于：
- 语法错误和类型错误：虽然 Go 编译器本身会捕捉这些，但某些静态分析工具可能提供更早或更友好的提示。
- 潜在的逻辑错误：例如，未初始化的变量、空指针解引用风险、不可能的条件判断、资源未释放等。
- 违反编码规范和最佳实践：例如，不一致地命名、过长的函数、过高的复杂度、API 的误用等。
- 代码风格问题：例如，不正确地缩进、多余的空格、不规范的注释等（gofmt 主要解决格式化，但静态分析可以检查更广义的风格）。
- 安全漏洞：例如，潜在的 SQL 注入、跨站脚本（XSS）风险、不安全的并发访问模式等。
- 性能瓶颈：例如，低效的循环、不必要的内存分配、可以优化的算法等。

## 1.1 静态分析的核心价值

静态分析工具就像给我们的代码做了一次全面的“体检”，在问题真正引发故障之前就发出预警。那么，静态分析的核心价值是什么呢？

将静态分析融入到我们的开发流程中，可以带来诸多显著的益处：
- 早期发现问题，降低修复成本：这是静态分析最核心的价值。
在代码编写阶段或代码提交前就能发现问题，远比在测试阶段、集成阶段甚至生产环境才发现问题要容易修复，成本也低得多。正所谓“防患于未然”。

- 自动化检查，提升效率：
静态分析工具可以自动、快速地扫描大量代码，执行许多原本需要人工代码审查才能发现的检查项，从而将宝贵的审查精力解放出来，聚焦于更复杂的业务逻辑和架构设计。

- 提升代码质量的多个维度：
规范性与一致性：帮助团队遵循统一的编码规范和最佳实践，使得代码库风格一致，降低新成员的理解成本。
可读性与可维护性：通过指出复杂的代码结构、不清晰的命名、冗余的代码等，促进编写更易读、更易维护的代码。
健壮性与可靠性：发现潜在的错误、资源泄漏、并发问题等，减少运行时 Bug，提升应用的稳定性。
安全性：一些专注于安全的静态分析工具（SAST - Static Application Security Testing）能帮助发现常见的安全漏洞。促进学习与知识传递：静态分析工具的报告和建议，往往也包含了对某些语言特性或编程模式的正确用法的解释，这对于开发者（尤其是初学者）来说，也是一个很好地学习和提升机会。

## 1.2 静态分析的局限

尽管静态分析非常强大，但它并非万能的，也存在其固有的局限性：

- 误报（False Positives）：有时，静态分析工具可能会报告一些实际上并不是问题的“警告”或“错误”。这可能是因为工具的规则过于通用，或者未能完全理解代码的特定上下文。过多的误报会降低开发者对工具的信任度，甚至导致他们忽略真正的告警。
- 漏报（False Negatives）：由于静态分析不执行代码，它无法完全模拟程序在所有可能的运行时环境和输入下的行为。因此，它可能会漏掉一些只有在特定运行时条件下才会暴露的缺陷（尤其是复杂的逻辑错误或并发问题）。
- 不能完全替代动态测试和人工审查：静态分析是代码质量保障体系中的重要一环，但它应该与单元测试、集成测试、人工代码审查等其他手段相辅相成，而不是取代它们。


# 2 静态分析是如何工作的？
理解静态分析工具大致是如何工作的，有助于我们更好地使用它们和解读其报告。虽然不同工具的具体实现各异，但其核心原理通常涉及以下几个阶段：

- 词法分析（Lexical Analysis）：将源代码文本分解成一系列的“词法单元”（Tokens），例如关键字（func、if）、标识符（变量名、函数名）、运算符（+、=）、字面量（123、"hello")、标点符号（{、}）等。

- 语法分析（Syntax Analysis）：根据 Go 语言的语法规则，将词法单元序列转换成一种结构化的表示，最常见的就是抽象语法树（Abstract Syntax Tree，AST）。AST 清晰地表达了代码的结构和层次关系。

- 语义分析（Semantic Analysis）：在 AST 的基础上，进行更深层次的检查和信息提取。这可能包括：
1. 类型检查：验证类型是否匹配、操作是否合法。
2. 作用域分析：确定标识符的定义和引用范围。
3. 控制流分析（Control Flow Analysis）：构建代码的控制流图（CFG），分析代码块的执行路径和可达性。 
4. 数据流分析（Data Flow Analysis）：分析数据在程序中的传播路径，例如变量的定义 - 使用链、指针的别名分析、污点数据的追踪（用于安全分析）等。

- 模式匹配与规则检查（Pattern Matching & Rule Checking）：这是静态分析工具发现问题的核心。工具会根据预定义的规则集（Linter Rules）或启发式模式，在 AST、CFG、数据流信息或其他中间表示上进行匹配。如果代码的某个部分匹配了某个“坏味道”模式或违反了某个规则，工具就会报告一个问题。

例如，go vet 在检查 printf 格式化字符串时，会解析 printf 调用的 AST 节点，提取格式化字符串和实际参数，然后比较它们的数量和类型是否匹配。staticcheck 在进行更复杂的分析时，可能会构建更详细的程序表示，并在其上执行数据流分析来发现更微妙的问题。 

了解这些基本原理，能帮助我们理解为何静态分析工具有时会产生误报（可能因为其模式匹配不够精确或上下文理解不足），以及为何它们通常对代码风格和常见错误模式非常敏感。

现在，我们已经对静态分析有了初步的认识，接下来将重点介绍 Go 生态中那些主流的、能帮助我们提升代码质量的静态分析工具。

# 3 主流静态分析工具实践

Go 语言生态系统拥有丰富的静态分析工具，从官方内置到社区驱动，它们覆盖了代码质量的方方面面。掌握这些工具的使用，是将静态分析融入日常开发流程的关键。接下来，我们重点介绍 Go 项目中最常用的几个静态分析工具。

## 3.1 go vet：来自官方的“代码医生”

go vet 是 Go 语言工具链中内置的一个简单但非常实用的静态分析工具。它的设计目标是检查 Go 源代码中那些编译器可能不会报错，但却是常见错误或可疑构造的代码。

### 3.1.1 核心检查

核心检查项举例：go vet 包含了一系列分析器（analyzers），用于检查特定类型的问题。以下是一些常见的检查类别（go tool vet help 可以查看所有支持的分析器及其简要说明）。

- printf 格式化：检查 fmt.Printf 及其类似函数的格式化字符串与其参数的数量和类型是否匹配。这是 go vet 最广为人知的功能之一。

- 未使用结果（unusedresult）：检查那些返回了 error 或其他重要结果但其返回值未被使用的函数调用（例如，调用了 fmt.Errorf 但未使用其结果）。

- 结构体标签（structtag）：检查结构体字段标签的格式是否规范（如json:"name,omitempty"）。

- 循环闭包变量捕获（loopclosure）：检查在 for 循环中创建的 goroutine 或 defer 语句是否正确捕获了循环变量（这是 Go 中一个常见的坑）。Go 1.22 版本修改了 for 循环变量语义（每次迭代创建新变量）后，这个检查仅对 Go 1.22 版本之前的代码有效了。

- context.Context 丢失取消（lostcancel）：检查当一个函数返回 context.Context 和 context.CancelFunc 后，CancelFunc 是否被调用。

- 不正确的 errors.As 或 errors.Is 用法（errorsas）：检查 errors.As 的第二个参数是否是指向错误接口或具体错误类型的指针。

- 不安全的 atomic 操作（atomic）：检查 sync/atomic 包中函数的参数是否符合对齐要求。

- HTTP 响应体未关闭（httpresponse）：检查 http.Get 等函数返回的 resp.Body 是否被正确关闭。

- 还有许多其他检查，例如：asmdecl（汇编声明）、assign（无用赋值）、bools（布尔表达式简化）、buildtags、cgocall、composites、copylocks、directive、ifaceassert（不可能的接口断言）、nilfunc（nil 函数比较）、shift（非法位移）、slog（Go 1.21+ log/slog用法检查）、stdmethods（标准方法签名）、testinggoroutine（测试中 goroutine 误用 t）、timeformat（time.Format 布局串）、unmarshal（Unmarshal 目标类型）、unreachable（不可达代码）、unsafeptr。


### 3.1.2 用法

go vet 的用法十分简单，可以直接在你的包路径或文件上运行 go vet：

```shell
$go vet ./... # 检查当前目录及其所有子包
$go vet mypkg/main.go mypkg/utils.go # 检查指定文件
```

go vet 会将发现的问题输出到标准错误。

Go vet 的输出通常格式为 filepath:line:column: message。

例如：

```shell
mypkg/utils.go:42:10: Sprintf call has arguments but no formatting directives
```

这表示在 mypkg/utils.go 文件的第 42 行第 10 列，一个 Sprintf 调用可能存在问题。


我们看一个真实的示例，下面是被 go vet 进行静态检查的目标 Go 代码示例


```go
package main

import (
    "context"
    "fmt"
    "sync"
    "time"
)

// Example 1: Printf format error
func PrintfError(name string, age int) {
    fmt.Printf("Name: %s, Age: %d years, Height: %.2f\n", name, age) // Missing argument for %.2f
}

// Example 2: Loop closure
func LoopClosureProblem() {
    var wg sync.WaitGroup
    s := []string{"a", "b", "c"}
    for _, v := range s { // v is reused in each iteration
        wg.Add(1)
        go func() { // This goroutine captures the loop variable v by reference
            defer wg.Done()
            // All goroutines will likely print 'c' because v will be 'c' when they run
            fmt.Printf("Loop var (problem): %s\n", v)
        }()
    }
    wg.Wait()
}
func LoopClosureFixed() {
    var wg sync.WaitGroup
    s := []string{"a", "b", "c"}
    for _, v := range s {
        v := v // Create a new variable v shadowing the loop variable
        wg.Add(1)
        go func() {
            defer wg.Done()
            fmt.Printf("Loop var (fixed): %s\n", v)
        }()
    }
    wg.Wait()
}

// Example 3: Lost cancel
func ProcessWithContext(parentCtx context.Context) context.Context {
    newCtx, _ := context.WithTimeout(parentCtx, 5*time.Second)
    go func() { // Simulate work that respects cancellation
        <-newCtx.Done()
        fmt.Println("ProcessWithContext: context done (e.g. timeout or manual cancel)")
    }()

    // For this example, let's make a clear lost cancel case for go vet to find:
    if time.Now().Year() > 2000 { // Dummy condition
        _, cancelFuncThatWillBeLost := context.WithCancel(parentCtx)
        _ = cancelFuncThatWillBeLost // Suppress unused variable, but vet checks if called.
    }
    return newCtx // Returning the context, but what about cancel from line 60?
}

// Dummy main for package to be vet-able
func main() {
    PrintfError("Alice", 30)
    LoopClosureProblem()
    LoopClosureFixed()

    ctx := context.Background()
    derivedCtx := ProcessWithContext(ctx)
    _ = derivedCtx
}
```

运行 go vet，我们将得到下面的输出：

```shell
$go vet .
# ch26/vetexamples
./vet_examples.go:24:43: loop variable v captured by func literal
./vet_examples.go:45:10: the cancel function returned by context.WithTimeout should be called, not discarded, to avoid a context leak
./vet_examples.go:12:2: fmt.Printf format %.2f reads arg #3, but call has 2 args
```

go vet 是一个很好的起点，它轻量、快速，并且能捕捉到许多常见的低级错误。但对于更全面、更深入的静态分析，我们通常需要更强大的工具。

### 3.1.3 使用 -vettool 集成自定义分析器

go vet 支持通过 `-vettool` 标志指定外部分析器二进制，将自定义分析器无缝集成到 `go vet` 工作流中。这是本文后面第 7 章自定义分析器的自然延伸：

```shell
# 构建你的自定义分析器
go build -o myanalyzer ./cmd/myanalyzer

# 使用 -vettool 指定自定义分析器
go vet -vettool=$(pwd)/myanalyzer ./...
```

使用 `-vettool` 时，go vet **只会运行你指定的分析器**，不会运行内置的检查器。如果你想同时运行内置检查和自定义检查，有两种方式：

1. 分别运行：`go vet ./... && go vet -vettool=./myanalyzer ./...`
2. 使用 `multichecker` 将内置分析器和自定义分析器组合成一个二进制（详见第 7 章）


## 3.2 staticcheck：更全面、更深入的静态检查

staticcheck（由 Dominik Honnef 开发和维护）是一个广受欢迎的、功能极其强大的 Go 静态分析工具集。它不仅仅是 go vet 的简单增强，而是包含了一系列独立的检查器，覆盖了代码的正确性、性能、风格简化以及一些可疑模式等多个方面。

### 3.2.1 特点

相比于 go vet，staticcheck 具有如下特点：

- 检查范围更广：staticcheck 包含了数百个检查规则(https://staticcheck.dev/docs/checks/)（分为 SA 系列 -Static Analysis、S 系列 -Simple、ST 系列 -Style、QF 系列 -QuickFix 等），远超 go vet。

- 检查更深入：许多检查基于更复杂的程序分析技术（如 SSA - Static Single Assignment form），能发现更微妙的问题。

- 错误分类清晰：每个检查都有一个唯一的 ID（如 SA5009），方便查阅文档和配置。

- 活跃维护与更新：staticcheck 社区非常活跃，工具和检查规则会随 Go 语言的发展而持续更新。


### 3.2.2 用法

staticcheck 的安装和使用都非常简单：

```shell
# 安装最新版
go install honnef.co/go/tools/cmd/staticcheck@latest 
```

然后，通过下面命令就可以检查当前目录以及所有子包：

```shell
$staticcheck ./... 
```

staticcheck 输出格式通常是 filepath:line:column: message (CHECK_ID)。这里我们用 staticcheck 对上面的 go vet 示例做一次检查：

```shell
$staticcheck .       
vet_examples.go:12:13: Printf format %.2f reads arg #3, but call has only 2 args (SA5009)
vet_examples.go:60:6: func main is unused (U1000)
```

我们看到 staticcheck 检出了两个问题，但这比 go vet 还要少，似乎 static check 没有其介绍的那么强大。其实，这是因为 staticcheck 默认检查范围导致的。我们不妨开启更多检查再试一下：

```shell
$staticcheck -checks "all" .
vet_examples.go:1:1: at least one file in a package should have a package comment (ST1000)
vet_examples.go:10:1: comment on exported function PrintfError should be of the form "PrintfError ..." (ST1020)
vet_examples.go:12:13: Printf format %.2f reads arg #3, but call has only 2 args (SA5009)
vet_examples.go:15:1: comment on exported function LoopClosureProblem should be of the form "LoopClosureProblem ..." (ST1020)
vet_examples.go:43:1: comment on exported function ProcessWithContext should be of the form "ProcessWithContext ..." (ST1020)
vet_examples.go:60:6: func main is unused (U1000)
```

这里，我们用 -checks 标志开启了"all"模式，即运行所有检查，结果即迥然不同了。如果你要排除某个检查，也可以在命令行中体现：

```shell
$staticcheck -checks "all,-U1000,-ST1020" .
vet_examples.go:1:1: at least one file in a package should have a package comment (ST1000)
vet_examples.go:12:13: Printf format %.2f reads arg #3, but call has only 2 args (SA5009)
```

在这次执行中，我们忽略掉了 U1000 和 ST1020 这两项检查。当然你也可以运行特定的检查，就像下面这样：

```shell
$staticcheck -checks "U1000,ST1020" . 
vet_examples.go:10:1: comment on exported function PrintfError should be of the form "PrintfError ..." (ST1020)
vet_examples.go:15:1: comment on exported function LoopClosureProblem should be of the form "LoopClosureProblem ..." (ST1020)
vet_examples.go:43:1: comment on exported function ProcessWithContext should be of the form "ProcessWithContext ..." (ST1020)
vet_examples.go:60:6: func main is unused (U1000)
```

在这次执行中，我们仅让 staticcheck 进行 U1000 和 ST1020 这两项检查。如果你想开启所有检查，但又想在某些特定代码行或特定文件中忽略特定的检查，可以使用 linter directive，staticcheck 的 linter directive 支持行级和文件级：

在问题代码行的上一行添加 //lint:ignore CHECK_ID reason 来忽略特定检查：
```shell
//lint:ignore ST1003 My custom error type doesn't need Error suffix
type MyCustomError struct { msg string } 
```

在源文件中添加 //lint:file-ignore CHECK_ID reason 来忽略特定检查：
```shell
//lint:file-ignore U1000 Ignore all unused code, it's generated
```

到这里，我们看到 staticcheck 以其检查的深度和广度以及极强的定制性，成为 Go 项目中事实上的标准静态分析工具之一。

然而，当我们需要组合多种 Linter，并对它们进行统一配置和管理时，golangci-lint 就登场了。

## 3.3 golangci-lint：集大成的 Linter 聚合器
golangci-lint 是一个非常流行的 Go Linter 聚合器。它本身不是一个 Linter，而是集成了大量社区优秀的静态分析工具和 Linter（包括 go vet、staticcheck、errcheck、unused、gofmt、goimports、misspell 等等，总数超过几十个），并提供了统一的命令行接口、配置文件、输出格式以及与 CI/CD 集成的便利性。

### 3.3.1 特点和优势

golangci-lint 能成为非常流行的 Go Linter 聚合器与其鲜明的特点不无关系：
- 一站式运行多种检查：无需单独安装和运行每个 Linter。
- 高性能：通过并发执行和缓存机制优化了运行速度。
- 高度可配置：可以通过 YAML 配置文件（通常是 .golangci.yml 或 .golangci.yaml）精确控制启用哪些 Linters、禁用哪些检查、为特定 Linter 设置参数、排除特定文件或目录等。
- 与 CI/CD 集成友好：输出格式多样（文本、JSON、Checkstyle 等），易于集成到 GitHub Actions、GitLab CI、Jenkins 等流水线中。
- 支持自动修复（--fix）：对于某些 Linter（如格式化、imports、一些简单的代码简化），可以尝试自动修复发现的问题。


### 3.3.2 安装和使用

这里推荐采用官方的安装方式安装 golangci-lint：

```shell
# binary will be $(go env GOPATH)/bin/golangci-lint
curl -sSfL https://raw.githubusercontent.com/golangci/golangci-lint/HEAD/install.sh | sh -s -- -b $(go env GOPATH)/bin v2.1.6
golangci/golangci-lint info checking GitHub for tag 'v2.1.6'
golangci/golangci-lint info found version: 2.1.6 for v2.1.6/darwin/amd64
golangci/golangci-lint info installed /Users/tonybai/Go/bin/golangci-lint

# 查看是否已安装
golangci-lint --version
golangci-lint has version 2.1.6 built with go1.24.2 from eabc2638 on 2025-05-04T15:41:19Z
```

和 govet、staticcheck 一样，golangci-lint 使用也非常简单，我们还以 vet_example.go 那个示例为例，使用 golangci-lint 对其进行一次检查：

```shell
$golangci-lint run ./...
vet_examples.go:12:2: printf: fmt.Printf format %.2f reads arg #3, but call has 2 args (govet)
    fmt.Printf("Name: %s, Age: %d years, Height: %.2f\n", name, age) // Missing argument for %.2f
    ^
vet_examples.go:45:10: lostcancel: the cancel function returned by context.WithTimeout should be called, not discarded, to avoid a context leak (govet)
    newCtx, _ := context.WithTimeout(parentCtx, 5*time.Second)
            ^
vet_examples.go:60:6: func main is unused (unused)
func main() {
     ^
3 issues:
* govet: 2
* unused: 1
```

可以看到 golangci-lint 的输出更为详细，不仅输出了问题行代码，还用 ^ 符号指出了问题的具体位置。

当然命令行形态的 golangci-lint 还支持问题修复和指定输出信息到特定格式的文件：

```shell
golangci-lint run --fix ./... # 尝试自动修复
golangci-lint run --out-format=json ./... > report.json # 输出JSON格式报告
```

### 3.3.3 最佳实践

在实际项目中，我们通常会为项目创建一个 .golangci.yml 配置文件，而不是依赖默认设置或纯命令行参数。这使得 linting 行为可复现、可版本控制，并且易于团队共享。

下面是一个适用于 **golangci-lint v2** 的 `.golangci.yml` 配置文件的内容片段。

> **注意：v2 相比 v1 有多处破坏性变更。** 如果你从 v1 升级，主要关注以下迁移点：
> - `run.skip-dirs` / `run.skip-files` 已移除，改用 `issues.exclude-dirs` / `issues.exclude-files`
> - `structcheck`、`varcheck`、`deadcode` 等 linter 已被移除（其功能已被 `unused` 覆盖）
> - `golint` 已彻底移除，使用 `revive` 替代
> - 配置文件格式有细微调整，建议运行 `golangci-lint config migrate` 自动迁移

```yaml
# .golangci.yml (golangci-lint v2)
version: "2"

run:
  timeout: 5m

linters:
  # v2 中推荐使用 enable 列表明确启用想要的 Linters
  enable:
    - govet
    - errcheck
    - staticcheck
    - unused           # 已涵盖原 structcheck/varcheck/deadcode 的功能
    - gosimple         # 代码简化建议（staticcheck 套件）
    - ineffassign      # 检测无效赋值
    - typecheck        # 快速类型检查
    - goimports        # 排序 imports，添加缺失/删除多余的
    - misspell         # 纠正注释和字符串中的常见拼写错误
    - revive           # 可配置的风格检查器（替代已废弃的 golint）
    # 按需启用更多 linter：
    # - bodyclose      # 检查 HTTP 响应体是否关闭
    # - noctx          # 检查应该接受 context.Context 的函数
    # - gocritic       # 多种代码质量检查
    # - gosec          # Go 安全检查器
    # - unparam        # 检查未使用的函数参数

linters-settings:
  govet:
    enable:
      - shadow         # v2 中 shadow 检查需要显式启用
  errcheck:
    check-type-assertions: true  # 检查类型断言中的错误
    check-blank: true            # 检查 _ = fn() 的错误忽略
  staticcheck:
    checks: ["all", "-ST1000"]   # 启用所有检查，排除包注释要求
  goimports:
    local-prefixes: github.com/yourorg/yourproject  # 你的项目的 import 前缀
  misspell:
    locale: US
  revive:
    rules:
      - name: exported
        arguments:
          - "checkPrivateReceivers"  # 检查私有接收者的导出方法

issues:
  exclude-dirs:
    - vendor
    - internal/generated           # 跳过生成的代码
  exclude-rules:
    - path: _test\.go
      linters:
        - errcheck                 # 测试文件中放宽错误检查
      text: "Error return value of .* is not checked"
    # 忽略所有 SA1019（使用了已废弃 API）的警告：
    # - linters: [staticcheck]
    #   text: "SA1019:"
```

这个配置文件：
 - 使用了 v2 的 `version: "2"` 声明和新的配置结构。
 - 移除了 v1 中已废弃的 `structcheck`、`varcheck`（功能已被 `unused` 覆盖）。
 - 使用 `issues.exclude-dirs` 替代了 v1 的 `run.skip-dirs`。
 - 为 govet、errcheck、staticcheck、goimports、misspell、revive 等 Linter 进行了具体设置。
 - 通过 enable 列表明确启用 Linters，这比默认启用所有然后禁用一部分更可控。
 - 提供了 issues.exclude-rules 示例，用于精确忽略某些不想处理的告警。

对于 golangci-lint 生成的代码静态分析报告，我们需要逐个分析报告的问题，判断是需要修复代码，还是调整配置（例如，忽略特定规则或路径），或者在代码中添加 //nolint:lintername 注释（应谨慎使用，并说明理由）。对于 --fix 选项，建议先在本地试运行并仔细审查其修改，确认无误后再提交。

golangci-lint 以其强大的整合能力和高度地可配置性，已成为 Go 项目静态分析的事实标准工具。


## 3.4 其他专项检查工具
虽然 golangci-lint 集成了很多 Linter，但有时我们可能只需要针对性地运行某个专项检查，或者某些工具可能尚未被 golangci-lint 完全集成或提供相同的配置粒度。

- errcheck(github.com/kisielk/errcheck)：Go 语言通过显式返回 error 来进行错误处理，但开发者有时可能会忘记检查或处理这些错误，这可能导致程序行为异常或隐藏 bug。errcheck 就是专门用来发现这类问题的。
- unused(github.com/dominikh/go-tools/cmd/unused)：未使用的变量、常量、函数、类型或结构体字段会增加代码的认知负担和维护成本，还可能掩盖逻辑错误（例如，一个本应被使用的计算结果被意外地赋给了未使用的变量）。unused 是专门用来发现此类问题的。
- gosec（github.com/securego/gosec）：专注于 Go 代码的安全扫描，能发现常见的安全漏洞，如硬编码凭证、不安全的随机数使用、SQL 注入风险、路径遍历等。
- nakedret（github.com/alexkohler/nakedret）：检查函数是否使用了裸返回（named return values without explicit return values），这在某些情况下会降低代码可读性。
- unparam（mvdan.cc/unparam）：查找函数中那些总是以相同常量值传递或从未被实际使用的参数。

## 3.5 revive：golint 的现代替代品

revive（github.com/mgechev/revive）是已废弃的 `golint` 的功能增强替代品。它是一个快速、可配置、可扩展的 Go 代码风格检查器，已被 golangci-lint 集成。

### 3.5.1 为什么需要 revive

`golint` 曾经是 Go 社区最流行的风格检查器，但它的规则是硬编码的、不可配置的，而且已于 2021 年被官方归档（archived），不再维护。revive 解决了这些问题：

- **规则可配置**：每条规则都可以单独启用/禁用，并支持参数化配置
- **性能更好**：相比 golint 快 6 倍以上（官方 benchmark）
- **规则更丰富**：内置 30+ 条规则，覆盖命名规范、错误处理、包设计等
- **支持自定义规则**：可以通过 Go plugin 机制编写自定义规则

### 3.5.2 独立使用

```shell
# 安装
go install github.com/mgechev/revive@latest

# 使用默认规则检查
revive ./...

# 使用配置文件
revive -config revive.toml ./...
```

### 3.5.3 配置示例

revive 使用 TOML 格式的配置文件：

```toml
# revive.toml
ignoreGeneratedHeader = false
severity = "warning"
confidence = 0.8

[rule.blank-imports]          # 检查空白 import 是否有注释说明
[rule.context-as-argument]    # context.Context 应作为第一个参数
[rule.context-keys-type]      # context.WithValue 的 key 应使用自定义类型
[rule.dot-imports]            # 禁止 dot import（import . "pkg"）
[rule.error-return]           # error 应作为最后一个返回值
[rule.error-strings]          # error 字符串不应以大写或标点结尾
[rule.error-naming]           # error 类型变量应以 Err 开头
[rule.exported]               # 导出标识符应有文档注释
  arguments = ["checkPrivateReceivers"]
[rule.if-return]              # 简化 if-else + return 模式
[rule.increment-decrement]    # 使用 i++ 而非 i += 1
[rule.var-naming]             # 遵循 Go 命名规范（如 ID 不是 Id）
[rule.package-comments]       # 包应有文档注释
[rule.range]                  # 简化 range 循环
[rule.receiver-naming]        # 接收者命名一致性
[rule.time-naming]            # time.Duration 变量不应以时间单位为后缀
[rule.unexported-return]      # 导出函数不应返回未导出类型
[rule.indent-error-flow]      # 错误处理应使用 early return，保持主逻辑不缩进
[rule.errorf]                 # 使用 fmt.Errorf 替代 errors.New + fmt.Sprintf
[rule.unused-parameter]       # 检查未使用的函数参数
  severity = "warning"
```

### 3.5.4 在 golangci-lint 中配置

在 `.golangci.yml` 中，revive 的规则通过 `linters-settings.revive` 配置：

```yaml
linters-settings:
  revive:
    severity: warning
    rules:
      - name: blank-imports
      - name: context-as-argument
      - name: context-keys-type
      - name: error-return
      - name: error-strings
      - name: error-naming
      - name: exported
        arguments:
          - "checkPrivateReceivers"
      - name: if-return
      - name: indent-error-flow
      - name: var-naming
      - name: package-comments
        disabled: true  # 如果不需要包注释检查
```

revive 的可配置性使其成为团队统一编码风格的理想选择——你可以从宽松配置开始，逐步收紧规则，平滑地提升代码规范要求。


# 4 如何在项目中有效集成静态分析
仅仅知道有哪些工具是不够的，更重要的是将它们有效地融入到日常的开发和协作流程中。这里介绍一下在项目中有效集成静态分析工具的一般步骤。

1. 第一步：从配置开始。对于像 golangci-lint 这样的聚合工具，首先要为项目创建一个共享的配置文件（如 .golangci.yml）。在这个文件中，团队共同决定启用哪些 Linter、禁用哪些检查、设置哪些参数。这个配置文件应纳入版本控制。 

2. 第二步：本地开发环境集成。

- IDE/ 编辑器插件：大多数主流的 Go IDE（如 GoLand）和编辑器（如 VS Code 配合 Go 插件）都支持集成 golangci-lint 或其他 Linter，可以在你编写代码时实时或保存时自动进行检查，并直接在编辑器中提示问题。这是最快反馈、最早发现问题的方式。
- Git Pre-commit Hook：设置一个 Git pre-commit 钩子，在每次 git commit之前自动运行选定的静态分析检查（通常是快速检查的一部分）。如果检查不通过，则阻止提交。这能确保进入代码库的代码至少满足基本的静态分析要求。

3. 第三步：CI/CD 流水线集成，这是最重要的集成点。在持续集成（CI）服务器上（如 GitHub Actions、GitLab CI、Jenkins、Travis CI 等），将静态分析（通常是运行 golangci-lint）作为构建和测试流程中的一个强制步骤。

- 如果静态分析发现任何问题（例如，golangci-lint run 以非零状态码退出），CI 构建应标记为失败，阻止有问题的代码被合并到主分支或部署到生产环境。
- CI 环境中的静态分析报告可以被存档，或输出为特定格式（如 JUnit XML、Checkstyle）供其他质量管理工具消费。

下面是一个 **GitHub Actions** 的实际配置示例：

```yaml
# .github/workflows/lint.yml
name: Lint

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

permissions:
  contents: read

jobs:
  golangci-lint:
    name: golangci-lint
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-go@v5
        with:
          go-version: '1.24'
      - name: golangci-lint
        uses: golangci/golangci-lint-action@v6
        with:
          version: v2.1.6
          # 可选：只检查本次 PR 新增/修改的代码（适合遗留项目）
          # args: --new-from-rev=HEAD~1
```

对于 **GitLab CI**，配置如下：

```yaml
# .gitlab-ci.yml
lint:
  stage: test
  image: golangci/golangci-lint:v2.1.6
  script:
    - golangci-lint run ./...
  rules:
    - if: $CI_MERGE_REQUEST_ID
    - if: $CI_COMMIT_BRANCH == "main"
```

4. 第四步：逐步引入，处理存量问题。对于已有大量代码的遗留项目，一次性启用所有严格的 Linter 规则可能会产生海量的告警，令人望而却步。

策略：
- 从小处着手：先启用最核心、误报率最低的 Linter 和规则（例如，go vet 的基本检查，errcheck，unused 等）。
- 逐步增加：待团队适应并修复了初期问题后，再逐步启用更严格或更细致的检查（如 staticcheck 的更多规则，代码复杂度检查等）。
- 关注新代码：golangci-lint 支持 --new 或 --new-from-rev 选项，可以只对本次提交或某个 Git 修订版本之后新增 / 修改的代码进行检查。这使得在遗留项目中引入静态分析的阻力更小，团队可以先确保新代码符合规范，再逐步清理旧代码的问题。
- 设定基线：对于实在难以立即修复的存量问题，可以在配置文件中通过 issues.exclude-rules 或代码内 //nolint 注释进行临时忽略（务必注明理由和计划），但要避免滥用。

5. 定期审查和调整规则。静态分析的配置不是一成不变的。随着项目的发展、Go 版本的升级、团队规范的演变，应定期回顾和调整启用的 Linter 和规则，确保它们仍然适用且有效。

通过这些集成方式，静态分析才能真正成为提升代码质量的持续动力，而不是一次性的“运动式”检查。


# 5 定制规则：构建自己的代码检查器
通过将这些主流的静态分析工具集成到我们的开发流程中，我们可以极大地提升代码质量，减少潜在的 Bug。然而，即便拥有了 go vet、staticcheck 及 golangci-lint 这样强大的工具集，它们提供的通用规则有时也可能无法完全覆盖我们团队特定的编码规范、独特的业务约束，或者那些在代码审查中反复出现的、可以通过模式识别的特定问题。


例如，你可能会遇到以下场景：
- 团队约定禁止在项目中使用某个标准库包的特定函数，因为它在你们的上下文中容易被误用。
- 业务逻辑要求某个核心实体在创建后，必须显式调用其 Initialize() 方法。
- 代码审查时，经常发现某些类型的错误没有被正确地包装上下文信息。

对于这些高度定制化的需求，依赖通用工具可能力不从心。这时，Go 语言为我们提供了更深层次的控制力——允许我们构建自己的自定义静态代码检查器。

定制检查器的核心价值在于其针对性和自动化：

- 针对性：它能够精确地捕捉到那些通用工具无法识别的、与你的项目特性或团队规范紧密相关的特定问题模式。
- 自动化：将原本需要依赖资深开发者经验、通过人工代码审查反复指出的问题，转化为可自动执行的检查规则。这不仅节省了宝贵的审查时间，更能保证规则在整个代码库中的一致执行。
- 知识沉淀：通过将团队在长期开发中总结出的最佳实践、常见陷阱和特定业务约束固化为可执行的检查规则，这些宝贵的经验得以沉淀和共享，有助于新成员快速融入团队规范，并减少重复犯错的概率。

那么，Go 语言为我们提供了哪些基础构件来支持这种自定义静态分析器的开发呢？这就要提到 go/analysis 包了。


# 6  Go 分析工具的构建块：go/analysis 包
Go 官方提供了一个强大的框架，用于编写模块化的静态代码分析器，它位于 golang.org/x/tools/go/analysis 包（通常简称为 analysis 包）。这个框架使得编写自定义检查器变得相对规范和容易。

analysis 包的核心概念如下：
- analysis.Analyzer：这是定义一个分析器的核心结构体。它包含了分析器的名称、文档、以及最重要的 Run 函数（分析逻辑的入口）。它还可以声明对其他分析器结果的依赖。
- analysis.Pass：当分析器的 Run 函数被调用时，它会接收一个 *analysis.Pass 对象作为参数。这个对象封装了当前分析阶段所需的所有信息，例如：
被分析包的类型信息（pass.TypesInfo）
被分析包的抽象语法树（AST）和文件列表（pass.Files）
报告问题的能力（pass.Reportf）
与其他分析器共享数据（Fact）的能力

- AST（Abstract Syntax Tree）：静态分析的核心通常是遍历和检查代码的 AST。Go 标准库的 go/parser 可以将源代码解析成 AST，go/ast 包定义了 AST 节点的类型， go/ast/inspect 则提供了方便遍历 AST 节点的工具。
- 类型信息（go/types）：analysis 框架会利用 go/types 包对代码进行完整的类型检查，并将类型信息提供给分析器，这使得分析器可以进行更深入的语义分析。
- Fact：一种在不同分析器之间或同一分析器对不同包的分析遍之间共享信息的机制。

go/analysis 框架鼓励编写小而专注的分析器，这些分析器可以组合在一起形成更强大的检查工具（例如，go vet 和 staticcheck 本身就是由许多这样的 Analyzer 组成的）。


# 7 编写简单分析器示例
让我们通过一个简单的例子来演示如何编写一个自定义的静态分析器。假设我们想创建一个分析器 checkpubfuncname，用于检查非 main 包中的顶层函数名是否都以大写字母开头（即是否为导出函数）。如果不是，则报告一个问题（这只是一个示例，实际中 go vet 可能已有类似或更复杂的检查）。

1. 定义 Analyzer 结构体：我们需要创建一个 analysis.Analyzer 实例，并填充其字段。
2. 实现 run 函数：这是分析器的核心逻辑。它接收一个 *analysis.Pass 对象，我们可以通过它访问 AST 和类型信息。
3. 遍历 AST 节点：使用 ast.Inspect 或直接遍历 pass.Files 中的 AST 节点，找到我们关心的代码模式（这里是函数声明）。
4. 执行检查逻辑：对找到的函数声明，检查其名称。
5. 报告问题：如果发现不符合规则的函数名，使用 pass.Reportf 报告。

下面是该示例的分析器逻辑的代码片段：

```go
package checkpubfuncname

import (
    "go/ast"
    "strings"
    "unicode"

    "golang.org/x/tools/go/analysis"
    "golang.org/x/tools/go/analysis/passes/inspect"
    "golang.org/x/tools/go/ast/inspector"
)

const Doc = `check for top-level function names that do not start with an uppercase letter (not exported) in non-main packages.

This analyzer helps enforce a convention that all top-level functions in library packages
should be exported if they are intended for external use, or kept unexported (lowercase)
if they are internal helpers. This specific check flags functions that might have been
intended to be package-private but were accidentally named with a non-uppercase first letter,
or vice-versa if the policy was to export all top-level funcs.`

// Analyzer is the instance of our custom analyzer.
var Analyzer = &analysis.Analyzer{
    Name:     "checkpubfuncname",
    Doc:      Doc,
    Run:      run,
    Requires: []*analysis.Analyzer{inspect.Analyzer}, // We need the inspector pass
    // ResultType: // Not producing any facts or results for other analyzers
    // FactTypes:  // Not using facts
}

func run(pass *analysis.Pass) (interface{}, error) {
    // Skip "main" package, as main.main is an exception, and other funcs might be internal.
    // This is a simplistic check; real linters have more sophisticated ways to handle package types.
    if pass.Pkg.Name() == "main" {
        return nil, nil
    }

    // Get the inspector. This is provided by the inspect.Analyzer requirement.
    inspectResult := pass.ResultOf[inspect.Analyzer].(*inspector.Inspector)

    // We are interested in function declarations (ast.FuncDecl)
    nodeFilter := []ast.Node{
        (*ast.FuncDecl)(nil),
    }

    inspectResult.Preorder(nodeFilter, func(n ast.Node) {
        funcDecl, ok := n.(*ast.FuncDecl)
        if !ok {
            return
        }

        // We are interested in top-level functions in the package.
        if funcDecl.Recv == nil { // It's a function, not a method
            funcName := funcDecl.Name.Name

            // Skip special function "init"
            if funcName == "init" {
                return
            }

            // Skip test functions (TestXxx, BenchmarkXxx, ExampleXxx)
            if strings.HasPrefix(funcName, "Test") ||
                strings.HasPrefix(funcName, "Benchmark") ||
                strings.HasPrefix(funcName, "Example") {
                return
            }

            if len(funcName) > 0 {
                firstChar := rune(funcName[0])
                if !unicode.IsUpper(firstChar) {
                    // This is a top-level function in a non-main package,
                    // and its name starts with a lowercase letter.
                    pass.Reportf(funcDecl.Pos(), "top-level function '%s' in package '%s' is not exported (name starts with lowercase)", funcName, pass.Pkg.Name())
                }
            }
        }
    })

    return nil, nil // No result for other analyzers, no error
}
```

待检查代码片段：

```go
package testpkg // A library package (not main)

import "fmt"

// This function is correctly exported.
func ExportedFunction() {
    fmt.Println("This is an exported function.")
}

// thisFunctionIsUnexported violates our hypothetical rule if we want all top-level funcs exported.
// Or, it's just a note if we only want to list unexported top-level functions.
// For this analyzer, we assume the rule is "top-level functions should be exported".
func thisFunctionIsUnexported() { // Analyzer should flag this
    fmt.Println("This function is not exported.")
}

type MyStruct struct{}

// This is a method, should be ignored by our simple check (Recv != nil)
func (s *MyStruct) ExportedMethod() {
    fmt.Println("This is an exported method.")
}
func (s *MyStruct) unexportedMethod() {
    fmt.Println("This is an unexported method.")
}

// TestHelperFunction is a test helper, should be ignored by our check
func TestHelperFunction() {}

func init() {
    fmt.Println("testpkg init")
}
```

接下来是驱动该独立分析器运行的命令行工具的代码片段：

```go
package main

import (
    "customanalyzer/checkpubfuncname" // Adjust import path to your module

    "golang.org/x/tools/go/analysis/singlechecker"
)

func main() {
    singlechecker.Main(checkpubfuncname.Analyzer)
}
```

analysis 的 singlechecker 可以方便地将单个 Analyzer 包装成一个命令行工具。multichecker 则可以将多个 Analyzer 组合起来。构建和运行这个命令行工具：

```shell
# customanalyzer下
go build customanalyzer/cmd/checkpubfunc
./checkpubfunc ./testpkg         
customanalyzer/testpkg/testpkg.go:13:1: top-level function 'thisFunctionIsUnexported' in package 'testpkg' is not exported (name starts with lowercase)
```

我们看到。自定义分析器成功捕捉到被检查代码（testpkg/testpkg.go）中的非导出顶层函数。

我们还可以将自定义分析器集成到 golangci-lint 中去。golangci-lint 支持通过 Go 插件（.so 文件，有原生 plugin 包的限制）或作为“私有 Linter”的方式集成自定义分析器。这通常需要更复杂的配置和构建步骤，具体可以参考 golangci-lint 的文档关于如何添加自定义 Linter 的部分。

这部分的主要目的是帮助大家了解 Go 强大的静态分析框架，并了解构建一个简单自定义检查器的基本流程。虽然深入 AST 操作和类型系统需要更多的学习，但 go/analysis 包为我们定制团队或项目特有的代码规范检查提供了可能。对于更复杂的需求，我们可以进一步研究该框架的文档和社区中已有的自定义分析器实现。


# 8 进阶：利用类型信息进行语义级分析

第 7 章的示例只使用了 AST 遍历，这相当于"看到了代码的语法结构"。但很多高级检查需要理解代码的**语义**——变量的类型是什么？函数的签名是什么？某个表达式是否实现了某个接口？这就需要用到 `pass.TypesInfo`。

## 8.1 pass.TypesInfo 的能力

`pass.TypesInfo` 是 `go/types.Info` 类型，它提供了以下关键信息：

```go
type Info struct {
    Types      map[ast.Expr]TypeAndValue  // 每个表达式的类型和值
    Defs       map[*ast.Ident]Object      // 每个定义标识符对应的对象
    Uses       map[*ast.Ident]Object      // 每个引用标识符对应的对象
    Selections map[*ast.SelectorExpr]Selection // 选择器表达式的解析结果
    // ...
}
```

通过这些信息，我们可以回答类似这样的问题：
- 这个变量是 `error` 类型吗？
- 这个函数调用返回的类型是什么？
- 这个接口断言的目标类型是否实现了特定接口？

## 8.2 示例：检查 error 是否被包装了上下文

在代码审查中，一个常见的反馈是 "error 应该用 `fmt.Errorf("context: %w", err)` 包装上下文信息，而不是直接 `return err`"。下面我们编写一个分析器来自动检测这个问题：

```go
package checkerrwrap

import (
    "go/ast"
    "go/types"

    "golang.org/x/tools/go/analysis"
    "golang.org/x/tools/go/analysis/passes/inspect"
    "golang.org/x/tools/go/ast/inspector"
)

var Analyzer = &analysis.Analyzer{
    Name:     "checkerrwrap",
    Doc:      "check that returned errors are wrapped with context using fmt.Errorf",
    Run:      run,
    Requires: []*analysis.Analyzer{inspect.Analyzer},
}

// errorType is the *types.Interface for the built-in error type.
var errorType = types.Universe.Lookup("error").Type().Underlying().(*types.Interface)

func run(pass *analysis.Pass) (interface{}, error) {
    inspectResult := pass.ResultOf[inspect.Analyzer].(*inspector.Inspector)

    nodeFilter := []ast.Node{
        (*ast.ReturnStmt)(nil),
    }

    inspectResult.Preorder(nodeFilter, func(n ast.Node) {
        ret := n.(*ast.ReturnStmt)

        for _, result := range ret.Results {
            // 检查返回值是否是 error 类型
            typ := pass.TypesInfo.TypeOf(result)
            if typ == nil || !types.Implements(typ, errorType) {
                continue
            }

            // 如果返回的是一个简单的标识符（直接 return err），而不是函数调用（如 fmt.Errorf）
            if ident, ok := result.(*ast.Ident); ok {
                // 跳过 return nil
                if ident.Name == "nil" {
                    continue
                }
                pass.Reportf(ident.Pos(),
                    "error '%s' returned without wrapping context; "+
                        "consider using fmt.Errorf(\"context: %%w\", %s)",
                    ident.Name, ident.Name)
            }
        }
    })

    return nil, nil
}
```

这个分析器的关键在于 `pass.TypesInfo.TypeOf(result)` —— 它不是通过变量名猜测（比如检查变量是否叫 `err`），而是通过**类型系统**精确判断一个表达式是否实现了 `error` 接口。这比纯 AST 分析准确得多。

## 8.3 Fact 机制：跨包传递分析信息

Fact 是 `go/analysis` 框架中一个强大的跨包信息传递机制。当分析器需要将一个包的分析结果传递给依赖该包的其他包时，就需要使用 Fact。

### 8.3.1 Fact 的工作原理

```
包 A 的分析 → 导出 Fact（如 "函数 Foo 已废弃"）
                ↓
包 B import A → 导入 A 的 Fact → 检查是否调用了已废弃的 Foo
```

Fact 分为两种：
- **ObjectFact**：附加在特定的 Go 对象上（函数、类型、变量等）
- **PackageFact**：附加在整个包上

### 8.3.2 示例：标记和检测已废弃的函数

```go
// DeprecatedFact 标记一个函数已被废弃
type DeprecatedFact struct {
    Message string
}

func (*DeprecatedFact) AFact() {} // 实现 analysis.Fact 接口

var Analyzer = &analysis.Analyzer{
    Name:      "deprecated",
    Doc:       "check for calls to deprecated functions",
    Run:       run,
    FactTypes: []analysis.Fact{(*DeprecatedFact)(nil)},
}

func run(pass *analysis.Pass) (interface{}, error) {
    // 阶段一：扫描当前包，标记带有 "Deprecated:" 注释的函数
    for _, file := range pass.Files {
        for _, decl := range file.Decls {
            fn, ok := decl.(*ast.FuncDecl)
            if !ok || fn.Doc == nil {
                continue
            }
            for _, comment := range fn.Doc.List {
                if strings.Contains(comment.Text, "Deprecated:") {
                    obj := pass.TypesInfo.ObjectOf(fn.Name)
                    if obj != nil {
                        pass.ExportObjectFact(obj, &DeprecatedFact{
                            Message: comment.Text,
                        })
                    }
                }
            }
        }
    }

    // 阶段二：检查当前包中是否调用了其他包中已废弃的函数
    inspectResult := pass.ResultOf[inspect.Analyzer].(*inspector.Inspector)
    nodeFilter := []ast.Node{(*ast.CallExpr)(nil)}

    inspectResult.Preorder(nodeFilter, func(n ast.Node) {
        call := n.(*ast.CallExpr)
        sel, ok := call.Fun.(*ast.SelectorExpr)
        if !ok {
            return
        }

        obj := pass.TypesInfo.ObjectOf(sel.Sel)
        if obj == nil {
            return
        }

        var fact DeprecatedFact
        if pass.ImportObjectFact(obj, &fact) {
            pass.Reportf(call.Pos(), "call to deprecated function: %s", fact.Message)
        }
    })

    return nil, nil
}
```

Fact 机制使得分析器可以进行真正的**全程序分析**，而不是局限于单个包。`go vet` 和 `staticcheck` 内部都大量使用了 Fact 来实现跨包检查。


# 9 使用 analysistest 测试自定义分析器

自定义分析器的可测试性是其工程价值的关键保障。`go/analysis` 框架提供了标准的测试工具 `analysistest`，使得分析器的测试变得规范、简洁。

## 9.1 测试目录结构

```
myanalyzer/
├── analyzer.go           # 分析器逻辑
├── analyzer_test.go      # 测试文件
└── testdata/
    └── src/
        └── example/
            └── example.go  # 待检查的测试用例文件
```

## 9.2 testdata 中的期望标注

测试用例文件中，使用 `// want "..."` 注释来标注**预期的诊断输出**：

```go
// testdata/src/example/example.go
package example

import "fmt"

func unexportedHelper() { // want `top-level function 'unexportedHelper' in package 'example' is not exported`
    fmt.Println("helper")
}

func ExportedFunction() { // 无 want 注释 → 不应产生告警
    fmt.Println("exported")
}

func init() { // init 应被跳过
    fmt.Println("init")
}
```

`// want` 后面的字符串是一个正则表达式。`analysistest` 会自动验证：
1. 分析器在标注了 `// want` 的行**确实**报告了匹配的诊断
2. 分析器**没有**在未标注的行报告诊断（即不会产生意外的误报）

## 9.3 编写测试函数

```go
// analyzer_test.go
package checkpubfuncname_test

import (
    "testing"

    "golang.org/x/tools/go/analysis/analysistest"
    "yourmodule/checkpubfuncname"
)

func TestAnalyzer(t *testing.T) {
    // analysistest.TestData() 返回当前包目录下 testdata/ 的绝对路径
    testdata := analysistest.TestData()

    // Run 会自动加载 testdata/src/example 包，运行分析器，
    // 并验证输出是否与 // want 注释匹配
    analysistest.Run(t, testdata, checkpubfuncname.Analyzer, "example")
}
```

运行测试：

```shell
go test ./myanalyzer/...
```

如果分析器在没有 `// want` 标注的行产生了诊断，或者在标注了 `// want` 的行没有产生预期的诊断，测试就会失败并给出清晰的错误信息。

## 9.4 测试多个场景

可以在 `testdata/src/` 下创建多个包来覆盖不同的场景：

```
testdata/
└── src/
    ├── basic/         # 基本场景
    │   └── basic.go
    ├── edge_cases/    # 边界情况
    │   └── edge.go
    └── false_positives/ # 确保不会误报
        └── fp.go
```

```go
func TestAnalyzer(t *testing.T) {
    testdata := analysistest.TestData()
    analysistest.Run(t, testdata, checkpubfuncname.Analyzer,
        "basic", "edge_cases", "false_positives")
}
```

`analysistest` 是 Go 生态中分析器开发的标准测试范式。所有官方的 `go vet` 检查器和 `staticcheck` 的检查器都使用了这种测试方式。掌握它，是编写可靠的自定义分析器的必要一步。