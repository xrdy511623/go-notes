
---
切片详解
---

# 1 当我们在说slice时，到底在说什么？

slice翻译成中文就是切片，它和数组（array）很类似，可以用下标的方式进行访问，如果越界，就会产生 panic。但是它比数组更灵活，可以自动地进行扩容。
要了解slice的本质，最简单的方法就是看它的源代码：


```golang
// runtime/slice.go
type slice struct {
	array unsafe.Pointer // 元素指针
	len   int // 长度 
	cap   int // 容量
}
```


> slice 共有三个属性：
- 指针，指向底层数组；
- 长度，表示切片可用元素的个数，也就是说使用下标对 slice 的元素进行访问时，下标不能超过 slice 的长度；
- 容量，表示从当前切片起始位置到底层数组末尾，可容纳的元素个数（cap >= len）。在不扩容的情况下，cap 就是可增长上限。
注意，底层数组是可以被多个 slice 同时指向的，因此对一个 slice 的元素进行操作是有可能影响到其他 slice 的。

如果底层数组长度是 n，切片起始下标是 l，则 cap = n - l。
如果用可访问区间来表示，起始位置为 l，最后一个可访问位置为 r（含），则 cap = r - l + 1。


# 2 截取

截取也是比较常见的一种创建 slice 的方法，可以从数组或者 slice 直接截取，当然需要指定起止索引位置，注意这个起止索引
位置是左闭右开区间。
基于已有 slice 创建新 slice 对象，被称为 reslice。新 slice 和老 slice 共用底层数组，新老 slice 对底层数组的更改
都会影响到彼此。基于数组创建的新 slice 对象也是同样的效果：对数组或 slice 元素作的更改都会影响到彼此。
值得注意的是，新老 slice 或者新 slice 老数组互相影响的前提是两者共用底层数组，如果因为执行 append 操作使得新 slice
底层数组扩容，移动到了新的位置，两者就不会相互影响了。所以，问题的关键在于两者是否会共用底层数组。

## 2.1 三下标切片表达式 `s[low:high:max]`（Full Slice Expression）

普通的二下标截取 `s[low:high]` 会让新切片继承原切片的剩余容量，这意味着新切片 append 时可能不会触发扩容，
而是直接写入原底层数组，污染其他切片的数据。这是很多共享底层数组 bug 的根源。

Go 提供了三下标语法来**显式控制新切片的容量**：

```go
s[low : high : max]
// len = high - low
// cap = max - low   （注意：max <= cap(s)）
```

```go
original := []int{1, 2, 3, 4, 5}

// 普通截取：sub 的 cap = 5 - 1 = 4，append 不会触发扩容，会污染 original[3]
sub := original[1:3]
fmt.Println(len(sub), cap(sub)) // 2, 4
sub = append(sub, 999)
fmt.Println(original) // [1 2 3 999 5]  ← original 被污染了！

// 三下标截取：sub2 的 cap = 3 - 1 = 2，append 必然触发扩容，和 original 彻底脱钩
original2 := []int{1, 2, 3, 4, 5}
sub2 := original2[1:3:3]
fmt.Println(len(sub2), cap(sub2)) // 2, 2
sub2 = append(sub2, 999)
fmt.Println(original2) // [1 2 3 4 5]  ← 安全，未被污染
```

**什么时候该用三下标？**

- 当你从一个大切片中截取子切片并需要独立 append 时，用 `s[low:high:high]` 将 cap 限制为 len，
  强制后续 append 触发扩容，避免意外共享
- 在库/框架代码中返回内部切片的子切片给调用者时，应该用三下标防止调用者的 append 污染内部数据
- 如果只是读取子切片不做 append，普通二下标即可

# 3 slice 和数组的区别在哪?
slice 的底层数据是数组，slice 是对数组的封装，它描述一个数组的片段。两者都可以通过下标来访问单个元素。
数组是定长的，长度定义好之后，不能再更改。在 Go 中，数组是不常见的，因为其长度是类型的一部分，限制了它的表达能力，
比如 [3]int 和 [4]int 就是不同的类型。 而切片则非常灵活，它可以动态地扩容。切片的类型和长度无关。
那么，Golang中为何要有数组这种数据类型呢？数组合适的应用场景是什么呢？
因为数组是不可变的，所以可以作为哈希表(map)的键(key)，但切片是可变的，就不行；
数组长度是类型的一部分，在常量索引等场景下可提供更强的静态检查能力；运行时越界仍会 panic。

# 4 append 到底做了什么?
使用 append 可以向 slice 追加元素，实际上是往底层数组添加元素。但是底层数组的长度是固定的，如果索引 len-1 所指向的
元素已经是底层数组的最后一个元素，就没法再添加了。 这时，slice 会迁移到新的内存位置，新底层数组的长度也会增加，这样
就可以放置新增的元素。同时，为了应对未来可能再次发生的 append 操作，新的底层数组的长度，也就是新 slice 的容量是
留了一定的 buffer 的。否则，每次添加元素的时候，都会发生迁移，成本太高。

**切片的扩容策略：**
不同 Go 版本对增长规则有差异，且会受到内存分配器 size class 对齐影响，不应机械记忆成固定倍数。
以 Go 1.18+ 为例，runtime 的目标增长趋势是：
- 当 oldCap 较小时，通常接近 2x；
- 当 oldCap 增大后，增长倍率逐步收敛到约 1.25x；
- 实际 cap 还会因分配器对齐出现“台阶值”（例如可能出现 1280 -> 1696 这类跳变）。

因此工程上应把"扩容大致趋势"作为认知，而不是把某个常数当成稳定契约。

## 4.1 growslice 源码分析

append 在容量不够时，编译器会插入对 `runtime.growslice` 的调用。以 Go 1.21 为例，核心逻辑如下
（源码位于 `runtime/slice.go`）：

```go
// 简化版，省略了溢出检查和部分细节
func growslice(oldPtr unsafe.Pointer, newLen, oldCap, num int, et *_type) slice {
    // 1. 计算目标容量
    newcap := nextslicecap(newLen, oldCap)

    // 2. 根据元素大小 * newcap 算出需要多少字节
    // 3. 向内存分配器的 size class 对齐（roundupsize）
    //    这一步是产生"台阶值"的原因
    capmem := roundupsize(uintptr(newcap) * et.Size_)
    newcap = int(capmem / et.Size_)

    // 4. 分配新内存
    p := mallocgc(capmem, et, true)

    // 5. 把旧数据 memmove 到新地址
    memmove(p, oldPtr, oldLen * et.Size_)

    return slice{p, newLen, newcap}
}

func nextslicecap(newLen, oldCap int) int {
    newcap := oldCap
    doublecap := newcap + newcap
    if newLen > doublecap {
        return newLen          // 一次性追加大量元素，直接用需要的长度
    }
    const threshold = 256
    if oldCap < threshold {
        return doublecap       // 小容量：翻倍
    }
    // 大容量：按 newcap += (newcap + 3*threshold) / 4 逐步增长
    // 增长率从 ~2x 平滑过渡到 ~1.25x
    for {
        newcap += (newcap + 3*threshold) / 4
        if newcap >= newLen {
            return newcap
        }
    }
}
```

可以用 [trap/slice_expand_and_modify.go](trap/slice_expand_and_modify.go) 中的 `VerifySliceExpand()` 函数来验证实际的扩容轨迹
（对应截图 [trap/images/slice-expand-strategy.png](trap/images/slice-expand-strategy.png)）：

```
小容量阶段（<256）：0→1→2→4→8→16→32→64→128→256→512→1024   ← 严格翻倍
过渡阶段：1024→1280→1696→2304                                ← 增长率逐步降低
```

从 1024→1280，增长率是 1.25x；从 1280→1696，增长率是 1.325x；这些"非整数"增长都是 `roundupsize`
对齐到内存分配器 size class 后的结果。**所以扩容的最终 cap 是 nextslicecap 和 roundupsize 共同决定的**，
单独看任何一个都不完整。

# 5 nil slice、empty slice 与零值语义

## 5.1 为什么 nil slice 可以直接 append?

其实 nil slice 或者 empty slice 都是可以通过调用 append 函数来获得底层数组的扩容。最终都是调用 mallocgc 来向
Go 的内存管理器申请到一块内存，然后再赋给原来的nil slice 或 empty slice，然后摇身一变，成为"真正"的 slice 了。

## 5.2 nil slice vs empty slice：看起来一样，行为不同

三种初始化方式产生的切片，`len` 和 `cap` 都是 0，`append`、`for range`、`len()` 的行为也完全一致，
但它们在**判等**和**序列化**时有关键差异：

```go
var s1 []int             // nil slice：  array 指针为 nil
s2 := []int{}            // empty slice：array 指针非 nil，指向一个零长度数组
s3 := make([]int, 0)     // empty slice：同 s2
```

```go
// 判等差异
fmt.Println(s1 == nil)   // true
fmt.Println(s2 == nil)   // false
fmt.Println(s3 == nil)   // false

// JSON 序列化差异 —— 这是生产中最常踩的坑
json.Marshal(s1)          // → "null"
json.Marshal(s2)          // → "[]"
```

**为什么这很重要？**

如果你的 API 返回一个切片字段，前端收到 `"items": null` 和 `"items": []` 的处理逻辑通常不同。
很多前端框架遍历 `null` 会报错，而遍历 `[]` 不会。

```go
type Response struct {
    Items []Item `json:"items"`
}

// ❌ 如果没有结果，Items 是 nil → JSON 输出 "items": null
resp := Response{}

// ✅ 显式初始化为空切片 → JSON 输出 "items": []
resp := Response{Items: []Item{}}

// ✅ 或者在序列化前兜底
if resp.Items == nil {
    resp.Items = []Item{}
}
```

**实践建议**：
- 函数内部处理逻辑中，nil slice 和 empty slice 几乎没有区别，不需要特意区分
- 在**对外输出**（JSON 响应、protobuf、日志）时，如果语义上是"空列表"而非"不存在"，应显式初始化为 `[]T{}`
- `reflect.DeepEqual(s1, s2)` 对 nil slice 和 empty slice 返回 `false`，在单元测试中要注意

# 6 传 slice 和 slice 指针有什么区别？
**首先要明确的是Golang中只有值传递**
当我们向函数或方法中传递的参数是指针时，其实也是值传递，因为指针也是值的一种，只不过它传递的是地址而已。
数组因为是值传递，传递时会复制(copy)内存，因此开销是比较大的；而切片底层是结构体，所以只是拷贝长度和容量以及指向底层
数组的指针，相比之下开销要小很多。
正因如此，拷贝大切片并不比拷贝小切片代价更大，因为都是拷贝长度和容量以及指向底层数组的指针三个字段，无非是长度和容量两个字段的
值大一些而已。 前面我们说到，slice 其实是一个结构体，包含了三个成员：len, cap, array。分别表示切片长度，容量，底层数据的地址。
当 slice 作为函数参数时，就是一个普通的结构体。其实很好理解：若直接传 slice，在调用者看来，实参 slice 并不会被函数中的操作
改变；若传的是 slice 的指针，在调用者看来，是会改变原 slice 的。
值得注意的是，不管传的是 slice 还是 slice 指针，如果改变了 slice 所指向的底层数组的数据，会反应到实参 slice 的底层数据。为什么能
改变底层数组的数据？很好理解：底层数据在 slice 结构体里是一个指针，尽管 slice 结构体自身不会被改变，也就是说底层数据地址不会被改变。 但是通过指向底层数据的指针，可以改变切片的底层数据，没有问题。
通过slice的array字段就可以拿到数组的地址。在代码里，是直接通过类似 s[i]=10 这种操作改变slice底层数组元素值。


```golang

package main

import "fmt"

func main() {
    s := []int{1, 1, 1}
    f(s)
    fmt.Println(s)
}

func f(s []int) {
        // i只是一个副本，不能改变s中元素的值
        //for _, i := range s {
        //    i++
        //}
		// 通过下表索引赋值的方式可以修改底层数组
        for i := range s {
                s[i] += 1
        }
}

```


通过下表索引赋值的方式改变了原始切片的底层数据。这里传递的是一个切片的副本，在函数f中，s只是main函数中s的一个拷贝。
在函数f内部，对 s 的作用并不会改变外层 main 函数的 s，但底层元素却确认被改变了。
要想真的改变外层 slice，只有将返回的新的 slice 赋值到原始 slice，或者向函数传递一个指向 slice 的指针。我们再来看一个例子：


```golang

package main

import "fmt"

func myAppend(s []int) []int {
    // 这里 s 虽然改变了，但并不会影响外层函数的 s
    s = append(s, 100)
    return s
}

func myAppendPtr(s *[]int) {
    // 会改变外层 s 本身
    *s = append(*s, 100)
    return
}

func main() {
    s := []int{1, 1, 1}
    newS := myAppend(s)
    fmt.Println(s)
    fmt.Println(newS)

    s = newS

    myAppendPtr(&s)
    fmt.Println(s)
}

```



myAppend 函数里，虽然改变了s，但它只是一个值传递，并不会影响外层的s，因此第一行打印出来的结果仍然是 [1 1 1]。
而 newS 是一个新的 slice，它是基于 s 得到的。因此它打印的是追加了一个 100 之后的结果： [1 1 1 100]。
最后，将 newS 赋值给了 s，s 这时才真正变成了一个新的slice。之后，再给 myAppendPtr 函数传入一个 s 指针，
这回它真的被改变了：[1 1 1 100 100]。


# 7 切片陷阱实战：5 个 modify 函数逐案分析

> 完整代码见 [trap/slice_expand_and_modify.go](trap/slice_expand_and_modify.go)。

理解切片的关键在于同时追踪两件事：**slice header（len, cap, array 指针）** 和 **底层数组的共享关系**。
下面 5 个案例系统性地覆盖了 append + 值传递 + 共享底层数组的所有交互组合。

前置条件：`generateSlice()` 返回的切片是 `[]int{0, 1, 2}`，**len=3, cap=4**。

```go
func generateSlice() []int {
    s := []int{}
    for i := 0; i < 3; i++ {
        s = append(s, i)
    }
    return s
}
```

为什么 cap=4？因为 append 过程中经历了 0→1→2→4 的扩容（小容量翻倍），最终 len=3 但 cap=4，
**底层数组还有 1 个空闲槽位**。这个"多出来的 1"是所有后续陷阱的根源。

### Case 1: modifyOne — 直接修改元素，调用者可见

```go
func modifyOne(s []int) {
    s[0] = 1024
}
// main 中：s1 = [0,1,2](len=3,cap=4) → 调用后 s1 = [1024, 1, 2]
```

**分析**：函数参数 `s` 是 slice header 的副本，但 `array` 指针指向同一个底层数组。
`s[0] = 1024` 通过指针直接修改了底层数组，调用者可见。

> 结论：值传递不影响通过下标修改底层数组。

### Case 2: modifyTwo — append 未扩容 + 修改元素

```go
func modifyTwo(s []int) {
    s = append(s, 2048)  // len: 3→4, cap: 4, 未扩容！
    s[0] = 1024          // 修改的是同一个底层数组
}
// main 中：s2 = [0,1,2](len=3,cap=4) → 调用后 s2 = [1024, 1, 2]
```

**分析**：append 前 len=3, cap=4，还有 1 个空闲槽位，**append 不触发扩容**，
2048 被写入底层数组的 `[3]` 位置。`s[0] = 1024` 修改的仍是原底层数组，调用者可见。
但调用者的 slice header 仍然是 len=3，所以看不到 `[3]` 位置的 2048。

```
函数内 s:  [1024, 1, 2, 2048]  len=4, cap=4
调用者 s2: [1024, 1, 2]        len=3, cap=4  ← len 没变，看不到 2048
```

> 结论：append 未扩容时，底层数组共享，下标修改可见；但调用者的 len 不变，新 append 的元素不可见。

### Case 3: modifyThree — 两次 append 触发扩容 + 修改元素

```go
func modifyThree(s []int) {
    s = append(s, 2048)  // len: 3→4, cap: 4, 未扩容
    s = append(s, 4096)  // len: 4→5, cap: 4→8, 扩容！迁移到新数组
    s[0] = 1024          // 修改的是新数组，与原数组无关
}
// main 中：s3 = [0,1,2](len=3,cap=4) → 调用后 s3 = [0, 1, 2]
```

**分析**：第一次 append 未扩容（cap=4 够用）。第二次 append 时 len=4, cap=4，容量不够，
触发 growslice 扩容到 cap=8，**底层数组迁移到新地址**。此后 `s[0] = 1024` 修改的是新数组，
原数组完全不受影响。

```
函数内 s:  [1024, 1, 2, 2048, 4096]  len=5, cap=8  ← 新数组
调用者 s3: [0, 1, 2]                  len=3, cap=4  ← 原数组，未被修改
```

> 结论：扩容导致底层数组迁移，此后的任何修改与原切片无关。

### Case 4: modifyFour — 先修改元素再 append 扩容

```go
func modifyFour(s []int) {
    s[0] = 1024          // 先修改，此时还是原数组
    s = append(s, 2048)  // len: 3→4, cap: 4, 未扩容
    s = append(s, 4096)  // len: 4→5, cap: 4→8, 扩容
}
// main 中：s4 = [0,1,2](len=3,cap=4) → 调用后 s4 = [1024, 1, 2]
```

**分析**：`s[0] = 1024` 在扩容之前执行，修改的是原底层数组，调用者可见。
后续扩容虽然迁移了数组，但那时修改已经发生了。

> 结论：修改操作的可见性取决于**执行时**是否共享底层数组，与后续是否扩容无关。

### Case 5: modifyFive — 同一基底两次 append 互相覆盖（最隐蔽的陷阱）

```go
func modifyFive(s []int) {
    s1 := append(s, 2048)  // s 的 len=3, cap=4, 未扩容, s1[3]=2048
    s2 := append(s, 4096)  // s 的 len 仍然是 3！再次从 [3] 位置写入，覆盖 2048
}
// 结果：s1 = [0,1,2,4096], s2 = [0,1,2,4096]  ← s1[3] 被 s2 的 append 覆盖了！
```

**分析**：这是最经典的陷阱。两次 append 都以 `s`（len=3, cap=4）为基底：

```
初始状态：  底层数组 = [0, 1, 2, ?]   s.len=3, s.cap=4
                                      ↑ [3] 是空闲槽位

s1 = append(s, 2048):  底层数组 = [0, 1, 2, 2048]  s1.len=4, s1.cap=4
                        但 s 的 len 仍然是 3！

s2 = append(s, 4096):  底层数组 = [0, 1, 2, 4096]  s2.len=4, s2.cap=4
                        ↑ 再次从 [3] 写入，覆盖了 2048！
                        s1 和 s2 共享底层数组，所以 s1[3] 也变成了 4096
```

这个问题的根源是：**append 不会修改原 slice 的 len**，所以第二次 `append(s, 4096)`
仍然认为 `s` 的有效长度是 3，从 `[3]` 位置开始写入，覆盖了第一次 append 的结果。

> 结论：不要从同一个 base slice 分叉出多个 append。如果需要分叉，用三下标 `s[:len(s):len(s)]`
> 或 `slices.Clone(s)` 先断开共享。

```go
// 安全做法：用三下标截断 cap，强制 append 扩容
s1 := append(s[:len(s):len(s)], 2048)  // 强制扩容，独立底层数组
s2 := append(s[:len(s):len(s)], 4096)  // 强制扩容，独立底层数组
// s1 = [0,1,2,2048], s2 = [0,1,2,4096]  ← 互不干扰
```

### 5 个案例的核心规律

| 因素 | 影响 |
|------|------|
| append 是否触发扩容 | **未扩容**：底层数组共享，下标修改对调用者可见。**扩容**：底层数组迁移，修改与原切片无关 |
| 调用者的 len 是否更新 | 值传递下，函数内的 append 不会更新调用者的 len，即使底层数组已被写入 |
| 修改发生在扩容前还是后 | 扩容前的修改写入原数组（可见），扩容后的修改写入新数组（不可见） |
| 多次 append 共享基底 | 后一次 append 会覆盖前一次在空闲槽位写入的值 |

### 附加案例：SliceRiseOne vs SliceRiseTwo — cap 决定命运 + range 值拷贝

> 同样来自 [trap/slice_expand_and_modify.go](trap/slice_expand_and_modify.go)。

```go
func SliceRiseOne(s []int) {
    s = append(s, 0)
    for i := range s {
        s[i]++
    }
}

func SliceRiseTwo(s []int) {
    s = append(s, 0)
    for _, v := range s {
        v++    // v 是元素的副本，修改无效
    }
}
```

main 中的调用：

```go
s6 := []int{1, 2}           // len=2, cap=2
s7 := s6
s7 = append(s7, 3)          // s6 的 cap=2 不够 → 扩容 → s7 = [1,2,3] len=3, cap=4
SliceRiseOne(s6)             // s6 不变
SliceRiseOne(s7)             // s7 变为 [2, 3, 4]
fmt.Println(s6, s7)          // [1 2] [2 3 4]
```

**为什么 `SliceRiseOne(s6)` 没有效果，而 `SliceRiseOne(s7)` 有效果？**

```
s6: len=2, cap=2
  → append(s, 0) 时 cap 不够，触发扩容，迁移到新数组
  → s[i]++ 修改的是新数组，调用者的 s6 完全不受影响

s7: len=3, cap=4
  → append(s, 0) 时 cap=4 够用，不扩容，底层数组共享
  → s[i]++ 修改的是原数组，调用者的 s7 看到 [2, 3, 4]
  （s7 的 len=3，所以看到前 3 个元素的 +1 结果）
```

这和 modifyTwo vs modifyThree 是同一个规律：**cap 是否有剩余空间决定了 append 是否扩容，进而决定了修改是否对调用者可见**。

**SliceRiseTwo 为什么完全无效？**

`for _, v := range s` 中的 `v` 是元素的**值拷贝**，`v++` 只修改了副本，不会写回 slice。
这是 Go range 循环的基本语义：如果要修改元素，必须用下标 `s[i]++`，不能用 `v++`。


# 8 切片的深浅拷贝
- 深拷贝和浅拷贝的本质区别就是复制出来的对象与原对象是否会指向同一个地址，浅拷贝是指向同一内存地址的，所以复制出来的新对象与原来
的对象无论谁发生改变时，都是会相互影响的，深拷贝则不存在这个问题。

- 使用"="操作符拷贝切片，是浅拷贝
- 使用[:]下标的方式复制切片，这种也是浅拷贝
- 使用 Go 语言内置函数 copy() 会把“这一层切片元素”复制到新的底层数组中，可避免与原切片共享同一段 backing array。
但如果元素本身是引用类型（如 map、slice、指针、包含指针的结构体），copy 仍然只是元素级拷贝，不会递归深拷贝其内部对象。

## 8.1 子切片导致的大对象滞留（memory retention）

这是生产中非常常见但又不容易第一时间定位的问题：
当你只需要大切片末尾几个元素时，如果直接返回子切片，子切片仍然引用整段底层数组，导致大对象无法被 GC 回收。

```go
func GetLastBySlice(origin []int) []int {
    return origin[len(origin)-2:] // 仍引用 origin 的 backing array
}

func GetLastByCopy(origin []int) []int {
    result := make([]int, 2)
    copy(result, origin[len(origin)-2:]) // 断开底层数组引用
    return result
}
```

对应代码：
- `trap/slice_memory_release.go`
- `trap/slice_memory_release_test.go`

该问题已做成可断言测试，而不是仅靠日志观察：
- 语义断言：`GetLastBySlice` 共享底层数组；`GetLastByCopy` 与原数组脱钩；
- 统计断言：多轮采样 + `runtime.GC()` + 中位数比较；
- 阈值断言：`slice` 方案的 retained memory 必须显著高于 `copy` 方案（比例阈值 + 上下界阈值）。

运行：

```shell
cd goprincipleandpractise/slice/trap
go test -run '^TestGetLast' -v .
```

经验法则：
- 需要长期保存小窗口结果时，优先 `copy` 断开引用；
- 临时读、生命周期极短时，直接子切片可以接受，但要确认不会被缓存到长生命周期结构中。

# 9 切片与数组的相互转换（Go 1.17+ / 1.20+）

Go 早期版本中，slice 和 array 之间的转换需要借助 `unsafe`。新版本提供了安全的语法支持。

## 9.1 slice → array pointer（Go 1.17+，零拷贝）

```go
s := []int{1, 2, 3, 4, 5}

// 转换为数组指针，零拷贝，共享底层数据
p := (*[3]int)(s)        // p 指向 s 底层数组的前 3 个元素
fmt.Println(p)           // &[1 2 3]

p[0] = 999
fmt.Println(s)           // [999 2 3 4 5]  ← 共享底层数组，修改互相可见
```

注意：如果数组长度大于 slice 的长度，会 panic：

```go
s := []int{1, 2, 3}
p := (*[5]int)(s)  // panic: cannot convert slice with length 3 to array or pointer to array with length 5
```

## 9.2 slice → array 值拷贝（Go 1.20+）

```go
s := []int{1, 2, 3, 4, 5}

// 值拷贝，独立副本，修改互不影响
a := [3]int(s)
fmt.Println(a)           // [1 2 3]

a[0] = 999
fmt.Println(s)           // [1 2 3 4 5]  ← 不受影响
```

**使用场景**：
- 将 slice 作为 map 的 key（array 是可比较类型，slice 不是）
- 需要固定长度的值语义传递
- 与 C 互操作、加密算法等需要定长数组的场景

# 10 切片的并发安全

slice **不是 goroutine-safe** 的。多个 goroutine 并发读写同一个 slice（包括并发 append）是数据竞争（data race），
行为未定义，可能导致程序 crash 或数据损坏。

```go
// ❌ 错误示例：并发 append 是数据竞争
s := make([]int, 0, 1000)
var wg sync.WaitGroup
for i := 0; i < 10; i++ {
    wg.Add(1)
    go func(val int) {
        defer wg.Done()
        s = append(s, val) // DATA RACE!
    }(i)
}
wg.Wait()
// s 的长度可能不是 10，甚至可能 panic
```

用 `go test -race` 可以检测到这类问题。常见的解决方案：

**方案一：加锁**

```go
var mu sync.Mutex
var s []int

mu.Lock()
s = append(s, val)
mu.Unlock()
```

**方案二：channel 收集**

```go
ch := make(chan int, 10)
for i := 0; i < 10; i++ {
    go func(val int) {
        ch <- val
    }(i)
}

s := make([]int, 0, 10)
for i := 0; i < 10; i++ {
    s = append(s, <-ch)
}
```

**方案三：预分配 + 下标写入（各写各的，无竞争）**

如果每个 goroutine 写入不同的下标位置，则不需要加锁：

```go
s := make([]int, 10)
var wg sync.WaitGroup
for i := 0; i < 10; i++ {
    wg.Add(1)
    go func(idx int) {
        defer wg.Done()
        s[idx] = idx * idx // 各写各的下标，无竞争
    }(i)
}
wg.Wait()
```

> 核心原则：并发 append 必须加锁或用 channel；并发下标写入不同位置是安全的（前提是 slice 已预分配且不 append）。

# 11 slices 标准库（Go 1.21+）

Go 1.21 引入了 `slices` 标准库包，提供了类型安全的泛型切片操作函数，
避免手写循环和常见错误：

```go
import "slices"

// Clone — 浅克隆，断开底层数组共享（替代手动 make + copy）
s := []int{1, 2, 3}
s2 := slices.Clone(s)

// Grow — 预扩容至少 n 个额外容量（不改变 len）
s = slices.Grow(s, 1000)

// Compact — 去除相邻重复元素（需先排序）
s = slices.Compact(s)

// Delete — 删除 [i, j) 范围的元素，保持顺序
s = slices.Delete(s, 1, 3)

// Insert — 在位置 i 插入元素
s = slices.Insert(s, 1, 99, 100)

// SortFunc — 自定义排序
slices.SortFunc(s, func(a, b int) int { return a - b })

// Contains / Index — 查找
slices.Contains(s, 42)
slices.Index(s, 42)
```

**为什么推荐用 slices 包？**

1. **`slices.Clone`** 是第 7 节 modifyFive 那类"共享底层数组"问题的标准解法
2. **`slices.Delete`** 正确处理了删除后的元素清零（Go 1.22+ 会将尾部失效元素置零，避免内存泄漏）
3. 手写 `append(s[:i], s[i+1:]...)` 删除元素容易忘记清零尾部，导致被删除元素的引用无法被 GC 回收

```go
// 手写删除的隐患——忘记清零尾部元素
func deleteManual(s []*User, i int) []*User {
    copy(s[i:], s[i+1:])
    s[len(s)-1] = nil  // ← 容易忘记！不清零会导致 *User 引用无法被 GC
    return s[:len(s)-1]
}

// 推荐：直接用 slices.Delete，内部已处理清零
s = slices.Delete(s, i, i+1)
```

# 12 clear 内建函数（Go 1.21+）

Go 1.21 新增了内建函数 `clear`，可以将切片的所有元素归零，而不改变 len 和 cap：

```go
s := []int{1, 2, 3, 4, 5}
clear(s)
fmt.Println(s)       // [0 0 0 0 0]
fmt.Println(len(s))  // 5（不变）
fmt.Println(cap(s))  // 5（不变）
```

**和 `s = s[:0]` 的区别**：

| 操作 | len | cap | 元素是否归零 | 底层数组是否释放 |
|------|-----|-----|-------------|----------------|
| `clear(s)` | 不变 | 不变 | 是 | 否 |
| `s = s[:0]` | 变为 0 | 不变 | 否（旧元素仍在底层数组中） | 否 |
| `s = nil` | 变为 0 | 变为 0 | — | 由 GC 决定 |

`clear` 的主要价值在于**安全清零引用类型元素**，防止底层数组持有过期引用导致内存泄漏：

```go
type Conn struct { /* 大对象 */ }
pool := make([]*Conn, 0, 100)

// 使用完毕后，想复用 pool 但释放里面的 *Conn
clear(pool)  // 所有元素置为 nil，GC 可以回收 Conn 对象
pool = pool[:0]  // 重置 len，准备复用
```

# 13 如何提升切片的操作性能?
- 对切片预先分配内存通常可以显著减少扩容次数和内存分配；
- 当最终长度已知且不需要条件过滤时，直接使用 index 赋值通常比 append 更省开销；
- 如果能确定访问边界，可利用 BCE（bounds check elimination）减少循环中的边界检查成本。

需要注意：性能结论必须建立在规范 benchmark 上（使用 b.N、避免在基准路径上做 I/O、固定输入规模）。


# 14 总结

我们最后来总结一下：

**基础**
- 切片是对底层数组的一个抽象，本质是 `{array unsafe.Pointer, len int, cap int}` 三字段结构体。
- 多个切片可能共享同一个底层数组，对其中一个切片或底层数组的更改，会影响到其他切片。
- 用三下标截取 `s[low:high:max]` 可以显式控制新切片的容量，防止 append 污染原底层数组。

**append 与扩容**
- append 容量不够时调用 `runtime.growslice`：先由 `nextslicecap` 计算目标容量，再由 `roundupsize` 对齐到 size class。
- 扩容策略是"随容量变化的增长曲线 + 分配器对齐"，不要把固定倍数当作跨版本契约。
- 扩容会导致底层数组迁移，此后的修改与原切片无关；未扩容时修改共享底层数组，调用者可见。

**值传递与陷阱**
- 值传递下，函数内 append 不会更新调用者的 len/cap，即使底层数组已被写入。
- 从同一基底分叉多次 append 会互相覆盖空闲槽位（modifyFive 陷阱），应使用三下标或 `slices.Clone` 断开共享。
- 同一函数传入不同 cap 的 slice，append 后的修改可见性可能截然相反（SliceRiseOne 陷阱）。
- `for _, v := range s` 中 `v` 是值拷贝，修改 `v` 不会写回 slice，要改元素必须用下标。

**nil vs empty**
- nil slice（`var s []int`）和 empty slice（`[]int{}`）的 len/cap 都是 0，append/range 行为一致。
- 但 `nil slice == nil` 为 true，JSON 序列化为 `null`；empty slice 序列化为 `[]`。API 返回空列表应显式初始化为 `[]T{}`。

**拷贝与类型转换**
- `=` 和 `[:]` 是浅拷贝；`copy()` 是元素级复制，遇到引用类型不等于递归深拷贝。
- Go 1.17+ 支持 `(*[N]T)(s)` 零拷贝转数组指针；Go 1.20+ 支持 `[N]T(s)` 值拷贝转数组。

**并发安全**
- slice 不是 goroutine-safe 的，并发 append 是数据竞争。解决方案：加锁、channel 收集、或预分配后各写各的下标。

**现代 Go**
- Go 1.21+ 的 `slices` 标准库提供 Clone、Delete、Insert、SortFunc 等泛型函数，优先使用。
- `slices.Delete` 会清零尾部失效元素，避免手写删除忘记清零导致的内存泄漏。
- `clear(s)` 将所有元素归零但不改变 len/cap，适合安全清零引用类型元素后复用切片。

**性能**
- 对切片预先分配内存可以提升性能。
- 在"长度已知且不需要过滤"的前提下，直接使用 index 赋值通常比 append 更高效。
- 如果能确定访问到的 slice 长度，可利用 BCE 让编译器消除循环内的边界检查。
