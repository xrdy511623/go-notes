
---
切片详解
---

# 1 当我们在说slice时，到底在说什么？

slice翻译成中文就是切片，它和数组（array）很类似，可以用下标的方式进行访问，如果越界，就会产生 panic。但是它比数组更灵活，可以自动地进行扩容。
要了解slice的本质，最简单的方法就是看它的源代码：


```golang
// runtime/slice.go
type slice struct {
	array unsafe.Pointer // 元素指针
	len   int // 长度 
	cap   int // 容量
}
```


> slice 共有三个属性：
- 指针，指向底层数组；
- 长度，表示切片可用元素的个数，也就是说使用下标对 slice 的元素进行访问时，下标不能超过 slice 的长度；
- 容量，表示从当前切片起始位置到底层数组末尾，可容纳的元素个数（cap >= len）。在不扩容的情况下，cap 就是可增长上限。
注意，底层数组是可以被多个 slice 同时指向的，因此对一个 slice 的元素进行操作是有可能影响到其他 slice 的。

如果底层数组长度是 n，切片起始下标是 l，则 cap = n - l。
如果用可访问区间来表示，起始位置为 l，最后一个可访问位置为 r（含），则 cap = r - l + 1。


# 2 截取

截取也是比较常见的一种创建 slice 的方法，可以从数组或者 slice 直接截取，当然需要指定起止索引位置，注意这个起止索引
位置是左闭右开区间。
基于已有 slice 创建新 slice 对象，被称为 reslice。新 slice 和老 slice 共用底层数组，新老 slice 对底层数组的更改
都会影响到彼此。基于数组创建的新 slice 对象也是同样的效果：对数组或 slice 元素作的更改都会影响到彼此。
值得注意的是，新老 slice 或者新 slice 老数组互相影响的前提是两者共用底层数组，如果因为执行 append 操作使得新 slice 
底层数组扩容，移动到了新的位置，两者就不会相互影响了。所以，问题的关键在于两者是否会共用底层数组。

# 3 slice 和数组的区别在哪?
slice 的底层数据是数组，slice 是对数组的封装，它描述一个数组的片段。两者都可以通过下标来访问单个元素。
数组是定长的，长度定义好之后，不能再更改。在 Go 中，数组是不常见的，因为其长度是类型的一部分，限制了它的表达能力，
比如 [3]int 和 [4]int 就是不同的类型。 而切片则非常灵活，它可以动态地扩容。切片的类型和长度无关。
那么，Golang中为何要有数组这种数据类型呢？数组合适的应用场景是什么呢？
因为数组是不可变的，所以可以作为哈希表(map)的键(key)，但切片是可变的，就不行；
数组长度是类型的一部分，在常量索引等场景下可提供更强的静态检查能力；运行时越界仍会 panic。

# 4 append 到底做了什么?
使用 append 可以向 slice 追加元素，实际上是往底层数组添加元素。但是底层数组的长度是固定的，如果索引 len-1 所指向的
元素已经是底层数组的最后一个元素，就没法再添加了。 这时，slice 会迁移到新的内存位置，新底层数组的长度也会增加，这样
就可以放置新增的元素。同时，为了应对未来可能再次发生的 append 操作，新的底层数组的长度，也就是新 slice 的容量是
留了一定的 buffer 的。否则，每次添加元素的时候，都会发生迁移，成本太高。

**切片的扩容策略：**
不同 Go 版本对增长规则有差异，且会受到内存分配器 size class 对齐影响，不应机械记忆成固定倍数。
以 Go 1.18+ 为例，runtime 的目标增长趋势是：
- 当 oldCap 较小时，通常接近 2x；
- 当 oldCap 增大后，增长倍率逐步收敛到约 1.25x；
- 实际 cap 还会因分配器对齐出现“台阶值”（例如可能出现 1280 -> 1696 这类跳变）。

因此工程上应把“扩容大致趋势”作为认知，而不是把某个常数当成稳定契约。


# 5 为什么nil的slice可以直接 append?
其实 nil slice 或者 empty slice 都是可以通过调用 append 函数来获得底层数组的扩容。最终都是调用 mallocgc 来向
Go 的内存管理器申请到一块内存，然后再赋给原来的nil slice 或 empty slice，然后摇身一变，成为“真正”的 slice 了。

# 6 传 slice 和 slice 指针有什么区别？
**首先要明确的是Golang中只有值传递**
当我们向函数或方法中传递的参数是指针时，其实也是值传递，因为指针也是值的一种，只不过它传递的是地址而已。
数组因为是值传递，传递时会复制(copy)内存，因此开销是比较大的；而切片底层是结构体，所以只是拷贝长度和容量以及指向底层
数组的指针，相比之下开销要小很多。
正因如此，拷贝大切片并不比拷贝小切片代价更大，因为都是拷贝长度和容量以及指向底层数组的指针三个字段，无非是长度和容量两个字段的
值大一些而已。 前面我们说到，slice 其实是一个结构体，包含了三个成员：len, cap, array。分别表示切片长度，容量，底层数据的地址。
当 slice 作为函数参数时，就是一个普通的结构体。其实很好理解：若直接传 slice，在调用者看来，实参 slice 并不会被函数中的操作
改变；若传的是 slice 的指针，在调用者看来，是会改变原 slice 的。
值得注意的是，不管传的是 slice 还是 slice 指针，如果改变了 slice 所指向的底层数组的数据，会反应到实参 slice 的底层数据。为什么能
改变底层数组的数据？很好理解：底层数据在 slice 结构体里是一个指针，尽管 slice 结构体自身不会被改变，也就是说底层数据地址不会被改变。 但是通过指向底层数据的指针，可以改变切片的底层数据，没有问题。
通过slice的array字段就可以拿到数组的地址。在代码里，是直接通过类似 s[i]=10 这种操作改变slice底层数组元素值。


```golang

package main

import "fmt"

func main() {
    s := []int{1, 1, 1}
    f(s)
    fmt.Println(s)
}

func f(s []int) {
        // i只是一个副本，不能改变s中元素的值
        //for _, i := range s {
        //    i++
        //}
		// 通过下表索引赋值的方式可以修改底层数组
        for i := range s {
                s[i] += 1
        }
}

```


通过下表索引赋值的方式改变了原始切片的底层数据。这里传递的是一个切片的副本，在函数f中，s只是main函数中s的一个拷贝。
在函数f内部，对 s 的作用并不会改变外层 main 函数的 s，但底层元素却确认被改变了。
要想真的改变外层 slice，只有将返回的新的 slice 赋值到原始 slice，或者向函数传递一个指向 slice 的指针。我们再来看一个例子：


```golang

package main

import "fmt"

func myAppend(s []int) []int {
    // 这里 s 虽然改变了，但并不会影响外层函数的 s
    s = append(s, 100)
    return s
}

func myAppendPtr(s *[]int) {
    // 会改变外层 s 本身
    *s = append(*s, 100)
    return
}

func main() {
    s := []int{1, 1, 1}
    newS := myAppend(s)
    fmt.Println(s)
    fmt.Println(newS)

    s = newS

    myAppendPtr(&s)
    fmt.Println(s)
}

```



myAppend 函数里，虽然改变了s，但它只是一个值传递，并不会影响外层的s，因此第一行打印出来的结果仍然是 [1 1 1]。
而 newS 是一个新的 slice，它是基于 s 得到的。因此它打印的是追加了一个 100 之后的结果： [1 1 1 100]。
最后，将 newS 赋值给了 s，s 这时才真正变成了一个新的slice。之后，再给 myAppendPtr 函数传入一个 s 指针，
这回它真的被改变了：[1 1 1 100 100]。


# 7 切片的深浅拷贝
- 深拷贝和浅拷贝的本质区别就是复制出来的对象与原对象是否会指向同一个地址，浅拷贝是指向同一内存地址的，所以复制出来的新对象与原来
的对象无论谁发生改变时，都是会相互影响的，深拷贝则不存在这个问题。

- 使用"="操作符拷贝切片，是浅拷贝
- 使用[:]下标的方式复制切片，这种也是浅拷贝
- 使用 Go 语言内置函数 copy() 会把“这一层切片元素”复制到新的底层数组中，可避免与原切片共享同一段 backing array。
但如果元素本身是引用类型（如 map、slice、指针、包含指针的结构体），copy 仍然只是元素级拷贝，不会递归深拷贝其内部对象。

# 8 如何提升切片的操作性能?
- 对切片预先分配内存通常可以显著减少扩容次数和内存分配；
- 当最终长度已知且不需要条件过滤时，直接使用 index 赋值通常比 append 更省开销；
- 如果能确定访问边界，可利用 BCE（bounds check elimination）减少循环中的边界检查成本。

需要注意：性能结论必须建立在规范 benchmark 上（使用 b.N、避免在基准路径上做 I/O、固定输入规模）。


# 9 总结

我们最后来总结一下：
- 切片是对底层数组的一个抽象，描述了它的一个片段。
- 切片实际上是一个结构体，它有三个字段：长度，容量，底层数据的地址。
- 多个切片可能共享同一个底层数组，这种情况下，对其中一个切片或者底层数组的更改，会影响到其他切片。
- append 函数会在切片容量不够的情况下，调用 growslice 函数获取所需要的内存，这称为扩容，扩容会改变元素原来的位置。
- 扩容策略是“随容量变化的增长曲线 + 分配器对齐”，不要把固定倍数当作跨版本契约。
- 当直接用切片作为函数参数时，可以改变切片的元素，不能改变切片本身；想要改变切片本身，可以将改变后的切片返回，函数调用者接收改变后的切片或者将切片指针作为函数参数。
- 使用"="操作符拷贝切片和使用[:]下标的方式复制切片，都是浅拷贝；copy() 是元素级复制，遇到引用类型元素时不等于递归深拷贝。
- 对切片预先分配内存可以提升性能。
- 在“长度已知且不需要过滤”的前提下，直接使用 index 赋值通常比 append 更高效。
- 如果能确定访问到的 slice 长度，可以先执行一次让编译器去做优化，省去后续每次做索引下标是否越界检查的开销。
