
---
接口详解
---

# 1 接口是什么

接口（interface）是Go类型系统的灵魂。它定义了一组方法签名，任何类型只要实现了这些方法，
就自动满足该接口——无需显式声明"我实现了某接口"。这种**隐式实现**是Go与Java、C++等语言最大的区别。

```go
// 定义接口：只有方法签名，没有实现
type Writer interface {
    Write(p []byte) (n int, err error)
}

// 结构体实现——不需要任何显式声明
type FileWriter struct {
    Path string
}

func (fw *FileWriter) Write(p []byte) (n int, err error) {
    // 写入文件的具体逻辑
    return len(p), nil
}

// FileWriter 自动满足 Writer 接口，可以直接赋值
var w Writer = &FileWriter{Path: "/tmp/log"}
```

隐式实现带来的好处：
- **解耦**：实现方不需要import接口所在的包，接口定义方也不需要知道实现方的存在
- **可扩展**：第三方类型可以满足你定义的接口，无需修改第三方代码
- **轻量**：标准库中大量接口只有1-2个方法（如`io.Reader`、`io.Writer`、`fmt.Stringer`）


# 2 接口的内部表示

理解接口的底层结构，才能理解后续的nil陷阱、性能开销等问题。Go的接口在runtime中有两种表示。

## 2.1 eface：空接口

空接口`interface{}`（Go 1.18+别名`any`）没有方法要求，因此结构最简单：

```
type eface struct {
    _type *_type  // 指向具体类型信息
    data  unsafe.Pointer  // 指向实际数据
}
```

```
                 eface (16 bytes)
              ┌──────────┬──────────┐
              │  _type   │   data   │
              │  (8B)    │  (8B)    │
              └────┬─────┴────┬─────┘
                   │          │
                   ▼          ▼
             类型元数据     实际数据
            (size,kind,   (值本身或
             hash,方法表)   指向值的指针)
```

## 2.2 iface：非空接口

带方法的接口使用更复杂的结构，需要额外保存方法表（用于动态分派）：

```
type iface struct {
    tab  *itab            // 接口类型+具体类型+方法表
    data unsafe.Pointer   // 指向实际数据
}

type itab struct {
    inter *interfacetype  // 接口的类型信息
    _type *_type          // 具体类型的类型信息
    hash  uint32          // _type.hash的副本，用于快速类型断言
    fun   [1]uintptr      // 方法表（变长数组，存储具体方法的函数指针）
}
```

```
                  iface (16 bytes)
              ┌──────────┬──────────┐
              │   tab    │   data   │
              │  (8B)    │  (8B)    │
              └────┬─────┴────┬─────┘
                   │          │
                   ▼          ▼
                 itab       实际数据
          ┌──────────────┐
          │ inter (*interfacetype)
          │ _type (*_type)
          │ hash  (uint32)
          │ fun   [方法1, 方法2, ...]
          └──────────────┘
```

两种接口值都占**16字节**（两个指针），可以通过`unsafe.Sizeof`验证：

```go
var e interface{}
var w io.Writer
fmt.Println(unsafe.Sizeof(e)) // 16
fmt.Println(unsafe.Sizeof(w)) // 16
```

## 2.3 itab缓存

Go运行时会缓存已经计算过的itab，存储在一个全局哈希表中。当同一个（接口类型，具体类型）组合
第二次出现时，直接从缓存获取，无需重新计算方法表。这使得接口的动态分派开销极小。


# 3 类型断言与类型选择

## 3.1 类型断言

类型断言从接口值中提取具体类型的值：

```go
var w io.Writer = os.Stdout

// 安全模式：不会panic，通过ok判断
f, ok := w.(*os.File)
if ok {
    fmt.Println("是*os.File，fd =", f.Fd())
}

// 不安全模式：断言失败直接panic
f = w.(*os.File) // 成功
// b := w.(*bytes.Buffer) // panic: interface conversion
```

**始终使用安全模式**（带ok的形式），除非你能100%确定具体类型。

## 3.2 类型选择

当需要根据接口的具体类型执行不同逻辑时，使用`type switch`：

```go
func describe(i interface{}) string {
    switch v := i.(type) {
    case int:
        return fmt.Sprintf("整数 %d", v)
    case string:
        return fmt.Sprintf("字符串 %q", v)
    case io.Writer:
        return "实现了io.Writer"
    case nil:
        return "nil接口"
    default:
        return fmt.Sprintf("未知类型 %T", v)
    }
}
```

注意：`type switch`中的case按顺序匹配，**接口类型的case**匹配的是"是否实现了该接口"，
而不是精确类型匹配。如果一个值同时匹配多个case，只执行第一个。


# 4 接口组合

Go推崇**小接口组合**，而非大而全的接口。标准库是这一理念的最佳范例：

```go
// 标准库中的小接口
type Reader interface {
    Read(p []byte) (n int, err error)
}

type Writer interface {
    Write(p []byte) (n int, err error)
}

type Closer interface {
    Close() error
}

// 通过嵌入组合成更大的接口
type ReadWriter interface {
    Reader
    Writer
}

type ReadWriteCloser interface {
    Reader
    Writer
    Closer
}
```

这种设计使得：
- `*os.File`实现了`ReadWriteCloser`（因为它有Read、Write、Close方法）
- `*bytes.Buffer`实现了`ReadWriter`（有Read、Write，但没有Close）
- 函数签名只需要声明**最小的接口需求**，如只需要读取就用`io.Reader`参数

**组合优于继承**：Go没有类继承，接口组合提供了同样的抽象能力，但耦合度更低。


# 5 空接口与any

## 5.1 空接口

空接口`interface{}`不包含任何方法，因此**所有类型**都满足它：

```go
var anything interface{}
anything = 42
anything = "hello"
anything = []int{1, 2, 3}
anything = struct{ Name string }{"Go"}
```

标准库中大量使用空接口：`fmt.Println(a ...interface{})`、`json.Unmarshal`的结果等。

## 5.2 any别名（Go 1.18+）

Go 1.18引入了`any`作为`interface{}`的类型别名，两者完全等价：

```go
// 以下两种写法完全等价
func PrintAnything(v interface{}) { fmt.Println(v) }
func PrintAny(v any) { fmt.Println(v) }
```

推荐在新代码中使用`any`，更简洁。

## 5.3 空接口 vs 泛型

Go 1.18引入泛型后，很多原本使用空接口的场景可以用泛型替代：

```go
// 空接口方式：失去类型安全，需要断言
func MaxInterface(a, b interface{}) interface{} {
    // 需要反射或类型断言，运行时才能发现类型错误
}

// 泛型方式：编译期类型安全，无性能损失
func Max[T cmp.Ordered](a, b T) T {
    if a > b {
        return a
    }
    return b
}
```

**原则**：如果逻辑对所有类型都一样，用泛型；如果需要运行时判断类型做不同操作，用接口。


# 6 值接收者 vs 指针接收者

这是接口使用中最容易犯错的地方。规则如下：

| 实现方式 | 值能赋给接口？ | 指针能赋给接口？ |
|---------|--------------|----------------|
| 值接收者方法 | 能 | 能 |
| 指针接收者方法 | **不能** | 能 |

```go
type Speaker interface {
    Speak() string
}

type Dog struct{ Name string }

// 值接收者
func (d Dog) Speak() string { return d.Name + ": Woof!" }

type Cat struct{ Name string }

// 指针接收者
func (c *Cat) Speak() string { return c.Name + ": Meow!" }
```

```go
// Dog用值接收者实现，值和指针都可以
var s1 Speaker = Dog{Name: "Buddy"}   // OK
var s2 Speaker = &Dog{Name: "Buddy"}  // OK

// Cat用指针接收者实现，只有指针可以
// var s3 Speaker = Cat{Name: "Kitty"}  // 编译错误！
var s4 Speaker = &Cat{Name: "Kitty"}   // OK
```

**为什么值不能赋给指针接收者实现的接口？**

编译器可以对变量自动取地址（`&dog`），但**接口内部存储的值是不可寻址的**。
当一个值被存入接口后，它是接口的一个副本，无法获取原始变量的地址。
而指针接收者需要一个指针才能调用方法，因此编译器拒绝这种赋值。

**经验法则**：如果类型的任何方法使用了指针接收者，那么统一使用指针接收者，
并始终用指针赋值给接口。


# 7 nil接口 vs nil值的接口

这是Go中**最经典的陷阱**之一。一个接口值在且仅在**类型和值都为nil**时才等于nil：

```go
// 情况1：nil接口——类型和值都是nil
var w io.Writer          // w == nil -> true
fmt.Println(w == nil)    // true

// 情况2：非nil接口持有nil值——类型不是nil
var buf *bytes.Buffer    // buf是一个nil指针
w = buf                  // w的类型是*bytes.Buffer，值是nil
fmt.Println(w == nil)    // false！！！
```

从内存布局来看：

```
情况1：nil接口             情况2：非nil接口（持有nil值）
┌──────────┬──────────┐    ┌──────────┬──────────┐
│ tab=nil  │ data=nil │    │ tab!=nil │ data=nil │
└──────────┴──────────┘    └──────────┴──────────┘
                            tab指向*bytes.Buffer的itab
```

接口的`== nil`判断检查的是**tab（类型信息）是否为nil**，而不是data。
情况2中tab指向了`*bytes.Buffer`的类型信息，所以不等于nil。

**这个陷阱在实际代码中经常出现在错误返回中**（详见[trap/main.go](trap/main.go)）：

```go
// 危险：即使process返回nil error，返回值也可能不是nil接口
func doSomething() error {
    var err *MyError = nil
    // ... 某些逻辑 ...
    return err  // 返回的error接口不是nil！
}

// 安全：显式返回nil
func doSomething() error {
    var err *MyError
    // ... 某些逻辑 ...
    if err != nil {
        return err
    }
    return nil  // 显式返回nil
}
```


# 8 接口设计原则

## 8.1 接受接口，返回结构体

这是Go社区最核心的接口设计准则：

```go
// 好：参数用接口，返回用具体类型
func NewLogger(w io.Writer) *Logger {
    return &Logger{out: w}
}

// 不好：返回接口（除非确实有多种返回类型）
func NewLogger(w io.Writer) LoggerInterface {
    return &Logger{out: w}
}
```

**理由**：
- 返回结构体让调用者能访问所有方法和字段，不会被接口限制
- 参数用接口让调用者可以传入任何满足条件的实现
- 返回接口会隐藏实现细节，增加不必要的间接层

## 8.2 保持接口小

标准库的最佳实践——大多数接口只有1-3个方法：

```go
io.Reader      -> 1个方法 (Read)
io.Writer      -> 1个方法 (Write)
fmt.Stringer   -> 1个方法 (String)
error          -> 1个方法 (Error)
sort.Interface -> 3个方法 (Len, Less, Swap)
http.Handler   -> 1个方法 (ServeHTTP)
```

> "The bigger the interface, the weaker the abstraction."  -- Rob Pike

接口越大，能满足它的类型越少，它的抽象能力就越弱。

## 8.3 在消费侧定义接口

接口应该定义在**使用它的地方**，而非实现它的地方：

```go
// 好：在使用方定义最小化接口
// package userservice
type UserStore interface {
    GetByID(id string) (*User, error)
}

type Service struct {
    store UserStore
}

// 不好：在实现方定义大接口
// package database
type DatabaseInterface interface {
    GetByID(id string) (*User, error)
    Create(user *User) error
    Update(user *User) error
    Delete(id string) error
    ListAll() ([]*User, error)
    // ... 20个方法
}
```

使用方只需声明自己需要的方法子集，这样：
- 实现方不需要知道接口的存在
- mock更简单（只mock需要的方法）
- 多个使用方可以定义不同的接口子集

## 8.4 不要为了mock而创建接口

如果一个接口只有一个实现，它大概率是不必要的。先写具体实现，当真正出现第二个实现或者
测试确实需要mock时再抽象接口。


# 9 接口的工程实践

## 9.1 依赖注入

通过构造函数注入接口依赖，使代码可测试：

```go
type Notifier interface {
    Send(to, msg string) error
}

type OrderService struct {
    notifier Notifier
}

func NewOrderService(n Notifier) *OrderService {
    return &OrderService{notifier: n}
}

func (s *OrderService) PlaceOrder(userEmail string) error {
    // ... 创建订单逻辑 ...
    return s.notifier.Send(userEmail, "订单已创建")
}
```

测试时注入mock：

```go
type mockNotifier struct {
    called bool
    lastTo string
}

func (m *mockNotifier) Send(to, msg string) error {
    m.called = true
    m.lastTo = to
    return nil
}

func TestPlaceOrder(t *testing.T) {
    mock := &mockNotifier{}
    svc := NewOrderService(mock)
    err := svc.PlaceOrder("user@example.com")
    if err != nil {
        t.Fatal(err)
    }
    if !mock.called {
        t.Error("expected notifier to be called")
    }
}
```

## 9.2 装饰器模式

接口使得装饰器模式非常自然——用一个实现包装另一个实现：

```go
// 标准库中的装饰器
r := io.LimitReader(file, 1024)  // 限制只读1024字节
r = io.TeeReader(r, os.Stdout)   // 读取时同时写到stdout

// 自定义装饰器：给Writer加上自动计数
type CountingWriter struct {
    W     io.Writer
    Count int64
}

func (cw *CountingWriter) Write(p []byte) (int, error) {
    n, err := cw.W.Write(p)
    cw.Count += int64(n)
    return n, err
}
```

这正是net/http中间件的本质——每个中间件都是一个接收Handler返回Handler的装饰器。

## 9.3 sort.Interface经典范例

标准库`sort`包通过一个三方法接口实现了通用排序：

```go
type Interface interface {
    Len() int
    Less(i, j int) bool
    Swap(i, j int)
}
```

任何类型只要实现这三个方法就可以排序：

```go
type ByAge []Person

func (a ByAge) Len() int           { return len(a) }
func (a ByAge) Less(i, j int) bool { return a[i].Age < a[j].Age }
func (a ByAge) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

sort.Sort(ByAge(people))
```

注：Go 1.21+推荐使用泛型的`slices.SortFunc`，更简洁：

```go
slices.SortFunc(people, func(a, b Person) int {
    return cmp.Compare(a.Age, b.Age)
})
```


# 10 常见陷阱

## 10.1 nil值接口陷阱

详见第7节分析。完整示例在[trap/main.go](trap/main.go)中。

核心记忆点：**永远不要将具体类型的nil指针赋值给接口后返回**，而是显式`return nil`。

## 10.2 指针接收者赋值陷阱

详见第6节分析。如果你看到这样的编译错误：

```
cannot use Cat{} (value of type Cat) as Speaker value in variable declaration:
    Cat does not implement Speaker (method Speak has pointer receiver)
```

说明接口方法是用指针接收者实现的，你需要用`&Cat{}`而非`Cat{}`。

## 10.3 接口变量的比较陷阱

两个接口值可以用`==`比较，但如果底层具体类型**不可比较**（如slice、map、func），
比较会panic：

```go
var a, b interface{}
a = []int{1, 2}
b = []int{1, 2}
// fmt.Println(a == b)  // panic: runtime error: comparing uncomparable type []int
```

安全的做法是先用类型断言取出具体值，再用`reflect.DeepEqual`比较：

```go
fmt.Println(reflect.DeepEqual(a, b)) // true
```

## 10.4 JSON反序列化的float64陷阱

`encoding/json`将JSON数字反序列化到`interface{}`时，**统一使用`float64`**，而非int：

```go
var data interface{}
json.Unmarshal([]byte(`{"age": 25}`), &data)

m := data.(map[string]interface{})
age := m["age"]
fmt.Printf("%T = %v\n", age, age) // float64 = 25

// 如果直接断言为int会panic：
// n := age.(int) // panic!

// 正确做法：先断言为float64再转换
n := int(age.(float64)) // 25
```

如果需要精确的整数类型，使用`json.Decoder`并启用`UseNumber`：

```go
dec := json.NewDecoder(strings.NewReader(`{"age": 25}`))
dec.UseNumber()
var data interface{}
dec.Decode(&data)

m := data.(map[string]interface{})
age := m["age"].(json.Number)
n, _ := age.Int64() // 25
```


# 11 总结

| 规则 | 说明 |
|------|------|
| 隐式实现 | 实现方法即满足接口，无需声明 |
| 底层结构 | eface（空接口）和iface（非空接口）各16字节 |
| 接口组合 | 小接口嵌入组合成大接口，组合优于继承 |
| 值/指针接收者 | 指针接收者实现的接口，只有指针能赋值 |
| nil陷阱 | 接口nil判断检查的是类型信息，非nil类型+nil值!=nil接口 |
| 接受接口返回结构体 | 参数用接口保持灵活，返回用具体类型保持透明 |
| 保持接口小 | 1-3个方法最佳，接口越大抽象越弱 |
| 消费侧定义 | 在使用方定义接口，不在实现方 |
| 性能 | 接口调用比直接调用慢约1-2ns（itab查表），几乎可以忽略 |
| 空接口 vs 泛型 | 类型相同逻辑用泛型，运行时分派用接口 |
