
---
GMP模型
---

# 1 goroutine与线程
可增长的栈
OS线程（操作系统线程）一般都有固定的栈内存（通常为2MB）,一个goroutine的栈在其生命周期开始时只有很小的栈（典型情况下2KB），
goroutine的栈不是固定的，他可以按需增大和缩小，goroutine的栈大小限制可以达到1GB，虽然极少会用到这么大。所以在Go语言中
一次创建十万左右的goroutine也是可以的。

# 2 goroutine调度
GPM是Go语言运行时（runtime）层面的实现，是go语言自己实现的一套调度系统。区别于操作系统调度OS线程。
G很好理解，就是goroutine，里面除了存放本goroutine信息外，还有与所在P的绑定等信息。
P代表逻辑处理器（Logical Processor），用于调度 Goroutine 到 M 上运行。
P 维护一个本地的 Goroutine 队列，存储待执行的 Goroutine。
一个 M 必须绑定一个 P 才能执行 Goroutine。
Go 程序启动时，P 的数量由 GOMAXPROCS 决定，默认等于机器的 CPU 核心数。

P管理着一组goroutine队列，P里面会存储当前goroutine运行的上下文环境（函数指针，堆栈地址及地址边界），P会对自己管理的
goroutine队列做一些调度。
（比如把占用CPU时间较长的goroutine暂停、运行后续的goroutine等等）当自己的队列消费完了就去全局队列里取，如果全局队列里也
消费完了会去其他P的队列里抢任务(每次偷取一半)。
M（machine）是Go运行时（runtime）对操作系统内核线程的虚拟， M与内核线程一般是一一映射的关系， 一个goroutine最终是要放到
M上执行的；M 是 Goroutine 执行的载体，负责真正与操作系统交互。 
每个 M 绑定一个内核线程（Kernel Thread）。
M 负责运行绑定的 Goroutine，但一个 M 在某一时刻只能运行一个 Goroutine。
P与M一般也是一一对应的。他们关系是：P管理着一组G挂载在一个M上运行。当一个G长久阻塞在一个M上时，runtime会新建一个M，阻塞G所在
的P会把其他的G挂载在新建的M上。
当旧的G阻塞完成或者认为其已经死掉时回收旧的M。

# 3 GMP模型的运作
## 3.1 创建 Goroutine：
当创建一个新的 Goroutine 时（如通过 go func()），这个 Goroutine 会被添加到某个 P 的本地队列中。

## 3.2 调度循环：
调度器（Scheduler）会按照以下步骤工作：
从 P 的本地队列中取出一个 Goroutine，分配给绑定的 M 执行。
如果本地队列为空，P 会尝试从全局队列去取，如果全局队列也为空，会去其他 P 的队列中偷取 Goroutine（Work Stealing）。
如果找不到 Goroutine，M 会进入空闲状态。

### 3.2.1 M 和 P 的绑定：
M 在执行 Goroutine 时必须绑定一个 P。
如果 M 需要执行 Goroutine 而没有空闲的 P，会阻塞等待。

### 3.2.2 系统调用处理：
如果 Goroutine 执行了耗时的系统调用（如 I/O），M 会被阻塞。
为了避免整个 P 被阻塞：
调度器会分配一个新的 M 与 P 绑定，继续处理其他 Goroutine。
原来的 M 在系统调用完成后重新加入调度器。

### 3.2.3 Goroutine 的休眠与唤醒：
Goroutine 可能因为通道操作（chan）、锁等待、定时器（time.Sleep）等进入休眠状态。
调度器会将休眠的 Goroutine 暂存，直到其被唤醒后重新加入 P 的队列。

## 3.3 GMP 模型的特点
**轻量级 Goroutine**
相比线程，Goroutine 消耗的资源非常少。
Goroutine 的栈初始大小仅为 2KB，线程通常需要 1MB。

**动态扩展栈空间**
Goroutine 的栈可以根据需要动态扩展，最大支持到 1GB。

**Work Stealing（工作窃取)**
当一个 P 的任务队列为空时，它会尝试从其他 P 的任务队列中窃取任务，从而最大化 CPU 利用率。

**高效调度**
GMP 模型通过 P 来限制并发的 Goroutine 数量，避免了过多的线程切换。



# 4 GMP调度的优势
单从线程调度讲，Go语言相比起其他语言的优势在于OS线程是由OS内核来调度的，goroutine则是由Go运行时（runtime）自己的调度器
调度的，这个调度器使用一个称为m:n调度的技术（复用/调度m个goroutine到n个OS线程）。 其一大特点是goroutine的调度是在用户态
下完成的，不涉及内核态与用户态之间的频繁切换，包括内存的分配与释放，都是在用户态维护着一块大的内存池，不直接调用系统的
malloc函数（除非内存池需要改变），成本比调度OS线程低很多。
另一方面充分利用了多核的硬件资源，近似的把若干goroutine均分在物理线程上，再加上本身goroutine的超轻量，以上种种保证了
go调度方面的性能。

GOMAXPROCS
Go运行时的调度器使用GOMAXPROCS参数来确定需要使用多少个OS线程来同时执行Go代码。默认值是机器上的CPU核心数。例如在一个8核心的
机器上，调度器会把Go代码同时调度到8个OS线程上（GOMAXPROCS是m:n调度中的n）。
Go语言中可以通过runtime.GOMAXPROCS()函数设置当前程序并发时占用的CPU逻辑核心数。
Go1.5版本之前，默认使用的是单核心执行。Go1.5版本之后，默认使用全部的CPU逻辑核心数。

**m:n调度模型**

## 4.1  m:n 调度模型的工作原理
Goroutine 的创建：
用户代码可以通过 go 关键字创建 Goroutine，它们会被添加到某个 P 的任务队列。

Goroutine 的调度：
Goroutine 不直接与操作系统线程绑定，而是通过 P 和 M 的协作进行调度：
P（Processor）： 逻辑处理器，维护一个本地任务队列。
M（Machine）： 内核线程，负责实际运行 Goroutine。

映射关系：
每个 M 必须绑定一个 P 才能运行 Goroutine。
一个 P 可以将任务分配给多个 M，从而将 Goroutine 映射到多个线程上运行。
用户态切换：
Goroutine 的切换在用户态完成，避免了内核态的高开销。

## 4.2 m:n 调度的关键机制

### 4.2.1 Goroutine 的挂起与唤醒
当一个 Goroutine 因为 I/O 或系统调用阻塞时，M 会被阻塞。
调度器会分配一个新的 M 继续执行 P 上的其他 Goroutine，从而避免 P 被完全阻塞。

### 4.2.2 工作窃取（Work Stealing）
如果一个 P 的任务队列为空，它会尝试从其他 P 的任务队列中窃取任务，确保负载均衡。
全局队列（Global Queue）
除了每个 P 的本地队列，调度器还维护了一个全局队列。
如果所有 P 的任务队列都为空，P 会从全局队列中获取任务。

## 4.3 m:n 调度的优势
轻量级并发：
Goroutine 是用户态的执行单元，创建、销毁和切换的开销比操作系统线程小很多。

高效资源利用：
调度器动态分配 M 到 Goroutine，避免线程闲置，提高 CPU 使用率。

避免阻塞：
调度器通过分配新 M 处理阻塞 Goroutine，避免 P 被完全阻塞。

负载均衡：
通过工作窃取和全局队列，均衡了多个 P 的负载。


## 4.4 m:n 调度的局限性
锁竞争问题：
多个 P 同时访问全局队列可能引发锁竞争。

垃圾回收开销：
大量 Goroutine 存在时，垃圾回收的开销可能增大。

复杂性：
m:n 模型比 1:1 或 n:1 模型更复杂，调度器需要额外的逻辑来处理边界情况。


# 5 深入细节

## 5.1 go 关键字启动协程的过程

### 5.1.1 创建 Goroutine (G)

**分配 Goroutine 对象**
运行时调用 runtime.newproc 函数，为新协程分配一个 g 结构体实例（goroutine 的控制块）。

g 结构体包含：
栈信息（初始栈大小为 2KB，可动态增长）。
当前状态（初始为 _Grunnable）。
函数指针（指向用户定义的函数，如 func() {...}）。
上下文信息（如程序计数器 PC 和栈指针 SP）。

**初始化栈和上下文**
运行时为新 G 初始化一个小的栈空间（2KB），并将用户函数的入口地址和参数写入栈。
通过 runtime·gogo 设置执行上下文，确保 G 被调度时能正确跳转到用户代码。

**放入运行队列**
新创建的 G 被标记为 _Grunnable（可运行状态），并加入到一个运行队列（runqueue）中。

运行队列可以是：
本地运行队列：与当前 P 绑定的队列（优先）。
全局运行队列：如果本地队列满，则放入全局队列。



### 5.1.2 检查当前 P 的状态
Go 运行时通过 runtime.schedule 函数调度 G，而调度依赖于 P（逻辑处理器）。
每个 P 都有一个本地运行队列（最多存储 256 个 G），由 P.sched 管理。
当前线程（M）会检查与它绑定的 P 是否有空闲。如果 P 的本地队列不满，新 G 会直接加入其中。

### 5.1.3 调度器的介入
一旦 G 被放入运行队列，运行时调度器会决定如何执行它。这涉及以下步骤：

获取当前 P：
运行时从当前线程（M）获取绑定的 P。如果没有绑定，则尝试从全局 P 列表中获取一个空闲 P。

检查运行队列：
如果当前 P 的本地队列中有 G（包括刚加入的新 G），调度器会选择一个 G 执行。
如果本地队列为空，调度器会尝试从全局队列或其他 P 的队列中“窃取” G（工作窃取机制）。

绑定 G 到 M：
调度器将选中的 G 绑定到当前 M，更新 M 的 g0（调度栈）或直接切换到新 G 的栈。
通过 runtime.gogo 跳转到 G 的代码入口，开始执行用户函数。

### 5.1.4 线程管理 (M)
现有线程复用：
如果当前 M 已经存在且空闲，运行时直接使用它执行 G，无需创建新线程。

创建新线程：
如果所有 M 都在忙，且全局线程池（M 的数量受 runtime.GOMAXPROCS 和系统资源限制）未达到上限，运行时会调用
runtime.newm 创建一个新线程。
新线程启动后绑定一个 P，并从运行队列中取出 G 执行。

线程池管理：
Go 运行时维护一个线程池，空闲的 M 会被缓存，避免频繁创建和销毁线程。

### 5.1.5 GMP模型的协作
**G 的生命周期**
创建：通过 go 关键字创建，状态为 _Grunnable。
运行：被调度到 M，状态变为 _Grunning。
阻塞：遇到 I/O 或同步操作，状态变为 _Gwaiting，M 释放 P 去执行其他 G。
结束：函数返回，状态变为 _Gdead，G 被回收。

**P 的作用**
P 是调度的核心，决定了并发度（GOMAXPROCS）。
每个 P 维护一个本地队列，减少全局锁竞争。
P 通过工作窃取平衡负载。

**M 的管理**
M 是实际执行单元，与 P 动态绑定。
如果 G 阻塞（如系统调用），M 会解绑 P，运行时会为 P 分配新的 M。

## 5.2 Go 的 runtime 如何判断 G 在 M 上的阻塞时间是否太长，需要新创建 M 来调度？

当一个 G 在 M 上执行时，如果遇到阻塞操作（例如系统调用、I/O 或 channel 等待），Go 运行时需要确保系统不会因
单个 G 的阻塞而影响整体性能。以下是运行时判断 G 阻塞时间是否过长的机制：

**系统调用检测**  
当 G 进入系统调用时，runtime运行时会记录其进入时间。
如果系统调用长时间未返回（例如网络 I/O 等待），运行时会认为 G 处于阻塞状态。

**sysmon 监控线程**  
Go 运行时内部有一个独立的系统监控线程 sysmon，它定期检查所有 M 的状态。
如果一个 M 被某个 G 占用超过一定时间（通常为 10ms），sysmon 会认为该 M 处于“饥饿”状态。
此时，运行时触发“抢占式调度”：将 P 与当前 M 解绑，并创建一个新的 M 来绑定 P，继续执行 P 上的其他 G。

阻塞类型的不同处理  
短时阻塞：如短暂的文件读写，运行时可能让 M 等待 G 完成。
长时阻塞：如网络请求，运行时会通过 sysmon 检测并采取行动，避免 M 被长期占用。

**总结**
Go 运行时通过 sysmon 线程定期检查 M 的状态，并在系统调用超时时（通常 10ms）判断 G 的阻塞时间是否过长。
如果过长，运行时创建一个新的 M，解除 P 与原 M 的绑定，确保 P 上的其他 G 能够继续执行。


## 5.3 当 P 将剩余的 G 切换到新的 M 上运行时，原来阻塞的 G 还在 P 的本地队列里吗？如果不在，它去哪了？

**阻塞的 G 的去向**
G_block 不再留在 P 的本地队列。
当 G_block 因阻塞被移出运行状态时，它的状态变为 _Gwaiting（等待状态），并从 P 的本地队列中移除。
P 的本地队列只保留处于 _Grunnable（可运行）状态的 G。

G_block 具体去向  
系统调用阻塞：G_block 仍然与原 M 绑定，等待系统调用完成。原 M 会继续处理该系统调用，直到返回。
channel 或 mutex 等待：G_block 被挂起到对应的等待队列中。
例如：
在 channel 操作中，G_block 被加入 channel 的发送或接收队列。
在 mutex 等待中，G_block 被加入 mutex 的等待队列。

**总结**
原来阻塞的 G（G_block）不在 P 的本地队列中。
如果是系统调用阻塞，G_block 与原 M 绑定，等待系统调用结束。
如果是 channel 或 mutex 等待，G_block 被挂起到对应的等待队列，等待事件触发。

## 5.4 Go 的 runtime 如何得知某个 G 结束阻塞了，又如何唤醒它？
Go 运行时通过事件驱动机制判断 G 是否能结束阻塞，并唤醒它。以下是具体过程：

**判断 G 结束阻塞的方式**

1 系统调用结束  
当系统调用完成时，原 M 继续执行 G_block。
运行时无法主动预测系统调用何时结束，只能等待其返回。

2 channel 操作  
当 G 因 channel 等待而阻塞时，它被加入 channel 的等待队列。
一旦 channel 操作完成（例如发送方发送数据或接收方准备接收），运行时从等待队列中取出 G。

3 mutex 解锁  
当 G 因 mutex 等待而阻塞时，它被加入 mutex 的等待队列。
当 mutex 被解锁时，运行时从等待队列中唤醒一个 G。

timer 定时器  
如果 G 在等待定时器到期，运行时的 timerproc（定时器管理线程）会在时间到达时触发。
到期后，G 被标记为可运行状态。

**唤醒 G 的过程**

状态更新  
一旦阻塞条件解除（例如系统调用返回、channel 数据就绪、mutex 解锁），运行时将 G 的状态从 _Gwaiting 
变回 _Grunnable。

重新调度  
被唤醒的 G 被放回 P 的本地队列，如果本地队列已满，则放入或全局队列，等待调度器分配 M 执行。

**总结**

判断：  
系统调用依赖返回时机，其他情况（如 channel、mutex、timer）通过事件触发（数据就绪、解锁、时间到期）判断。

唤醒：  
运行时将 G 状态更新为 _Grunnable，并将其放入运行队列，等待调度。