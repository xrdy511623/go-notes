
---
defer详解
---
1 使用场景
由于defer语句延迟调用的特性，所以defer语句能非常方便的处理资源释放问题。比如：资源清理、文件关闭、解锁、
关闭连接及记录时间等。

2 defer执行的时机
在Go语言的函数中return语句在底层并不是原子操作，它分为给返回值赋值和RET指令两步。而defer语句执行的时机就在返回值
赋值操作后，RET指令执行前。
也就是:
返回值=x
执行defer语句
ret指令返回x

3 行为规则

3.1> 延迟函数的参数在defer语句出现时就已经确定了，譬如:
```golang
func a() {
	i := 0
	defer fmt.Printtln(i)
	i++
}
```

defer语句中的fmt.Printtln()参数i的值在defer出现时就已经确定了，实际上是复制了一份。之后对变量i的修改不会影响fmt.Printtln()
函数的执行，仍然打印0.
注意: 对于指针类型参数，此规则仍然适用，只不过延迟函数的参数是一个地址值，在这种情况下，defer后面的语句对变量的修改可能会影响
延迟函数。

3.2> 延迟函数按照后进先出的顺序执行，即先出现的defer最后执行。
defer语句采取后进先出的设计，类似于栈的方式，函数执行时，每遇到一个defer都会把一个函数压入栈中，函数返回前再将函数从栈中
取出执行，最早被压入栈中的函数最晚被执行。
不仅函数正常返回会执行被defer延迟的函数，函数中任意一个return语句、panic语句均会触发延迟函数。

设计defer的初衷是简化函数返回时资源清理的动作，资源往往有依赖顺序，比如先申请A资源，再根据A资源申请B资源，根据B资源申请
C资源，即申请顺序是A->B->C，释放时往往又要反向进行。这就是把defer设计成后进先出的原因。
每申请到一个用完需要释放的资源时，立即定义一个defer来释放资源是一个很好的习惯。

3.3> 延迟函数可能会操作主函数的具名返回值
定义defer的函数(下称主函数)可能有返回值，返回值可能有名字(具名返回值)，也可能没有名字(匿名返回值)，延迟函数可能会影响返回值。

a 主函数拥有匿名返回值，返回字面值。
一个主函数拥有一个匿名返回值，返回时使用字面值，比如返回1、2、Hello这样的值，这种情况下defer语句是无法操作返回值的。
譬如:

```golang
func foo() {
	var i int
	defer func() {
		i++
    }()  
	return 1
}
```

b 主函数拥有匿名返回值，返回变量
一个主函数拥有一个匿名返回值，返回本地或全局变量，这种情况下defer语句可以引用返回值，但不会改变返回值。
譬如:

```golang
func foo() {
	var i int
	defer func() {
		i++
    }()  
	return i
}
```
上面的函数返回一个局部变量，同时defer函数也会操作这个局部变量。对于匿名返回值来说，可以假定仍然有一个变量存储返回值，假定返回值变量
为anony，则上面的返回语句可以拆分为以下过程:
```shell
anony = i
i++
return anony
```
由于i是整数，会将值复制给anony，所以在defer语句中修改i值，不会对i的副本，也就是函数返回值anony造成影响。

c 主函数拥有具名返回值 
主函数声明语句中带名字的返回值会被初始化为一个局部变量，函数内可以像使用局部变量一样使用该返回值。如果defer语句操作该返回值，
则可能改变返回值。
譬如:
```golang
func foo() (ret int) {
	defer func() {
		ret++
    }()  
	return 0
```

则上面的返回语句可以拆分为以下过程:
```shell
ret = 0
ret++
return ret
所以最后返回1
```

小结：
未命名的返回值，defer中对返回值的操作指向不同的内存地址
命名且同名的返回值，defer中对返回值的操作指向相同的内存地址
