
---
init进程和信号
---

# 1 如何理解init进程
linux内核执行文件一般会放在/boot目录下，文件名类似vmlinuz*。在内核完成了操作系统的各种初始化之后，这个程序需要执行的第一个
用户态进程就是init进程。
系统启动的时候先是执行内核态的代码，然后在内核中调用1号进程的代码，从内核带切换到用户态。
目前主流的Linux发行版，都会把/sbin/init作为符号链接指向Systemd。Systemd是目前最流行的Linux Init进程，在它之前还有
SysVinit, UpStart等Linux Init进程。

**init进程的基本功能**
无论是哪种Linux init进程，它最基本的功能都是创建出 Linux系统中其他所有的进程，并且管理这些进程。

在Linux上有了容器的概念之后，一旦容器创建了自己的Pid Namespace(进程命名空间)，这个Namespace里的进程号也是从1开始标记的。
所以，容器的init进程也被称为1号进程。也就是说，1号进程是第一个用户态的进程，由它直接或者间接创建了Namespace中的的其他进程。

# 2 如何额理解Linux信号？
信号一般会从1开始编号，通常来说，信号编号是1到31.
用一句话来概括，信号其实就是Linux进程收到的一个通知。下面是几个典型的场景：
如果我们通过键盘按下Ctrl+C，当前运行的进程就会收到一个信号SIGINT(2号信号)而退出。
如果我们的代码写得有问题，导致内存访问出错了，当前的进程会收到另一个信号SIGSEGV。
我们也可以通过命令kill <pid>，直接向一个进程发送一个信号，缺省情况下不指定信号类型，那么这个信号就是SIGTERM(15号信号)。
也可以指定信号类型，譬如kill -9 <pid>，这里的9就是编号为9的信号，SIGKILL信号。

进程在收到信号后，就会去做相应的处理。进程一共有三个选择:
第一个选择是忽略(ignore)，就是对这个信号不做任何处理，但是有两个信号例外，那就是SIGKILL和SIGSTOP这两个信号，进程是
不能忽略的，因为它们的主要作用是为Linux内核和超级用户提供删除任意进程的特权。

第二个选择是捕获(Catch)，这个是指让用户进程可以注册自己针对这个信号的handler。

还有一个选择是缺省行为(Default)，Linux为每个信号都定义了一个缺省行为，我们可以使用man 7 signal来查看每个信号的缺省行为。

对于大部分的信号，应用程序或者说进程都不需要注册自己的handler，使用系统缺省定义行为就可以了。

**特权信号**

特权信号就是Linux为kernel(内核)和超级用户去删除任意进程所保留的，不能被忽略也不能被捕获。

在容器中，1号进程(或init进程)永远不会响应SIGKILL和SIGSTOP这两个特权信号，因为它们不能被捕获，不能被捕获意味着它们无法
定义自己的处理handler，只能使用缺省的Default handler，而Linux内核针对每个Namespace里的init进程，会把只有
default handler的信号都忽略掉。

对于其他信号，如果用户自己注册了handler,  1号进程可以响应。

捕获指的是我们在代码中为某个信号，调用signal()注册自己的handler。这样在进程运行的时候，一旦接收到信号，就不会再去执行内核中的缺省代码，而是会执行通过signal()注册的handler。
如果要让进程忽略一个信号，我们就要通过signal()这关系统调用，为这个信号注册一个特殊的handler，也就是SIG_IGN

**信号的两个系统调用**

进程对信号的处理其实就包括两个问题，一个是进程如何发送信号，另一个是进程收到信号后如何处理。
在Linux系统中发送信号的系统调用就是kill()，它内部的实现就是调用了kill这个函数。这个函数有两个参数，一个是sig，代表需要发送哪个信号，比如15表示发出SIGTREM；
另一个参数是pid，表示这个信号需要发送到哪个进程，比如1表示发送这个信号给进程号是1的进程。

怎么解决停止容器时，容器内应用程序被强制杀死的问题？
解决的办法就是在容器的init进程中对收到的信号做一个转发，发送到容器中的其他子进程，这样容器中的所有进程在停止时，都会收到SIGTERM信号，而非SIGKILL信号了。