
---
CPU的上下文切换
---

我们知道，多进程在竞争CPU时并没有真正运行，那么为什么还会导致系统负载升高呢？其实，罪魁祸首就是CPU的上下文切换。

# 1 什么是CPU上下文？
Linux是一个多任务操作系统，它支持远大于CPU数量的任务同时运行，当然，这些任务并不是真的在同时运行，只是因为系统在很短的
时间内，将CPU轮流分配给它们，造成多任务同时运行的错觉。
而在每个任务运行前，CPU都需要知道任务从哪里加载，又从哪里开始运行，也就是说，需要系统事先帮它设置好CPU寄存器和程序计数器。
CPU寄存器，是CPU内置的容量小，但速度极快的内存。而程序计数器，则是用来存储CPU正在执行的指令位置，或者即将执行的下一条指令位置。
它们都是CPU在运行任何任务前，所必须依赖的环境，因此也被叫做CPU上下文。

所以，CPU上下文切换，就是先把前一个任务的CPU上下文(也就是CPU寄存器和程序计数器)保存起来，然后加载新任务的上下文到这些寄存器
和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务。
而这些保存下来的上下文，会存储在系统内核中，并在任务重新调度执行时再次加载进来，这样就能保证任务原来的运行状态不受影响，让
任务看起来还是连续运行。

如此看来，CPU上下文切换无非是更新了CPU寄存器的值，但这些寄存器本身就是为了快速运行任务而设计的，为什么会影响系统的CPU性能呢？
根据任务的不同，CPU的上下文切换可以分为几个不同的场景，也就是进程上下文切换，线程上下文切换以及中断上下文切换。


# 2 进程上下文切换

Linux按照特权等级，把进程的运行空间划分为内核空间和用户空间。内核空间拥有最高权限，可以直接访问所有资源；用户空间只能访问受限资源，
不能直接访问内存等硬件设备，必须通过系统调用陷入到内核中，才能访问这些特权资源。

换个角度看，也就是说，进程既可以在用户空间运行，又可以在内核空间运行。进程在用户空间运行时，被称为进程的用户态，而陷入内核空间时，
被称为进程的内核态。从用户态到内核态的转变，需要通过系统调用来完成。比如，当我们查看文件内容时，就需要多次系统调用来完成；
首先调用open()打开文件，然后调用read()读取文件内容，并调用write()将内容写到标准输出，最后再调用close()关闭文件。

那么系统调用的过程中是否会发生CPU上下文的切换呢？答案是肯定的。
CPU寄存器里原来用户态的指令位置，需要先保存起来。接着，为了执行内核态代码，CPU寄存器需要更新为内核态指令的新位置。
最后才是跳转到内核态运行内核任务。

而系统调用结束后，CPU寄存器需要恢复原来保存的用户态，然后再切换到用户空间，继续运行进程。所以，一次系统调用的过程，其实
是发生了两次CPU上下文切换。

不过，需要注意的是，系统调用过程中，并不会涉及到虚拟内存等进程用户态的资源，也不会切换进程，这跟我们通常所说的进程上下文切换是不一样的:
进程上下文切换，是指从一个进程切换到另一个进程运行。
而系统调用过程中一直都是同一个进程在运行。

所以，系统调用过程通常称为特权模式切换，而非上下文切换。但实际上，系统调用过程中，CPU的上下文切换还是无法避免的。

那么，进程上下文切换与系统调用又有什么区别呢？

我们知道，进程是由内核来管理和调度的，进程的切换只能发生在内核态，所以，进程的上下文不仅包括了虚拟内存，栈，全局变量等用户空间的资源，
还包括了内核堆栈，寄存器等内核空间状态。
因此，进程的上下文切换就比系统调用时多了一步；在保存当前进程的内核态和CPU寄存器之前，需要先把该进程的虚拟内存，栈，全局变量等保存下来；
而加载了下一进程的内核态后，还需要刷新进程的虚拟内存和用户栈。而保存和恢复上下文的过程并不是免费的，需要内核在CPU上运行才能完成。

根据Tsuna的测试报告，每次上下文切换都需要耗费几十纳秒到数微秒的CPU时间，这个时间还是相当可观的，特别是在进程上下文切换比较频繁
的情况下，很容易导致CPU将大量时间耗费在CPU寄存器，内核堆栈以及虚拟内存等资源的保存和恢复上，进而大大缩短了真正运行进程的时间，
这也正是导致CPU平均负载升高的一个重要因素。

另外，Linux通过TLB来管理虚拟内存到物理内存的映射关系。当虚拟内存更新后，TLB也需要刷新，内存的访问也会随之变慢，特别是在多核
CPU处理器系统上，缓存是被多个处理器共享的，刷新缓存不仅会影响当前处理器的性能，还会影响共享缓存的其他处理器的进程。


## 2.1 进程上下文切换的场景

Linux为每个CPU都维护了一个就绪队列，将活跃进程(即正在运行和正在等待CPU的进程)按照优先级和等待CPU的时间排序，然后选择最
需要CPU的进程，也就是优先级最高和等待CPU时间最长的进程来运行。

最常见的进程切换场景是进程执行完终止了，它之前使用的CPU会释放出来，此时系统会从就绪队列里，拿一个新的进程过来运行。当然还有
很多其他场景，如下所列：

其一，为了保证所有进程可以得到公平调度，CPU时间被划分为一段段时间片，这些时间片再被轮流分配给各个进程。这样，当某个进程的
时间片耗尽了，就会被系统挂起，切换到其他正在等待CPU的进程运行。

其二，进程在系统资源不足(比如内存不足)时，要等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其他进程运行。

其三，当进程通过睡眠函数sleep这样的方法将自己主动挂起时，自然也会重新调度。

其四，当有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由系统调度高优先级的进程来运行。

最后，发生硬件中断时，CPU上的进程会被中断挂起，转而执行内核中的中断服务程序。


## 2.2 线程上下文切换
进程和线程最大的区别在于，线程是调度或者说CPU执行的基本单位，而进程这是操作系统分配资源的基本单位。说白了，所谓内核中的任务调度，实际上的调度对象是线程；而进程只是给线程提供了虚拟内存，全局变量等资源。所以，对于进程和线程，我们可以这样理解:
当进程只有一个线程时，可以认为进程就等于线程。
当进程拥有多个线程时，这些线程会共享相同的虚拟内存和全局变量等资源，这些资源在线程上下文切换时是不需要修改的。
另外，线程也有自己的私有数据，比如栈和寄存器等，这些在上下文切换时也是需要保存的。

如此，线程的上下文切换其实可以分为两种情况:
第一种，前后两个线程属于不同的进程。此时，因为资源不共享，所以切换过程就跟进程上下文切换是一样的。
第二种，前后两个线程属于同一个进程。此时，因为虚拟内存，全局变量是共享的，所以切换时，虚拟内存，
全局变量这些资源就保持不动，只需要切换线程的私有数据，寄存器等不共享的数据。

所以，虽然都是上下文切换，但同进程内的线程切换，要比多进程间的切换消耗更少的资源，这正是多线程代替多进程的一个优势。


## 2.3 中断上下文切换
为了快速响应硬件的事件，中断处理会打断进程的正常调度和执行，转而调用中断处理程序，响应设备事件。而在打断其他进程时，
就需要将进程当前的状态保存下来，这样在中断结束后，进程仍然可以从原来的状态恢复运行。
跟进程上下文不同，中断上下文切换并不涉及到进程的用户态。所以，即便中断过程打断了一个正处于用户态的进程，也不需要保存
和恢复这个进程的虚拟内存，用户栈，全局变量等用户态资源。中断上下文，其实只包括内核态中断服务程序执行所必需的状态，
包括CPU寄存器，内核堆栈，硬件中断参数等。
对同一个CPU来说，中断处理比进程拥有更高的优先级，所以中断上下文切换并不会与进程上下文切换同时发生。同样道理，由于中断
会打断正常进程的调度和执行，所以大部分中断处理程序都短小精悍，以便尽可能快地执行结束。
另外，跟进程上下文切换一样，中断上下文切换也需要消耗CPU，切换次数过多也会耗费大量CPU，甚至严重降低系统的整体性能。所以，
当中断次数过多时，就需要注意去排查它是否会给系统带来严重的性能问题。


# 3 如何查看系统的上下文切换情况？
vmstat是一个常用的系统性能分析工具，主要用来分析系统的内存使用情况，也常用于分析CPU上下文切换和中断次数。

比如，下面就是一个vmstat的使用示例:





![vmstat.png](images%2Fvmstat.png)





cs(context switch)是每秒上下文切换的次数。
in(interrupt)则是每秒中断的次数。
r(running or runnable)是就绪队列的长度，也就是正在运行和等待CPU的进程数。
b(blocked)则是处于不可中断睡眠状态的进程数。

vmstat只给出了系统总体的上下文切换情况，要想查看每个进程的详细情况，就需要使用pidstat了，给它加上-w选项，
便可查看每个进程上下文切换的情况了。





![pidstat-w.png](images%2Fpidstat-w.png)




## 3.1 自愿上下文切换和非自愿上下文切换 

这个结果中有两列内容是我们的重点关注对象。一个是cswch，表示每秒自愿上下文切换(voluntary context switches)的次数，
另一个则是nvcswch，表示每秒非自愿上下文切换(non voluntary context switches)的次数。
这两个概念意味着不同的性能问题:
自愿上下文切换，是指进程无法获取所需资源，导致的上下文切换。比如说，I/O，内存等系统资源不足时，就会发生自愿上下文切换。
而非自愿上下文切换，则是指进程由于时间片已到等原因，被系统强制调度，进而发生的上下文切换。比如，大量进程都在争抢CPU时，
就容易发生非自愿上下文切换。


## 3.2 如何查看中断上下文切换情况？

我们知道，中断只发生在内核态，而pidstat只是一个进程的性能分析工具，并不提供任何关于中断的详细信息，如何才能知道中断发生的类型呢？
这个其实可以从/proc/interrupts这个只读文件中读取。/proc实际上是Linux的一个虚拟文件系统，用于内核空间与用户空间之间的通信。
/proc/interrupts就是这种通信机制的一部分，提供了一个只读的中断使用情况。

我们可以运行以下命令，观察中断的变化情况:

```shell
watch -d cat /proc/interrupts
```





![proc-interrupt.png](images%2Fproc-interrupt.png)





观察一段时间，如果你发现变化速度最快的是重调度中断(RES)，这个中断类型表示，唤醒空闲状态的CPU来调度新的任务运行。这是多处理器
系统(SMP)中，调度器用来分散任务到不同CPU的机制，通常也被称为处理器间中断，这种中断升高还是因为过多任务的调度问题。


## 3.3 每秒上下文切换多少次才算正常？

这个数值其实取决于系统本身的CPU性能。如果系统的上下文切换次数比较稳定，那么从数百到一万以内，都应该算是正常的。但当上下文切换次数
超过一万次，或者切换次数出现数量级的增长时，就很可能已经出现了性能问题。

此时，我们就需要根据上下文切换的具体类型，再做具体分析：
自愿上下文切换变多了，说明进程都在等待资源，有可能发生了I/O等其他问题；
非自愿上下文切换变多了，说明进程都在被强制调度，也就是都在争抢CPU，说明CPU的确成了瓶颈。
中断次数变多了，说明CPU被中断处理程序占用，还需要通过查看/proc/interrupts文件来分析具体的中断类型。