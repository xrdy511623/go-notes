
---
如何理解Linux软中断
---

# 1 软中断和硬中断

中断是系统用来响应硬件设备请求的一种机制，它会打断进程的正常调度和执行，然后调用内核中的中断处理程序来响应设备的请求。
为了解决中断处理程序执行过长和中断丢失的问题，Linux将中断处理过程分成了两个阶段，也就是上半部和下半部；
上半部用来快速处理中断，它在中断禁止模式下运行，主要处理跟硬件紧密相关敏感的工作。
下半部用来延迟处理上半部未完成的工作，通常以内核线程的方式运行。

下面以网卡接收数据包为例，讲讲硬中断和软中断。
网卡接收到数据包后，会通过硬件中断的方式，通知内核有新的数据到了。这时，内核就应该调用中断处理程序来响应它。对上半部来说，
需要快速处理，那就把网卡的数据读到内存中，然后更新一下硬件寄存器的状态(表示数据已经读好了)，然后再发送一个软中断信号，通知下半部做进一步的处理。
而下半部被软中断信号唤醒后，需要从内存中找到网络数据，再按照网络协议栈，对数据进行逐层解析处理，直到把它传递给应用程序。
所以，这两个阶段可以这样理解：
上半部直接处理硬件请求，也就是硬中断，特点是快速执行；
而下半部则是由内核触发，也就是软中断，特点是延迟执行。

实际上，上半部会打断CPU正在执行的任务，然后立即执行中断处理程序。而下半部以内核线程的方式执行，并且每个CPU都对应一个软中断内核线程，
名字为ksoftirqd/CPU编号，譬如，0号CPU对应的软中断内核线程的名字就是ksoftirqd/0。

不过需要注意的是，软中断不仅包括硬件设备中断处理程序的下半部，一些内核自定义事件也属于软中断，比如内核调度和RCU锁
(Read-Copy Update的缩写，是Linux内核中最常用的锁之一)。

# 2 查看软中断和内核线程

我们知道，proc文件系统是一种在内核空间和用户空间进行通信的机制，可以用来查看内核的数据结构，或者用来动态修改内核的配置。其中：
/proc/softirqs  提供了软中断的运行情况；
/proc/interrupts 提供了硬中断的运行情况。

运行以下命令，查看/proc/softirqs文件的内容，就可以看到各种类型软中断在不同CPU上的累计运行次数：

```shell
cat /proc/softirqs
```





![soft-irq.png](images%2Fsoft-irq.png)





在查看 /proc/softirqs 文件内容时，需要特别注意以下两点:
第一，要注意软中断的类型，也就是上图中第一列的内容。从第一列可以看到，软中断包括了10个类别，分别对应不同的工作类型。
比如NET_RX表示网络接收中断，而NET_TX表示网络发送中断。

第二，要注意同一软中断在不同CPU上的分布情况，也就是同一行的内容。正常情况下，同一种中断在不同CPU上的累积次数应该差不多。
比如，上图中，NET_TX在CPU2和CPU3上的中断次数基本上是同一个数量级，相差不大。

但是，TASKLET在不同CPU上的分布并不均匀。TASKLET是最常用的软中断实现机制。每个TASKLET只运行一次就会结束，
并且只在调用它的函数所在的CPU上运行。因此，使用TASKLET特别简单，但也存在一些问题，比如说由于只在一个CPU上
运行导致的调度不均衡，再比如因为不能在多个CPU上并行运行带来了性能限制。

下面的命令可以查看每个CPU的软中断内核线程：

```shell
ps aux | grep softirq
```




![grep-soft-irq.png](images%2Fgrep-soft-irq.png)





# 3 总结

Linux中的中断处理程序分为上半部和下半部:
上半部对应硬件中断，用来快速处理中断；
下半部对应软中断，用来异步处理上半部未完成的工作。

Linux中的软中断包括网络收发、定时、调度、RCU锁等各种类型，可以通过查看 /proc/softirqs来观察软中断的运行情况。