
---
Linux内存是如何工作的？
---

# 1 内存映射

大多数计算机的主存都是动态随机访问内存(DRAM)，只有内核才可以直接访问物理内存。那么，进程要访问内存时，该怎么办呢？

Linux内核给每个进程都提供了一个独立的虚拟地址空间，并且这个地址空间是连续的。这样，进程就可以很方便的访问内存，更确切地说是访问虚拟内存。

进程在用户态时，只能访问用户空间内存；只有进入内核态后，才能访问内核空间内存。虽然每个进程的地址空间都包含了内核空间，但这些
内核空间，其实关联的都是相同的物理内存。这样，进程切换到内核态后，就可以很方便地访问内核空间内存。

注意，并不是所有的虚拟内存都会分配物理内存，只有那些实际使用的虚拟内存才会分配物理内存，并且分配后的物理内存，是通过内存映射管理的。

内存映射，其实就是将虚拟内存地址映射到物理内存地址，为了完成内存映射，内核为每个进程都维护了一张页表，记录虚拟地址与物理地址的映射关系。

页表实际上存储在CPU的内存管理单元MMU中，这样，正常情况下，处理器就可以直接通过硬件，找出要访问的内存。

而当进程要访问的虚拟地址在页表中查不到时，系统会产生一个缺页异常，进入内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行。

另外，TLB(Translation Lookaside Buffer，后备缓冲器)会影响CPU的内存访问性能。因为TLB其实就是MMU中页表的高速缓存。由于进程的
虚拟地址空间是相互独立的，而TLB的访问速度又比MMU快得多，所以，通过减少进程的上下文切换，减少TLB的刷新次数，就可以提高TLB缓存的
使用率，进而提高CPU的内存访问性能。

MMU并不是以字节为单位来管理内存，而是规定了一个内存映射的最小单位，也就是页，通常是4kb大小。这样，每一次内存映射，都需要关联4kb或者4kb整数倍的内存空间。
页的大小只有4kb，带来的一个问题是，整个页表会变得非常大。比方说，仅32位系统就需要100多万个页表项(4GB/4kb)，才可以实现整个地址空间的映射。为了解决
页表项过多的问题，Linux提供了两种机制，那就是多级页表和大页。

多级页表就是把内存分成区块来管理，将原来的映射关系改成区块索引和区块内的偏移。由于虚拟内存空间通常只用了很少一部分，那么，多级页表就只保存这些使用中的区块，
这样就可以大大减少页表的项数。

Linux用的是四级页表来管理内存页，虚拟地址被分为5个部分，前4个表项用于选择页，而最后一个索引表示页内偏移。
而大页，顾名思义，就是比普通页更大的内存块，常见的大小有2MB和1GB。大页通常用在使用大量内存的进程上，比如Oracle，DPDK等。


# 2 虚拟内存空间分布

用户空间内存，从低到高分别是五种不同的内存段。

1  只读段，包括代码和常量等。
2  数据段，包括全局变量等
3  堆，包括动态分配的内存，从低地址开始向上增长。
4  文件映射段，包括动态库、共享内存等，从高地址开始向下增长。
5 栈，包括局部变量和函数调用的上下文等。栈的大小是固定的，一般是8MB。

在以上五个内存段中，堆和文件映射段的内存是动态分配的。


# 3 内存分配与回收
malloc() 是C标准库提供的内存分配函数，对应的系统调用上，有两种实现方式，即brk()和mmap()。
对小块内存(小于128K)，C标准库使用brk()来分配，也就是通过移动堆顶的位置来分配内存。这些内存释放后并不会立即归还系统，而是被
缓存起来，这样就可以重复使用。

而大块内存(大于128K)，则直接使用内存映射mmap()来分配，也就是在文件映射段找一块空闲内存分配出去。

brk()方式的缓存，可以减少缺页异常的发生，提高内存访问的效率。不过，由于这些内存没有归还系统，在内存工作繁忙时，频繁的内存分配
和释放会造成内存碎片。

而mmap()方式分配的内存，会在释放时直接归还系统，所以每次mmap都会发生缺页异常。在内存工作繁忙时，频繁的内存分配会导致大量的
缺页异常，使内核的管理负担增大。这也是malloc()只对大块内存使用mmap的原因。

需要注意的是，这两种调用发生后，其实并没有真正分配内存。这些内存，都只在首次访问时才分配，也就是通过缺页异常进入内核中，再由内核来分配内存。

在内核空间，Linux通过slab分配器来管理小内存。我们可以把它看成构建在伙伴系统上的一个缓存，主要作用是分配并释放内核中的小对象。
对内存来说，如果只分配而不释放，就会造成内存泄露，甚至会耗尽系统内存。所以，在应用程序用完内存后，还需要调用free()或unmap()，
来释放这些不用的内存。


## 3.1 内存释放

系统不会任由某个进程用完所有内存。在发现内存紧张时，系统就会通过一系列机制来回收内存，主要是以下三种方式:

回收缓存，比如使用LRU算法，回收最近最少使用的内存页面；
回收不常访问的内存，把不常用的内存通过交换分区直接写到磁盘中；
杀死进程，内存紧张时系统还会通过OOM(Out Of Memory)，直接杀掉占用大量内存的进程。

其中，第二种方式回收不常访问的内存时，会用到交换分区(以下简称Swap)。Swap其实就是把一块磁盘空间当成内存来使用。它可以把进程
暂时不用的数据存储到磁盘中(这个过程称为换出)，当进程需要访问这些内存时，再从磁盘读取这些数据到内存中(这个过程称为换入)。

所以，我们可以看到，Sawp把系统的可用内存变大了。不过要注意，通常只有在内存不足时，才会发生Swap交换。并且由于磁盘读写的速度
远比内存慢，Swap会导致严重的内存性能问题。

第三种方式提到的OOM，其实是内核的一种保护机制。它会监控进程的内存使用情况，并且使用oom_score为每个进程的内存使用情况进行评分:
一个进程消耗的内存越大，oom_score就越大；
一个进程运行占用的CPU越多，oom_score就越小。

这样，进程的oom_score越大，代表消耗的内存越多，也就越容易被OOM杀死，从而可以更好地保护系统。


# 4 如何查看内存使用情况

free工具的输出如下所示:





![free.png](images%2Ffree.png)





可以看到，free输出的是一个表格，其中的数值默认都以字节为单位。表格总共有两行六列，这两行分别是物理内存Mem和交换分区Swap的
使用情况，而六列中，每列数据的含义分别为:

第一列，total是总内存大小；
第二列，used是已使用内存的大小，包含共享内存；
第三列，free是未使用内存大小；
第四列，shared是共享内存大小；
第五列，buff/cache是缓冲/缓存区大小；
第六列，available是新进程可用内存大小；

注意，最后一列的可用内存available不仅包含未使用内存，还包括可回收缓存，所以一般会比未使用内存更大。不过，并不是所有缓存
都可以回收，因为有些缓存可能正在使用中。

free显示的是整个系统的内存使用情况。如果想查看进程的内存使用情况，可以用top或ps等工具(按下M切换到内存排序)。





![top-mem.png](images%2Ftop-mem.png)





top输出界面的顶端，也显示了系统整体的内存使用情况，这些数据与free类似。下面看看与内存相关的几列数据。

VIRT是进程虚拟内存的大小，只要是进程申请过的内存，即便还没有真正分配物理内存，也会计算在内。
RES是常驻内存的大小，也就是进程实际使用的物理内存大小，但不包括Swap和共享内存。
SHR是共享内存的大小，比如与其他进程共同使用的共享内存、加载的动态链接库以及程序的代码段。
%MEM 是进程使用的物理内存占系统总内存的百分比。


# 5 总结

对普通进程来说，它能看到的其实是内核提供的虚拟内存，这些虚拟内存还需要通过页表，由系统映射为物理内存。

当进程通过malloc()申请内存后，内存并不会立即分配，而是在首次访问时，才通过缺页异常陷入内核中分配内存。

由于进程的虚拟地址空间比物理内存大很多，Linux还提供了一系列机制，应对内存不足的问题，比如，缓存的回收、
交换分区Swap以及OOM等。