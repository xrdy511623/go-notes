
---
title: 如何写好技术文档
version: v2.0
status: active
owner: john.q
last_updated: 2026-02-10
---

# 1 写作前

## 1.1 了解读者
了解目标读者实际的需求，定位写作目标，避免自嗨式写作。

### 1.1.1 为何要了解读者？

> 保证文档可读性；
> 让读者能理解文档；
> 完成任务。

### 1.1.2 如何了解读者？

#### 1.1.2.1 明确读者身份: 小白用户 or 资深用户？运维人员 or 开发人员？
#### 1.1.2.2 明确读者阅读目的: 了解一个概念、完成一个步骤，还是查阅一个参数解释？
#### 1.1.2.3 明确读者所需信息: 根据读者的认知能力提供所需信息(消除信息差)。

#### 1.1.2.4 抹平信息差(狭义):作者和读者之间的认知差异。

常见的信息差来源有:
**专业术语**
譬如CPU负载过高； 
算法时间复杂度过高；
缓存雪崩；

对于这些专业术语，非专业人士可能难以理解，我们在使用标准术语的同时，对于同一个意思尽量用一个表达，同时通过术语的
悬浮提示或百科功能提供术语解释帮助非专业人士理解，以消除这种信息差。

**相似物**
一个产品提供了两个相似的功能，文档需要帮助读者辨析，方便其作出选择。






![similarity.png](images%2Fsimilarity.png)






**新事物**
所有新出现的事物都需要充分解释其来源。

#### 1.1.2.5 主动走进读者
> 邀请同事评审；
> 把身边同学作为目标受众，获得反馈意见。

> 读者访谈；
与读者约一次访谈，了解他们对文档的期待、建议和意见。

> 文档支持群。
建立文档支持群，收集第一手的文档问题。这是一个长期、可靠、优质的渠道，通过该途径可以收集到许多鲜活的、高价值的
文档反馈。

> 时常问自己:

**读者从哪里来？**
背景是什么？读者遇到了什么困难，要完成什么任务？读者最开始是什么状态？他们此时在做什么？手边有哪些资源？

**读者在哪？**
读者此时所处状态? 比如，此时在哪个文件夹下？读者怎么确认他们处于文档里说的这个状态？比如执行某个命令，应该返回什么
结果？

**读者到哪里去？**
为什么要告诉读者这些信息？对他们有什么用？下一步要做什么？

**问题案例**:
Error: 视频数据包不完整，主要发生在上下麦瞬间，packet不完整会引起花屏。

| 问题点       | 解释                                                        | 问题类型 |
| 主要发生     | 缺少主语，尽管可以通过上下文推测出主语，但给读者徒增了理解负担       |  写作问题  |
| 上下麦       | 缺少主语。谁在上下麦？                                         | 缺乏对新事物的解释 |
| packet      | 术语使用不统一，中英夹杂。数据包和packet在这里指的是同一个东西      | 术语不统一 |
| 引起花屏     | 没有交代哪里会出现花屏                                         | 缺乏对新事物的解释 |

改造后:
Error: 视频数据包不完整，**该错误**主要发生在**主播端**上下麦的瞬间。**数据包**不完整会造成**接收端**出现花屏。


# 2 写作中

## 2.1 结构化写作
学习谋篇布局，搭建清晰的文档框架，体现内容之间的联系。
强调整体性，以简驭繁；有序地传递信息。

### 2.1.1 何为结构化写作？
理解信息之间的逻辑关系；
把无序信息排列为有序信息；
创造逻辑且顺畅的信息流；
有逻辑有条理地提炼和组织内容。

### 2.1.2 为何要结构化写作？
为作者理清写作思路:
帮助作者在清晰分类的基础上全面考虑问题，找到写作的方向和重点。

为读者降低阅读成本:
帮助读者快速锁定目标信息，获取重点信息和核心观点。

### 2.1.3 如何结构化写作？
结构化写作三步走:
**搭建文档框架**
纵向: 
论:结论先行。开门见山，把核心观点或中心思想放在文章开头的位置，让读者一目了然。
证:以上统下。上层结论是概括总结，然后通过下层信息进行具体解释和说明。

横向:
类: 归类分组。 把相关联的信息按照一定的标准进行划分归类，归为同一个逻辑范畴。
比: 逻辑递进。 按逻辑顺序递进排列素材。

**填充必要信息**





![fill-necessary-info.png](images%2Ffill-necessary-info.png)





**巧用结构化呈现**
无序列表: 没有特定顺序的列表，各个列表项之间属于并列关系；
有序列表: 强调排列顺序的列表，各个列表项之间属于先后关系；
表格: 一种可视化交流模式，也是一种组织整理内容的手段，主要用来罗列和对比信息。

**问题案例**:
应用上线某商店(**结构化前**)
应用上线标准
内容上线应用商店，无论使用消费者设备还是企业设备都需要先签订协议。
请勾选应用发布的设备型号。C端开发者在创建应用时，建议勾选系列设备下的全部型号；企业开发者在创建应用时，请选择对应
企业设备版本(目前在售的企业版本设备包括Neo3 Pro、Neo 3 Eye、G2 4KS)。
通过测试后，应用方可上线。

其他说明
如应用未能成功上线应用商店，请参照如上应用上线应用商店流程图查看卡点环节并与对应人员沟通详细情况。可能存在的卡点环节
及联系渠道如下:
未通过开发者申请或注册审核长时间未反馈: 请联系对应商务接口人沟通详细原因:
应用长时间未测试：请先确认是否已经签订协议，如已经签订协议，请联系对应运营接口人，沟通详细原因；
如未签订协议，请联系对应商务接口人进行协议签订；
应用未通过测试，请联系对应运营接口人沟通详细原因；
应用通过测试但长时间未上线应用商店，请联系对应运营接口人，沟通详细原因；
有关应用上线应用商店的质量标准，请联系对应运营接口人，沟通具体事宜。

![document-framework.png](images%2Fdocument-framework.png)

应用上线某商店(**结构化后**)
本文介绍了应用上线某应用商店的必要条件，潜在卡点以及解决卡点的对接人。

**必要条件**
* 创建应用时，你需要为应用选择匹配的设备型号。
    个人应用: 建议选择全部型号；
    企业应用: 选择企业版，包括Neo3 Pro、Neo 3 Eye、G2 4KS。
* 签署上线协议: 所有上线的应用均需要签署协议。
* 通过上线测试: 测试成功后，应用即可上线。

**潜在卡点**
参照应用上线某应用商店的流程确定潜在卡点。潜在卡点及联系渠道如下表所示。对接人联系方式见对接人联系方式表格。

卡点                              联系人员
* 开发者账号注册未通过。             商务对接人
* 注册审核长时间未反馈。 

* 应用未通过测试。                 运营对接人
* 应用通过测试但长时间未上线。

* 应用长时间未测试             请先确认你是否签订协议:
                            * 若是，请联系运营对接人；
                            * 若否，请联系商务对接人。 



## 2.2 写好标题
巧用SPA原则，写出精简准确的文档标题。

### 2.2.1 何为标题？
标题: 指明文档内容的概括性语句
总标题: 文章核心内容的体现；
副标题: 对总标题加以补充和解说；
分标题: 文档内的分级标题，能清晰地显示文章的层次。

### 2.2.2 为何要写好标题？
可提升浏览量，更容易被引用。
帮助读者快速了解文档的主要内容。

### 2.2.3 如何写好标题?
SPA法则:
Simple: 简明扼要；
Profit: 利益相关；
Accurate: 准确客观

文档类型            描述                                               示例
概念型       介绍某一个概念，内容可以是介绍背景、原理以及优劣势等。  名词+名词，如《A概述》、《A背景》、《A原理》等

任务型    指导完成某项具体的任务，内容通常包括业务背景、前置条件、操作步骤、 名词+动词或动词+名词，如《A工具的安装》，
         验证结果以及注意事项等。                                     《部署A环境》等。

参考型   罗列参考信息，比如产品的型号参数、API参数以及配置参数等。    名词+名词，如《机器配置的要求》等。

## 2.3 极简写作

**学习如何用精简有力的语言来传递内容**

### 2.3.1 何为极简写作？
用最精炼的语言概括最有价值的信息；
简化读者理解信息的成本。

### 2.3.2 为什么要极简写作？
节省时间；
易于理解；
减少成本。

### 2.3.3 如何极简写作？
保持前后一致:
最简单，最易忽略。





![consistency.png](images%2Fconsistency.png)





![consistency-demo.png](images%2Fconsistency-demo.png)





避免啰嗦:
简化效果最直观，需要在长期写作训练中习得。
啰嗦的原因: 口语化表达；叙事反复。
![solve-long-winded.png](images%2Fsolve-long-winded.png)

提供路标和索引:
方式多样

![landmark-and-index.png](images%2Flandmark-and-index.png)


# 3 写作后

## 3.1 检查文档
360度全方位检查文档内容，持续提升文档质量。

### 3.1.1 何为检查文档？
对文档的**体检**
**写作**
以创作者的视角表达和呈现信息。
**检查**
以**批判者**视角审视已经写好的内容。

### 3.1.2 如何检查文档？
**主题**
主题是否明确且聚焦，且符合目标读者的需求？
内容是否过于发散，是否跑题？

**结构**
内容是否遵照一定逻辑顺序？
是否符合结构化写作原则: 结论先行、以上统下、归类分组、逻辑递进？

**标题**
是否符合SPA原则(简明扼要、利益相关、准确客观)？

**内容**
文字表述是否简单清晰，不拖泥带水？

为了达到更好的检查效果，一般建议在写完文档后，冷却一段时间后再进行自查。这样做的好处是，冷却可以帮助你用全新的视角
来看待自己的内容，不会陷在自我欣赏的怪圈里。


# 4 一页式技术文档模板（可直接复用）

下面这份模板适用于大多数“要让别人做成一件事”的技术文档。建议新文档默认从此模板创建。

````markdown
# <文档标题：动词+对象，例如《部署 XXX 服务》>

## 1. 目标与范围
- 目标读者：<开发/测试/运维/值班同学>
- 解决问题：<一句话说明这篇文档解决什么问题>
- 适用范围：<系统/版本/环境>
- 不适用范围：<明确边界，避免误用>

## 2. 前置条件
- 权限要求：<账号权限、角色>
- 环境要求：<OS、Go/MySQL/Redis 版本>
- 依赖准备：<配置、密钥、网络、工具>
- 输入材料：<需要提前准备的文件/参数>

## 3. 操作步骤
### 3.1 步骤一：<名称>
- 目的：<为什么做这一步>
- 命令：
```bash
<可复制命令>
```
- 预期输出（成功判定）：
```text
<关键输出或状态>
```
- 常见失败与处理：<失败现象 + 对应动作>

### 3.2 步骤二：<名称>
...（同上）

## 4. 验证与回滚
- 验证命令：
```bash
<验证命令>
```
- 验证通过标准：<可量化标准>
- 回滚条件：<什么情况下必须回滚>
- 回滚步骤：
```bash
<回滚命令>
```

## 5. 故障排查（FAQ）
- Q1：<现象>
  - 原因：
  - 处理：

## 6. 元信息
- Owner：<负责人>
- Reviewer：<评审人>
- 创建时间：<YYYY-MM-DD>
- 最近更新时间：<YYYY-MM-DD>
- 变更记录：<链接或列表>
````

最小要求：任何“任务型文档”都应至少包含“前置条件、步骤、预期输出、验证、回滚”5项。


# 5 文档类型与结构模板（概念 / 任务 / 参考）

## 5.1 概念型文档模板

适合回答“是什么、为什么、何时用”。

建议结构：
1. 定义（一句话）
2. 背景与问题
3. 核心原理（配图可选）
4. 适用场景与不适用场景
5. 方案对比（优缺点、成本、风险）
6. 最小示例（可运行或可推演）
7. 常见误区
8. 延伸阅读

## 5.2 任务型文档模板

适合回答“怎么做、怎么验证、失败怎么办”。

建议结构：
1. 目标与完成标准
2. 前置条件
3. 分步骤操作（每步附命令与预期输出）
4. 验证方法
5. 回滚方案
6. 故障排查
7. 安全注意事项

## 5.3 参考型文档模板

适合参数、API、配置项、错误码速查。

建议结构：
1. 数据字典/参数表（字段、类型、默认值、是否必填、说明）
2. 示例请求与示例响应
3. 错误码（含触发条件与处理建议）
4. 兼容性说明（版本差异）
5. 变更历史（新增、废弃、替换）

选型建议：
- 如果读者主要目的是“理解”，优先概念型。
- 如果目的是“执行”，优先任务型。
- 如果目的是“查参数”，优先参考型。
- 一篇文档只做一件主事；混合过多时应拆分并交叉链接。


# 6 质量门禁 Checklist（可打勾、可验收）

发布前按下表逐项自检，建议评审时也使用同一张表：

| 维度 | 门禁项 | 通过标准 |
| --- | --- | --- |
| 可执行性 | 所有命令可复制执行 | 抽样或全量执行通过率=100% |
| 可验证性 | 每个关键步骤有“预期输出” | 关键步骤覆盖率=100% |
| 完整性 | 包含前置条件、步骤、预期输出、验证、回滚 | 5项必须全部存在 |
| 一致性 | 术语、命名、单位前后一致 | 同义词混用=0（如 packet/数据包） |
| 准确性 | 版本/参数/路径已核对 | 关键事实抽检无误 |
| 可维护性 | 有 Owner 与最近更新时间 | 元信息字段完整 |
| 可检索性 | 标题与小节可搜索 | 标题能准确命中关键字 |
| 可读性 | 单段不过长、列表化表达 | 80%+ 信息可在列表/表格定位 |

建议设定发布规则：
1. 任务型文档：以上门禁必须全通过。
2. 概念型/参考型文档：除“回滚”外，其余门禁必须通过。
3. 未通过门禁的文档标记为 `draft`，禁止作为正式操作依据。


# 7 文档维护机制（防过期）

## 7.1 文档元信息规范

每篇文档顶部建议至少维护以下字段：

| 字段 | 说明 | 示例 |
| --- | --- | --- |
| title | 文档标题 | 如何写好技术文档 |
| owner | 直接负责人 | john.q |
| reviewers | 评审人 | team-doc |
| status | draft/active/deprecated | active |
| last_updated | 最近更新日期 | 2026-02-10 |
| applicable_versions | 适用版本范围 | Go 1.24+, MySQL 8.0 |

## 7.2 更新触发条件

出现以下任一情况，文档必须在同一迭代内更新：
1. 命令、配置项、接口参数发生变更。
2. 默认行为因版本升级发生变化。
3. 故障处理流程或值班路径变化。
4. 上线后出现“按文档执行仍失败”的案例。

## 7.3 周期性复查机制

1. 高频文档（发布、部署、故障处理）：每月复查一次。
2. 中频文档（日常开发流程）：每季度复查一次。
3. 低频文档（背景知识）：每半年复查一次。

复查结果建议标记：
- `active`：已确认可用。
- `needs-update`：内容部分过期，限期修订。
- `deprecated`：不再适用，给出替代文档链接。

## 7.4 版本兼容矩阵（建议）

建议在关键文档增加兼容矩阵，减少“版本误用”：

| 组件 | 版本 | 状态 | 备注 |
| --- | --- | --- | --- |
| Go | 1.24.x | 支持 | 当前验证版本 |
| MySQL | 8.0.x | 支持 | 参数语义已校验 |
| Redis | 7.x | 支持 | 命令示例基于该版本 |
| MySQL | 5.7.x | 限制支持 | 需参考旧版文档 |


# 8 故障排查写法（从“描述现象”到“可修复”）

## 8.1 推荐结构

故障排查章节建议固定为 7 段：
1. 现象：用户看到什么，系统报什么。
2. 影响：影响范围、优先级、是否阻断主流程。
3. 环境：发生环境、版本、时间窗口、变更背景。
4. 根因：证据链（日志、指标、trace、SQL/命令结果）。
5. 处理步骤：按顺序可执行，每步有预期输出。
6. 验证：修复后如何确认恢复。
7. 预防：如何避免再次发生（监控、阈值、流程）。

## 8.2 排查模板（可直接粘贴）

```markdown
### 故障：<标题>
- 现象：<具体报错/异常表现>
- 影响：<影响用户、影响范围、紧急程度>
- 环境：<prod/staging + 版本 + 时间>
- 根因：<证据1/证据2/证据3>

#### 处理步骤
1. <步骤1>
   - 命令：
   - 预期输出：
2. <步骤2>
   - 命令：
   - 预期输出：

#### 验证
- 验证命令：
- 验证标准：

#### 预防
- 监控项：
- 告警阈值：
- 流程改进：
```

## 8.3 写作禁忌

1. 只写“可能是网络问题”而不给证据。
2. 只写“重启试试”而不说明风险与回滚。
3. 只写“已恢复”而没有验证标准。
4. 只写结论不写适用条件，导致后续误用。
