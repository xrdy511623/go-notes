
---
channel详解
---

1 初始化
声明和初始化管道的方式主要有以下两种:
变量声明
使用内置函数make()

1> 变量声明

```golang
var ch chan int
```
这种方式声明的管道，值为nil。每个管道只能存储一种类型的数据。

2> 使用内置函数make()
使用内置函数make()可以创建无缓冲管道和有缓冲管道

```golang
c1 := make(chan int)
c2 := make(chan int, 5)
```

2 管道操作

1> 操作符
操作符<- 表示数据流向，管道在左表示向管道写入数据，管道在右表示从管道读出数据。
默认的管道为双向可读写，管道在函数间传递时可以使用操作符限制管道的读写，如下所示:

```golang
func NormalChan (ch chan int) {
	// 管道可读写
}

func ReadChan (ch <-chan int) {
	// 只能从管道读取数据
}

func WriteChan (ch chan<- int) {
    // 只能向管道写入数据
}
```

2> 数据读写
管道没有缓冲区时，从管道读取数据会阻塞，直到有协程向管道发送(写入)数据。类似的，向管道写入数据也会阻塞，直到有协程从
管道读取数据。

管道有缓冲区但缓冲区没有数据时，从管道读取数据也会阻塞，直到有协程写入数据。类似的，向管道写入数据，如果缓冲区已满，那么也会
阻塞，直到有协程从缓冲区中读出数据。
对于值为nil的管道，无论读写都会阻塞，而且是永久阻塞。
使用内置函数close()可以关闭管道，尝试向已经关闭的管道写入数据会触发panic，但关闭的管道仍然可读。

![channel-operation.png](images%2Fchannel-operation.png)

管道读取表达式最多可以给两个变量赋值

```golang
v := <-ch
v, ok := <-ch
```
第一个变量表示读出的数据，第二个变量(bool类型)表示是否成功读取了数据，需要注意的是，第二个变量不用于指示管道的关闭状态。
第二个变量常常会被误以为管道的关闭状态，其实它指示的是管道的缓冲区是否还有数据可读。

一个已关闭的管道有两种情况:
管道缓冲区已无数据；
管道缓冲区还有数据。

对于第一种情况，管道已关闭且缓冲区没有数据，那么管道读取表达式返回的第一个变量为相应类型的零值，第二个变量为false；
对于第一种情况，管道已关闭且缓冲区还有数据，那么管道读取表达式返回的第一个变量为读取到的数据，第二个变量为true。

3 小结
内置函数len() 和cap() 作用于管道，分别用于查询缓冲区中数据的个数及缓冲区的大小。
管道实现了一种FIFO，也就是先进先出的队列，数据总是按照写入的顺序流出管道。

协程读取时，阻塞的场景有:
管道为nil；
管道无缓冲区
管道有缓冲区但缓冲区无数据。

协程写入时，阻塞的场景有:
管道为nil；
管道无缓冲区
管道有缓冲区但缓冲区已满。

实现原理

1 数据结构


```golang
// src/runtime/chan.go hchan定义了管道的数据结构
type hchan struct {
   // 当前队列中剩余的元素个数
   qcount   uint
   // 环形队列长度，即可以存放的元素个数
   dataqsiz uint
   // 指向底层循环数组的指针
   // 只针对有缓冲的 channel
   buf      unsafe.Pointer
   // chan 中每个元素的大小
   elemsize uint16
   // chan 是否被关闭的标志
   closed   uint32
   // chan 中元素类型
   elemtype *_type // element type
   // 已发送元素在循环数组中的索引
   sendx    uint   // send index
   // 已接收元素在循环数组中的索引
   recvx    uint   // receive index
   // 等待接收的 goroutine 队列
   recvq    waitq  // list of recv waiters
   // 等待发送的 goroutine 队列
   sendq    waitq  // list of send waiters

   // 互斥锁，chan不允许并发读写
   lock mutex
}
```

从数据结构可以看出管道由队列、类型信息、协程等待队列完成。

1> 环形队列
chan内部实现了一个环形队列作为其缓冲区，队列的长度是在创建chan时指定的。
下图展示了一个可缓存6个元素的管道。

![hchan.png](images%2Fhchan.png)

dataqsiz指示了队列长度为6，即可以缓存6个元素；
buf指向队列的内存；
qcount表示队列中还有两个元素；
sendx指示后续写入的数据存储的位置，这里为4；
recvx指示后续从该位置读取数据，这里为0。

使用数组实现队列是比较常见的操作，sendx和recvx分别表示队尾和队首，分别指示数据数据写入的位置和数据读取的位置。

2> 等待队列
从管道读取数据时，如果管道缓冲区为空或者没有缓冲区时，则读取数据的协程会被阻塞，并被加入到recvq队列。向管道写入
数据时，如果管道缓冲区已满或者没有缓冲区时，则写入数据的协程会被阻塞，并被加入到sendq队列。

处于等待队列中的协程会在其他协程操作管道时被唤醒；
因为读取数据被阻塞的协程会被向管道写入数据的协程唤醒；
因为写入数据被阻塞的协程会被从管道读取数据的协程唤醒。

一般情况下，recvq和sendq至少有一个为空。只有一个例外，那就是同一个协程使用select语句向管道一边写入数据，一边读取数据，
此时协程会分别位于两个等待队列中。

3> 类型信息
一个管道只能传递一种类型的值，类型信息存储在hchan数据结构中。
elemtype代表类型，用于在数据传递过程中赋值；
elemsize代表类型大小，用于在buf中定位元素的位置。
如果需要管道传递任意类型的数据，则可以使用interfac{}类型。

4> 互斥锁
一个管道同时仅允许被一个协程读写。

2 管道操作

1> 创建管道
创建管道的过程实际上是初始化hchan结构，其中类型信息和缓冲区长度由内置函数make()指定，buf的大小则由元素大小和缓冲区容量共同决定。

2> 向管道写数据
如果缓冲区没满，则将数据写入缓冲区，结束发送过程。
如果缓冲区已满，则将当前协程加入sendq队列，进入睡眠并等待被读协程唤醒。

在实现时有一个小技巧，当接收队列recvq不为空时，说明缓冲区没有数据但有协程在等待数据，此时会把数据直接传递给recvq队列中的
第一个协程，而不必再写入缓冲区。

3> 从管道读数据
如果缓冲区有数据，则从缓冲区中取出数据，结束读取过程；
如果缓冲区中没有数据，则将当前协程加入到recvq队列，进入睡眠并等待被写协程唤醒。

类似地，如果等待发送队列sendq不为空，且没有缓冲区，那么此时将直接从sendq队列的第一个协程中获取数据。

4> 关闭管道
关闭管道时会把recvq中的协程全部唤醒，这些协程获取到的数据都是对应类型的零值。同时会把sendq队列中的协程全部唤醒，
但这些协程会触发panic。

除此之外，其他会触发panic的操作还有：
关闭一个已经关闭的管道；
关闭值为nil的管道；
向已经关闭的管道写入数据。

1> select
使用select可以监控多个管道，当其中某一个管道可操作时就触发相应的case分支。
如果多个管道都可操作时，会随机选出一个来读取。
尽管管道中没有数据，select的case语句读管道时不也会阻塞，这是因为case语句编译后调用读管道时会明确传入不阻塞参数，
读不到数据时不会将当前协程加入recvq等待队列，而是直接返回。

2> for-range
通过for-range可以持续地从管道中读取数据，好像在遍历一个数组一样，当管道中没有数据时会阻塞当前协程，与读管道时的阻塞
处理机制一样。即便管道被关闭，for-range也可以优雅地结束。



