
---
一致性读，当前读与快照读
---

当前读，读取的是最新版本，并且对读取的记录加锁，阻塞其他事务同时改动相同记录，避免出现安全问题。
快照读指的是普通的select操作，不包括select ... lock in share mode, select ... for update。
一致性读指的是可重复读隔离级别下的快照读。
Read Committed隔离级别下：每次select普通查询都生成一个快照读。
Read Repeatable隔离级别下：开启事务后第一个select普通查询语句才是快照读的地方，而不是一开启事务就快照读。

下面是一个只有两行的表的初始化语句。

```sql
CREATE TABLE `t` (
`id` int(11) NOT NULL,
`k` int(11) DEFAULT NULL,
PRIMARY KEY (`id`)
) ENGINE=InnoDB;
insert into t(id, k) values(1,1),(2,2);
```





![mvcc-nine.png](images%2Fmvcc-nine.png)





begin/start transaction 命令并不是一个事务的起点，在执行到它们之后的第一个操作 InnoDB 表的语句，
事务才真正启动。如果你想要马上启动一个事务，可以使用 start transaction with consistent snapshot 这个命令。

在这个例子中，事务 C 没有显式地使用 begin/commit，表示这个 update 语句本身就是一个事务，语句完成的时候会自动提交。
事务 B 在更新了行之后查询 ; 事务 A 在一个只读事务中查询，并且时间顺序上是在事务 B 的查询之后。
这时，事务 B 查到的 k 的值是 3，而事务 A 查到的 k 的值是 1。

为什么？
在可重复读隔离级别下，事务C的更新操作是在事务A开启之后提交的，因此C的更改对A是不可见的；而事务B在事务A读取数据时还未
提交，其更改操作对于A而言更是不可见的，因此根据版本链推导，此时事务A读到的k值只能是1。
虽然事务A执行期间这id=1这一行数据被修改过，但是事务 A 不论在什么时候查询，看到这行数据的结果都是一致的，所以我们称之为一致性读。

事务B的更新操作必然是当前读，否则会丢失其他事务的更新。因此，事务B会读到已提交事务C的更新，也就是k=2，事务B在此基础上将k更新为3，
那么之后事务B读k时，自然可以读取到自己事务内部的更新，于是它读到的k值就是3。

因此，更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”（current read）。
其实，除了 update 语句外，select 语句如果加锁，也是当前读。
所以，如果把事务 A 的查询语句 select * from t where id=1 修改一下，加上 lock in share mode 或 for update，也都可以读到
最新版本的数据，返回的 k 的值是 3。

再往前一步，假设事务 C 不是马上提交的，而是变成了下面的事务 C’，会怎么样呢？





![mvcc-ten.png](images%2Fmvcc-ten.png)





事务 C’的不同是，更新后并没有马上提交，在它提交前，事务 B 的更新语句先发起了。前面说过了，虽然事务 C’还没提交，
但是 (1,2) 这个版本也已经生成了，并且是当前的最新版本。那么，事务 B 的更新语句会怎么处理呢？
这时候，我们在上一篇文章中提到的“两阶段锁协议”就要上场了。事务 C’没提交，也就是说 (1,2) 这个版本上的写锁还没释放。
而事务 B 是当前读，必须要读最新版本，而且必须加锁，因此就被锁住了，必须等到事务 C’释放这个锁，才能继续它的当前读。





![mvcc-demo.png](images%2Fmvcc-demo.png)





InnoDB 的行数据有多个版本，每个数据版本有自己的 row trx_id，每个事务或者语句有自己的一致性视图。普通查询语句是一致性读，
一致性读会根据 row trx_id 和一致性视图确定数据版本的可见性。
- 对于可重复读，查询只承认在事务启动前就已经提交完成的数据；
- 对于读提交，查询只承认在语句启动前就已经提交完成的数据；
  而当前读，总是读取已经提交完成的最新版本。
  你也可以想一下，为什么表结构不支持“可重复读”？这是因为表结构没有对应的行数据，也没有 row trx_id，因此只能遵循当前读的逻辑。