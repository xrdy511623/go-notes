
---
硬核: MySQL行锁实战
---

MySQL使用版本
5.7.24  
8.0.13

测试表t建表语句及插入的数据如下:

```sql
create table t(
    id int primary key not null,
    c int not null,
    d int not null,
    key idx_c(c)
)engine=InnoDB;

insert into t values(0,0,0),(5,5,5),(10,10,10),(15,15,15),(20,20,20),(25,25,25);
```

# 1 什么SQL语句会加行级锁？

InnoDB 引擎是支持行级锁的，而 MyISAM 引擎并不支持行级锁，故以下内容都是基于 InnoDB 引擎的。
所以，在说 MySQL 是怎么加行级锁的时候，其实是在说 InnoDB 引擎是怎么加行级锁的。
普通的 select 语句是不会对记录加锁的，因为它属于快照读，是通过 MVCC（多版本并发控制）实现的。如果要在查询时对
记录加行级锁，可以使用下面这两个方式，这两种查询会加锁的语句称为锁定读。

```sql
//对读取的记录加共享锁(S型锁,也叫共享锁)
select ... lock in share mode
// 对读取的记录加独占锁(X型锁，也叫独占锁)
select ... for update
```

上面这两条语句必须在一个事务中，因为一旦事务提交了，锁就会被释放，所以在使用这两条语句的时候，要加上 begin 或者 
start transaction 开启事务的语句。
除了上面这两条锁定读语句会加行级锁之外，update 和 delete 操作都会加行级锁，且锁的类型都是独占锁(X型锁)。

共享锁（S锁）满足读读共享，读写互斥。独占锁（X锁）满足写写互斥、读写互斥。
共享锁与共享锁是可以兼容的，但是与独占锁是互斥的。





![lock-exclusive-one.png](images%2Flock-exclusive-one.png)






而独占锁是应用于写操作的，它与共享锁以及独占锁都是互斥的，也就是读写互斥，写写也互斥。





![lock-exclusive-two.png](images%2Flock-exclusive-two.png)





![lock-exclusive-three.png](images%2Flock-exclusive-three.png)





# 2 行级锁有哪些种类？


不同隔离级别下，行级锁的种类是不同的。
在读已提交隔离级别下，行级锁的种类只有记录锁，也就是仅仅把一条记录锁上。
在可重复读隔离级别下，行级锁的种类除了有记录锁，还有间隙锁（目的是为了避免幻读），所以行级锁的种类主要有三类：
- Record Lock，记录锁，也就是仅仅把一条记录锁上，主要作用是保护这条记录，防止有别的事务去更新或删除它；
- Gap Lock，间隙锁，锁定一个范围，但是不包含记录本身，主要作用是阻止其他事务插入这个间隙，避免出现幻读的问题；
- Next-Key Lock：Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。

接下来，分别介绍这三种行级锁。

## 2.1 Record Lock

Record Lock 称为记录锁，锁住的是一条记录。而且记录锁是有 S 锁和 X 锁之分的：
- 当一个事务对一条记录加了 S 型记录锁后，其他事务也可以继续对该记录加 S 型记录锁（S 型与 S 锁兼容），
但是不可以对该记录加 X 型记录锁（S 型与 X 锁不兼容）;
- 当一个事务对一条记录加了 X 型记录锁后，其他事务既不可以对该记录加 S 型记录锁（S 型与 X 锁不兼容）， 
也不可以对该记录加 X 型记录锁（X 型与 X 锁不兼容）。

## 2.2 Gap Lock

Gap Lock 称为间隙锁，只存在于可重复读隔离级别，目的是为了解决可重复读隔离级别下幻读的现象。
间隙锁虽然存在 X 型间隙锁和 S 型间隙锁，但是并没有什么区别，
间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入
幻影记录而提出的，所以，与间隙锁存在冲突的是向这个间隙插入数据的操作。

## 2.3 Next-Key Lock

Next-Key Lock 称为临键锁，是 Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。其作用是保护该记录，
同时阻止其他事务将新记录插入到被保护记录**前面**的间隙中。

next-key lock 是包含间隙锁+记录锁的，如果一个事务获取了 X 型的 next-key lock，那么另外一个事务在获取相同范围的 
X 型的 next-key lock 时，是会被阻塞的。
比如，一个事务持有了范围为 (1, 10] 的 X 型的next-key lock，那么另一个事务在获取相同范围的 X 型的next-key lock 时，就会被阻塞。
虽然相同范围的间隙锁是多个事务相互兼容的，但对于记录锁，我们是要考虑 X 型与 S 型关系，X 型的记录锁与 X 型的记录锁是冲突的。


# 3 行级锁的加锁规则

一个基本概念是MySQL的锁都是加在索引上的，这是前置条件。
MySQL在InnoDB存储引擎的可重复读隔离级别下，加锁规则如下:
原则1: 加锁的基本单位是next-key lock(gap lock+record lock), next-key lock是左开右闭区间。
原则2: 查找过程中访问到的对象才会加锁。

**两个优化**
优化1: 索引上的等值查询，给唯一索引加锁时，next-key lock会退化成行锁(record lock)
优化2: 索引上的等值查询，向右遍历时当最后一个值不满足查询条件时，next-key lock会退化成间隙锁(gap lock)

但是，next-key lock 在一些场景下会退化成记录锁或间隙锁，以缩小锁的粒度，提高系统的并发度。
那到底是什么场景呢？总结一句，在能使用记录锁或者间隙锁就能避免幻读现象的场景下， next-key lock 就会退化成记录锁或间隙锁。

**next-key lock退化成记录锁或间隙锁的七种场景**

> 唯一索引等值查询，且查询的记录存在;
则在索引树上定位到这一条记录后，将该记录的索引中的 next-key lock 退化成record lock，也就是记录锁。

> 唯一索引等值查询，但查询的记录不存在;
则在索引树找到第一条大于该查询记录的记录后，会将该记录的索引中的 next-key lock 退化成 gap lock，也就是间隙锁。

> 非唯一索引等值查询，且查询的记录存在;
由于不是唯一索引，所以可能存在索引值相同的记录，于是非唯一索引等值查询的过程是一个扫描的过程，会一直扫描直到
第一个不符合条件的二级索引记录为止，然后在扫描的过程中，对扫描到的二级索引记录加的是 next-key 锁，而对于
第一个不符合条件的二级索引记录，该二级索引的 next-key 锁会退化成间隙锁。同时，在符合查询条件的记录的
主键索引上加记录锁(如果需要回表的话)。

> 非唯一索引等值查询，且查询的记录不存在;
扫描到第一条不符合条件的二级索引记录就结束了，该二级索引的 next-key 锁会退化成间隙锁。因为不存在满足查询条件
的记录，所以不会对主键索引加锁。

> 唯一索引范围查询
范围查询和等值查询的加锁规则是不同的。

当唯一索引进行范围查询时，会对每一个扫描到的索引加 next-key 锁，然后如果遇到下面这些情况，会退化成记录锁或者间隙锁：
- 情况一：针对「大于等于」的范围查询，因为存在等值查询的条件，那么如果等值查询的记录是存在于表中，那么该记录的索引中的 next-key 锁会退化成记录锁，
然后从扫描到的下一个记录开始一直到+∞，都会加next-key lock。
如果等值查询的记录不存在于表中，那么从第一个扫描到的符合条件的记录开始到+∞，都会加next-key lock。而对于大于的范围查询也是如此，从第一个
扫描到的符合条件的记录开始到+∞，都会加next-key lock。

- 情况二：针对「小于或者小于等于」的范围查询，要看条件值的记录是否存在于表中：
当条件值的记录不在表中，那么不管是「小于」还是「小于等于」条件的范围查询，扫描到终止范围查询的记录时，该记录的索引的 next-key 锁会退化成间隙锁，
其他扫描到的记录，都是在这些记录的索引上加 next-key 锁。
当条件值的记录在表中，如果是「小于」条件的范围查询，扫描到终止范围查询的记录时，该记录的索引的 next-key 锁会退化成间隙锁，其他扫描到的记录，
都是在这些记录的索引上加 next-key 锁；如果「小于等于」条件的范围查询，扫描到终止范围查询的记录时，该记录的索引 next-key 锁不会退化成间隙锁。
其他扫描到的记录，都是在这些记录的索引上加 next-key 锁。

- 情况三: 针对既有大于等于又有小于等于这种范围查询，则是分别针对两种范围查询加锁的结果集取交集。
譬如，针对"select * from t where id>10 and id<=15 for update"这条SQL，加锁的分析过程如下:
对于>10的范围查询，加锁结果是(10,15], (15,20], (20,25], (25, +∞];
而对于<=15的范围查询，加锁结果则是(10,15], (5,10], (0,5], (-∞, 0]
最后取交集，正是(10,15]






![analyze-lock-six.png](images%2Fanalyze-lock-six.png)






> 非唯一索引范围查询;
非唯一索引和主键索引的范围查询的加锁也有所不同，不同之处在于非唯一索引范围查询，索引的 next-key lock不会有退化为间隙锁和记录锁的情况，也就是
非唯一索引进行范围查询时，对二级索引记录加锁都是加 next-key 锁。

之所以没有退化为间隙锁和记录锁的优化，是因为非唯一索引不具有唯一性，所以如果只加记录锁（记录锁无法防止插入，只能防止删除或者修改），就会导致其他事务
插入相同的记录，这样前后两次查询的结果集就不相同了，会出现幻读的问题。

> 没有加索引的查询

如果锁定读查询语句，没有使用索引列作为查询条件，或者查询语句没有走索引查询，导致查询是全表扫描。那么，每一条记录的索引上都会加
next-key 锁，这样就相当于锁住的是全表，这时如果其他事务对该表进行增、删、改操作的时候，都会被阻塞。
不只是锁定读查询语句不加索引才会导致这种情况，update 和 delete 语句如果查询条件不加索引，那么由于扫描的方式是全表扫描，于是
就会对每一条记录的索引上都会加 next-key 锁，这样就相当于锁住的全表。
因此，在线上在执行 update、delete、select ... for update 等具有加锁性质的语句，一定要检查语句是否走了索引，如果是全表
扫描的话，会对每一个索引加 next-key 锁，相当于把整个表锁住了，这是挺严重的问题。


# 4 实战案例分析

## case1  唯一索引等值查询，且查询记录不存在





![row-lock-one.png](images%2Frow-lock-one.png)





请问session B和session C两个事务中的操作能否执行成功，为什么？

先说结论:session B中的事务操作会执行失败，session C会执行成功。
分析:session A中的事务先执行，我们看一下加锁过程，首先加锁单位是next-key_lock，由于没有找到id=7这一行数据，
所以会找到第一条大于id=7的记录，也就是id=10的记录，对它加上next-key lock，于是锁定范围是(5,10]。但因为是
唯一索引，所以会退化成间隙锁，故而最终加锁范围是(5,10), 所以session B插入id=8这一行数据会失败；而session C
是对id=10这行数据进行修改操作，不在(5,10)这个加锁区间内，所以可以执行成功。

验证结论：





![verify-one.png](images%2Fverify-one.png)





## case2  非唯一索引等值查询，且查询记录存在





![row-lock-two.png](images%2Frow-lock-two.png)





请问session B和session C两个事务中的操作能否执行成功，为什么？
进阶: 如果把session A中的查询语句改为select d from t where c=5 lock in share mode; 结果又会有什么不同，为什么？

结论: session B中的事务操作会执行成功，session C会执行失败。如果把session A中的查询语句改为select d from t where c=5 lock in share mode，那么session B和session C都会执行失败。
分析: 因为session A中的查询语句是当前读( lock in share mode), 而不是快照读(普通的查询语句)，所以会加锁，而且这里是对非唯一索引c加锁，由于是select id，那么在普通索引，也就是字段c的索引树上就可以获取到所需要的数据(主键索引id的值)，不需要回表，所以只会对非唯一索引这个字段c加锁。根据加锁规则，它首先会对c=5加上next-key lock，于是字段c的(0, 5]区间被加锁了，同时由于c是非唯一索引，所以会一直向右扫描到第一个不满足查询条件的记录为止，也就是c=10，对于这个不满足查询条件的记录会退化为间隙锁，于是加锁范围是(5, 10)，所以最终的加锁范围是字段C的(0, 10)区间。
sesssion B中操作的是id=5的数据行，修改的是字段d的值，而session A不需要回表，所以只是对字段c的(0,10)区间加锁，对主键索引id并未加锁，所以sesssion B的操作并不会受到影响，可以执行成功。
而session C的插入操作，会影响到c=7这一行，会被session A对字段c的(5, 10)的间隙锁所阻塞，无法执行。


### 有什么命令可以分析加了什么锁？

我们可以通过 select * from performance_schema.data_locks\G; 这条语句，查看事务执行 SQL 过程中加了什么锁。
我们以上面的事务session A作为例子，分析下下它加了什么锁。





![analyze-lock-one.png](images%2Fanalyze-lock-one.png)






![analyze-lock-two.png](images%2Fanalyze-lock-two.png)





从上图可以看到，共加了两个锁，分别是：

表锁：S 类型的意向锁；
行锁：S 类型的记录锁；
这里我们重点关注行级锁，图中 LOCK_TYPE 中的 RECORD 表示行级锁，而不是记录锁的意思。

通过 LOCK_MODE 可以确认是 next-key 锁，还是间隙锁，还是记录锁：
如果 LOCK_MODE 为 X(或S)，说明是 next-key 锁；
如果 LOCK_MODE 为 X(或S), REC_NOT_GAP，说明是记录锁；
如果 LOCK_MODE 为 X(或S), GAP，说明是间隙锁；

从上图可以看出，加锁范围只限于普通索引c(INDEX_NAME都是idx_c)的(0,5]区间(next-key lock(LOCK_MODE为S))
和(5,10)区间(gap lock(LOCK_MODE为S,GAP))，并未对主键索引加锁。


如果把session A中的查询语句改为select d from t where c=5 lock in share mode，由于是select d，那么
在普通索引，也就是字段c的索引树上无法获取到所需要的数据(字段d对应的值)，所以需要根据获取到的主键索引id的值去
主键索引树上回表查询获取d的值，因此加锁范围就不限于字段c了，会因为回表扩展到主键字段id, 因此最终的加锁范围除了
字段C的(0, 10)区间，还包含扫描过程中符合查询条件的主键记录id=5的记录锁，因此sesssion B操作id=5的数据行以及
session C操作c=7的数据行都会失败。





![analyze-lock-three.png](images%2Fanalyze-lock-three.png)





![analyze-lock-four.png](images%2Fanalyze-lock-four.png)





![analyze-lock-five.png](images%2Fanalyze-lock-five.png)





从上图可以看到，加锁情况与我们分析的一致，加锁范围除了普通索引c(INDEX_NAME都是idx_c)的(0,5]区间(next-key lock(LOCK_MODE为S))
和(5,10)区间(gap lock(LOCK_MODE为S,GAP))，还对主键索引id加了锁，INDEX_NAME:PRIMARY表示对主键索引加锁；
LOCK_MODE为S,REC_NOT_GAP，说明是记录锁；LOCK_DATA为5，表明是对主键为5的记录加了记录锁(RECORD LOCK)





![verify-two.png](images%2Fverify-two.png)





将session A中的查询语句改为select d from t where c=5 lock in share mode后，结果就变了。





![verify-three.png](images%2Fverify-three.png)





## case3  唯一索引范围查询，且查询记录存在





![row-lock-three.png](images%2Frow-lock-three.png)





结论:session B的第一个插入操作能执行成功，但第二个插入操作会失败，session C中的事务能执行成功。
分析: 根据sql语句，首先要找id=10这一行数据，那么加的next-key lock会锁住(5,10]范围，但根据优化一，索引上的
等值查询，给唯一索引加锁时， next-key lock会退化为record lock，也就是行锁，所以此时只会锁住id=10这一行；
由于是范围查询，所以这里唯一索引id的范围查询会访问到不满足条件的第一个值为止,也就是id=15, id=15显然不满足
查询条件，所以锁住的是间隙锁(10,15), 所以最终锁住的区间是[10,15), 因此session B的第一个操作是插入id=8
这一行数据，并不会被阻塞，能执行成功，而第二个操作是插入id=13这一行数据，与session A的加锁范围[10,15)冲突，
无法执行。session C操作的是id=15的数据行，不会与session A的加锁范围[10,15)冲突，是可以执行成功的。





![verify-four.png](images%2Fverify-four.png)





## case4 非唯一索引范围查询，且查询记录存在





![row-lock-four.png](images%2Frow-lock-four.png)





结论: 在MySQL5.7版本下， session B的插入操作会失败，session C的更新操作也会执行失败。
在MySQL8.0版本及以后， 对第二个next-key lock(10,15]会应用优化2，session B的插入操作会失败，session C的
更新操作会执行成功。

分析: 与case3不同，此次session A加锁对象是非唯一索引字段c, 那么在等值查询c=10时就没有了优化，所以是加的是完整
的next-key lock, 同时因为是select *，所以需要回表，会锁住字段c的(5,10]这个区间范围，同时给主键id=10的记录
加上记录锁，因为是范围查询，会向右遍历直到找到第一个不满足条件的值为止，因此会锁住(10,15]范围。最终加锁范围是(5,15], 
因此session B的插入操作会失败，session C的更新操作也会执行失败。

那么为什么这里没有应用优化2，向右遍历时如果最后一个值不满足等值条件时，next-key lock会退化为gap lock，也就是间隙锁？
因为非唯一索引和主键索引的范围查询的加锁有所不同，不同之处在于非唯一索引范围查询，索引的next-key lock 不会有退化为
间隙锁和记录锁的情况，也就是非唯一索引进行范围查询时，对二级索引记录加锁都是加 next-key 锁。
之所以没有退化为间隙锁和记录锁的优化，是因为非唯一索引不具有唯一性，所以如果只加记录锁（记录锁无法防止插入，只能防止
删除或者修改），就会导致其他事务插入相同的记录，这样前后两次查询的结果集就不相同了，会出现幻读的问题。

而在MySQL8.0版本后，对第二个next-key lock(10,15]会应用优化2 索引上的等值查询,向右遍历时如果最后一个值不满足
等值条件时，next-key lock会退化为gap lock，也就是间隙锁，所以c=15不会加锁，最终的加锁范围就是(5,15)。因此
session B的插入操作会失败，session C的更新操作会执行成功。

验证结论:





![verify-five.png](images%2Fverify-five.png)
![verify-six.png](images%2Fverify-six.png)





![verify-seven.png](images%2Fverify-seven.png)
![verify-eight.png](images%2Fverify-eight.png)





## case5 唯一索引范围bug





![row-lock-five.png](images%2Frow-lock-five.png)





结论: 在MySQL5.7版本下，session B的更新操作会失败，session C的插入操作也会执行失败。
但是在MySQL8.0版本及以后，会进行优化，session B的更新操作和session C的插入操作都能执行成功。

分析: MySQL首先会在主键索引id上加上(10,15]这个next-key lock, 按理说因为id是唯一键，所以判断到id=15这一行就应该停止了，
但是实现上，InnoDB会向后扫描到第一个不满足条件的行为止，也就是id=20, 因此索引id上的(15, 20]这个next-key lock 也会被
加锁。结果就是session B的更新操作和session C的插入操作都和(15, 20]这个next-key lock冲突导致执行失败。

而在MySQL8.0版本及以后，会进行优化，只会加(10,15]这一个next-key lock，因此session B的更新操作和session C的插入
操作都能执行成功。 

验证结论:





![verify-nine.png](images%2Fverify-nine.png)





![verify-ten.png](images%2Fverify-ten.png)





## case6 非唯一索引上存在等值的例子

首先我们插入一行数据，让表t中有两行c=10的数据

```sql
insert into t values(30,10,30);
```





![row-lock-six.png](images%2Frow-lock-six.png)





结论: session B的插入操作会执行失败，而session C的更新操作会执行成功。
分析: 根据原则一， 首先会对非唯一字段c加上(5, 10]的next-key lock, 然后因为是非唯一索引，所以需要向右遍历，查询是否
还有c=10的数据，因此会在(10,15]区间也加上next-key lock，但由于是等值查询，会应用优化2，退化为间隙锁(10,15), 
所以最终加锁范围是(5,15), 因此session B的插入操作会执行失败，而session C的更新操作会执行成功。
验证结论





![verify-eleven.png](images%2Fverify-eleven.png)





## case7 limit语句加锁





![row-lock-seven.png](images%2Frow-lock-seven.png)





结论：session B中的插入操作能执行成功。
分析: 我们知道，此时表t里c=10的记录就两条，因此后面加不加limit 2，删除的效果其实都是一样的，但是加锁的效果却不同，
这里加了limit 2的限制，因此InnoDB存储引擎在向右遍历到(c=10,id=30)这一行之后，满足条件的记录已经有两条，不需要
再继续向右遍历寻找符合c=10的记录了，遍历就此结束。因此在字段c索引上的加锁范围就变成了c的(5,10]这个左开右闭的区间
(c=5,id=5到c=10,id=30), 因此session B插入c=12这一行数据，并没有在加锁范围内，所以是可以正常执行的。

从这里我们可以看到，在删除数据时应该尽可能的加limit, 这样不仅可以控制删除数据的条数，让操作更安全，还可以减小
加锁的范围，提升并发度。


验证结论:





![verify-twelve.png](images%2Fverify-twelve.png)





## case8 一个死锁的案例





![row-lock-eight.png](images%2Frow-lock-eight.png)





结论: session B中的更新操作一开始会阻塞，待到session A中执行插入操作时，session B中的更新操作会导致出现死锁而被系统强制要求回滚。
分析: 首先，session A启动的查询语句是加了共享锁的当前读，因此会在索引c上加next-key lock(5,10]，由于c是非唯一索引，所以需要向右遍历，
于是在c=15的记录上也加了next-key lock((10,15])，同时由于是索引c上的等值查询，会应用优化2，next-key lock会退化为间隙锁，所以在
c=15的记录上加的是间隙锁(10,15)，故session A对索引c的最终加锁范围为next-key lock(5,10] 和间隙锁(10,15)。

然后同样的，session B的更新操作也要在索引c上加next-key lock(5,10] 和间隙锁(10,15)，由于需要回表操作，还会触发在主键索引id
上(id=10)加锁， 但是第一步加next-key lock(5,10]就会和session A持有的锁冲突，而被迫进入锁等待。
最后当session A中执行插入(8,8,8)操作时, 会被session B的间隙锁锁住，由于出现了死锁，InnoDB会强制要求回滚成本更低的session B回滚。
这里就出现了一个问题，为什么session A中执行插入(8,8,8)操作时, 会被session B的间隙锁锁住，它的next-key lock(5,10]不是还没
申请成功吗？
其实是这样的，sessionB的next-key lock(5,10]加锁操作，实际上分成了两步，先是加(5,10)的间隙锁，加锁成功；然后加c=10的行锁，这时候才被阻塞的。
等等，还是不对啊，session A不是已经加了next-key lock(5,10] 吗，那肯定也是一样的，先加的(5,10)的间隙锁，然后加c=10的行锁，怎么session B
加(5,10)的间隙锁还能加锁成功呢，难道不会与session A的间隙锁5,10)冲突吗？
嗯，这个不会，因为间隙锁(gap lock)和行锁(record lock)不同，跟间隙锁存在冲突关系的，是往这个间隙中插入一个记录这个操作，间隙锁之间是不存在冲突关系的。





![verify-thirteen.png](images%2Fverify-thirteen.png)





## case9 怀疑人生的案例





![row-lock-nine.png](images%2Frow-lock-nine.png)





结论: session B的插入操作会阻塞，最后失败。
分析: 由于是order by c desc, 第一个要定位是索引c上最右边的c=20那一行，所以会加上间隙锁(20,25)和next-key lock(15,20]
因为是desc降序排序，所以会在索引c上向左遍历，要扫描到c=10才停下来(会查到第一个不满足条件的行为止)，所以next-key lock会加到(5,10], 
这正是阻塞session B的插入(6,6,6)操作的原因。
在扫描过程中，c=20, c=15, c=10这三行都存在值，由于是select *，需要回表，所以也会在主键id上加行锁。
因此，session A的select语句加锁范围是:
索引c上(5,25)
主键索引上id=15, id=20两个行锁。

注意: c=10并不符合查询条件，所以id=10这一行不会加行锁。

验证结论:





![suspect.png](images%2Fsuspect.png)




![suspect-one.png](images%2Fsuspect-one.png)
![suspect-two.png](images%2Fsuspect-two.png)
![suspect-three.png](images%2Fsuspect-three.png)
![suspect-four.png](images%2Fsuspect-four.png)

可以看到，加锁范围是字段c上的(5,10],(10,15],(15,20]上的next-key lock以及(20,25)上的间隙锁，
以及主键id上的id=15,20两个行锁。


## case10  加锁是分步加的，不是一次性加上的





![row-lock-ten.png](images%2Frow-lock-ten.png)





结论: 因为这两条SQL语句要操作相同的资源，但是加锁顺序却相反，所以并发执行时会因为互相等待导致死锁。





![explain-one.png](images%2Fexplain-one.png)





分析: 通过explain工具可以看到，session A的查询操作使用了索引c, 说明取到的4个值都是通过B+树搜索定位的，也就是从小到大
搜索定位的，因此是先查找c=5, 加了(0,5]的next-key lock， 然后加了间隙锁(5,10); 同样的，定位c=10时，加锁范围是
(5,10]和(10,15), 定位c=20时，加锁范围是(15,20]和(20,25)。
而在执行session B中的查询语句时，因为是按照字段c的值进行降序排序，所以加锁顺序是相反的，是先定位c=20时，加锁范围
(15,20]和(20,25)；然后定位c=10，加锁范围是(5,10]和(10,15)；最后查找c=5, 加了(0,5]的next-key lock和间隙锁(5,10)。
如此，两个事务都要对相同的资源进行操作(加锁)，但是加锁顺序正好相反，并发执行时便很容易出现因为互相等待而导致死锁的现象了。

因此，要避免死锁，对同一组资源我们要尽量按相同的顺序去操作。而在出现死锁时，MySQL会比较产生冲突的两个事务中谁占有的资源更多，
回滚成本更大，从而选择回滚成本更小的，占用资源更少的事务来回滚。


## case11 锁等待和锁合并





![row-lock-eleven.png](images%2Frow-lock-eleven.png)





结论:  session B中的删除操作可以正常执行，但接下来的插入操作会执行失败。
分析:  session A 对主键id的加锁范围是(10, 15], 也就是id=10这一行并不会
被加锁，所以session B中的删除id=10这一行数据的操作可以正常执行，但是由于delete删除操作把id=10这一行删掉了，
MySQL就只能向左找id=5这一行数据作为参照加锁, 加锁范围变成了(5, 15) 导致session B再想插入id=10这一行就不行了。
这里我们看到了一个诡异的现象，session A 执行完select语句后，什么都没做，但它的加锁范围突然变大了。


验证结论:





![verify-fourteen.png](images%2Fverify-fourteen.png)





## case12 update的诡异例子





![row-lock-twelve.png](images%2Frow-lock-twelve.png)





结论: session B中的第一个更新操作能正常执行，第二个更新操作会执行失败。
分析: 根据c>5查到的第一个记录是c=10, 因此不会加(0,5]这个next-key lock，所以session A的加锁范围是(5,10], (10,15], 
(15,20], (20,25], (25, supreme], 所以session B的第一个更新操作，修改c=5这一行数据与session A的加锁范围并不冲突，
可以正常执行。由于索引c上(5,10)的间隙锁是由这个间隙右边的记录，也就是c=10定义的，所以第一个更新操作执行后，session A 
的最左边的加锁范围就变成了(1,10)。详细来说，就是现在没有c=5的数据了，要找c>5的数据，存储引擎找不到c=5的参照系，只能
锁定(1,10)这段间隙，因此session B中的更新操作的第二步插入(c=5, id=5)这条记录就会与session A的间隙锁(1,10)冲突，
所以会执行失败。


验证结论:





![verify-fifteen.png](images%2Fverify-fifteen.png)





## case 13 非唯一索引等值查询且查询的记录不存在

```sql
select * from t where c=17 for update
```

我们知道，此时的加锁情况是对字段c加锁，范围为(15,20)，由此引发了一个问题，事务 A 在 c = 20 记录的二级索引上，加了
X 型的间隙锁，范围是 (15, 20)。意味着其他事务无法插入 c 值为 16、17、18、19 这些新记录。不过对于插入 c=15和c=20 
记录的语句，一定能执行成功吗？

我们先要弄清楚，什么情况下插入语句会发生阻塞。
插入语句在插入一条记录之前，需要先定位到该记录在 B+树中的位置，如果插入的位置下一条记录的索引上有间隙锁，才会发生阻塞。
在分析二级索引的间隙锁是否可以成功插入记录时，我们要先要知道二级索引树是如何存放记录的？
二级索引树是按照二级索引值按顺序存放的，在相同的二级索引值情况下， 再按主键id的顺序存放。知道了这个前提，我们才能知道
执行插入语句的时候，插入位置的下一条记录是谁。

插入 c = 15 记录的成功和失败的情况分别如下：
- 当其他事务插入一条 c = 15，id = 13 的记录的时候，在二级索引树上定位到插入的位置，而该位置的下一条是 
id = 15、c = 15 的记录，该记录的二级索引c上没有间隙锁，所以这条插入语句可以执行成功。

解释:(13,15)的下一条记录是(15,15)，(13,15)到(15,15)之间是没有间隙锁的，所以可以插入成功

- 当其他事务插入一条 c = 15，id = 17 的记录的时候，在二级索引树上定位到插入的位置，而该位置的下一条是
id = 20、c = 20 的记录，正好该记录的二级索引上有间隙锁，所以这条插入语句会被阻塞，无法插入成功。

解释:(17,15)的下一条记录是(20,20)，(15,15)到(20,20)之间是有间隙锁的，所以无法插入成功，也就是(17,15)
这条记录正好处在(15,15)到(20,20)之间，这一段是有间隙锁的，故而无法插入成功。

验证结论:





![verify-sixteen.png](images%2Fverify-sixteen.png)





插入 c = 20 记录的成功和失败的情况分别如下：
- 当其他事务插入一条 c = 20，id = 17 的记录的时候，在二级索引树上定位到插入的位置，而该位置的下一条是 id = 20、
c = 20 的记录，正好该记录的二级索引上有间隙锁，所以这条插入语句会被阻塞，无法插入成功。
- 当其他事务插入一条 c = 20，id = 21 的记录的时候，在二级索引树上定位到插入的位置，而该位置的下一条记录不存在，
- 也就没有间隙锁了，所以这条插入语句可以插入成功。

验证结论：





![verify-seventeen.png](images%2Fverify-seventeen.png)





所以，当有一个事务持有二级索引idx的间隙锁 (a, b) 时，插入 idx=a 或者 idx = b 记录的语句是否可以执行成功，
关键还要考虑插入记录的主键值，因为「二级索引值（idx列）+主键值（pk列）」才可以确定插入的位置，确定了插入位置后，
就要看插入的位置的下一条记录是否有间隙锁，如果有间隙锁，就会发生阻塞，如果没有间隙锁，则可以插入成功。


知道了这个结论之后，我们再回过头看，非唯一索引等值查询时，查询的记录不存在时，执行
select * from performance_schema.data_locks\G;输出的结果。





![analyze-lock-seven.png](images%2Fanalyze-lock-seven.png)





在前面分析输出结果的时候，我说的结论是：「事务 A 在 c = 20 记录的二级索引上，加了范围为 (15,20) 的 X 型间隙锁」。
这个结论其实还不够准确，因为只考虑了 LOCK_DATA 第一个数值（20），没有考虑 LOCK_DATA 第二个数值（20）。
那 LOCK_DATA：20，20 是什么意思？
- LOCK_DATA 第一个数值，也就是 20， 它代表的是字段c的值。我们知道，LOCK_DATA 第一个数值是 next-key 锁和
间隙锁锁住的范围的右边界值。
- LOCK_DATA 第二个数值，也就是20， 它代表的是 id 值。
之所以 LOCK_DATA 要多显示一个数值（ID值），是因为针对「当某个事务持有非唯一索引的 (15,20) 间隙锁的时候，其他事务
是否可以插入 c = 20 新记录」的问题，还需要考虑插入记录的 id 值。而 LOCK_DATA 的第二个数值，就是说明在插入 c = 20 
新记录时，哪些范围的 id 值是不可以插入的。
因此， LOCK_DATA：20，20 + LOCK_MODE : X, GAP 的意思是，事务 A 在 c = 20 记录的二级索引上（INDEX_NAME: index_c ），
加了c值范围为 (15, 20) 的 X 型间隙锁，同时针对其他事务插入 c 值为 20 的新记录时，不允许插入的新记录的 id 值小于20 。 
如果插入的新记录的 id 值大于20，则可以插入成功。

但是我们无法从select * from performance_schema.data_locks\G; 输出的结果分析出「在插入 c = 20 新记录时，哪些范围的
id 值是可以插入成功的」，这时候就得自己画出二级索引的 B+ 树的结构，然后确定插入位置后，看下该位置的下一条记录是否存在间隙锁，
如果存在间隙锁，则无法插入成功，如果不存在间隙锁，则可以插入成功。


## case 14 非唯一索引等值查询且查询的记录存在(二级索引加锁分析)

```sql
select * from t where c=15 for update
```





![analyze-lock-eight.png](images%2Fanalyze-lock-eight.png)





从上图可以看到，该事务的加锁结果为: 对字段c加上(10,15]的next-key lock加上(15,20)的间隙锁以及对主键索引id=15
这一行加上record记录锁，这与我们根据加锁规则得出的分析完全一致。

- 在 c = 15 这条记录的二级索引上，加了范围为 (10, 15] 的 next-key 锁，意味着其他事务无法更新或者删除 c = 15 的
记录，针对是否可以插入 c = 10 和 c = 15 的新记录，分析如下：
是否可以插入 c = 10 的新记录，还要看插入的新记录的 id 值，如果插入 c = 10 新记录的 id 值小于 10，那么就可以插入
成功，因为此时插入的位置的下一条记录是 id = 10，c = 10 的记录，该记录的二级索引上没有间隙锁。如果插入 c = 10 新
记录的 id 值大于 10，那么就无法插入成功，因为此时插入的位置的下一条记录是 id = 15，c = 15 的记录，该记录的二级
索引上有间隙锁。





![verify-eighteen.png](images%2Fverify-eighteen.png)





- 是否可以插入 c = 15 的新记录，还要看插入的新记录的 id 值，从 LOCK_DATA : 15, 15 可以得知，其他事务插入 c 
值为 15 的新记录时，如果插入的新记录的 id 值小于 15，那么插入语句会发生阻塞；
如果插入的新记录的 id 大于 15，还要看该新记录插入的位置的下一条记录是否有间隙锁，如果没有间隙锁则可以插入成功，
如果有间隙锁，则无法插入成功。





![verify-nineteen.png](images%2Fverify-nineteen.png)





- 在 c = 20 这条记录的二级索引上，加了范围 (15, 20) 的间隙锁。意味着其他事务无法插入 c 值为 16, 17, 18, 19 的这
些新记录，针对是否可以插入c = 15 和 c = 20 的新记录，分析如下：
是否可以插入 c = 15 的新记录，还要看插入的新记录的 id 值，如果插入 c = 15 新记录的 id 值小于 15，那么插入语句会被阻塞，
无法插入，因为此时插入的位置的下一条记录是 id = 15，c = 15 的记录，该记录的二级索引上有间隙锁。如果插入 c = 15 新记录
的 id 值大于 15，也无法插入，因为此时插入的位置的下一条记录是 id = 20，c = 20 的记录，该记录的二级索引上有间隙锁。
- 是否可以插入 c = 20 的新记录，还要看插入的新记录的 id 值，从 LOCK_DATA : 20, 20 可以得知，其他事务插入 c 值
为 20 的新记录时，如果插入的新记录的 id 值小于 20，那么插入语句会发生阻塞，如果插入的新记录的 id 大于 20，则可以插入成功。





![verify-twenty.png](images%2Fverify-twenty.png)





同时，事务 A  还对主键索引（INDEX_NAME: PRIMARY ）加了X 型的记录锁：
- 在 id = 15 这条记录的主键索引上，加了记录锁，意味着其他事务无法更新或者删除 id = 15 的这一行记录。


**那么，为什么这个案例中，需要在二级索引索引上加范围 (15, 20) 的间隙锁？**
要找到这个问题的答案，我们要明白 MySQL 在可重复读的隔离级别场景下，为什么要引入间隙锁？其实是为了避免幻读现象的发生。

如果事务 A 不在二级索引索引上加范围 (15, 20) 的间隙锁，只在二级索引索引上加范围为 (10, 15] 的 next-key 锁的话，
那么就会有幻读的问题。
如果只在在非唯一索引上加了范围为 (10, 15] 的 next-key 锁，是无法完全锁住 c = 15 新记录的插入，因为对于是否可以
插入 c = 15 的新记录，还要看插入的新记录的 id 值，从 LOCK_DATA : 15, 15 可以得知，其他事务插入 c 值为 15 的
新记录时，如果插入的新记录的 id 值小于 15， 那么插入语句会发生阻塞，如果插入的新记录的 id 值大于 15，则可以插入成功。
也就是说，只在二级索引索引（非唯一索引）上加范围为 (10, 15] 的 next-key 锁，其他事务是有可能插入 c 值为 15 的新记录的
（比如插入一个 c = 15，id = 17 的新记录），那么如果事务 A 再一次查询 c= 15 的记录的时候，前后两次查询 c = 15 的结果集
就不一样了，这时就发生了幻读的现象。
那么当在 c = 20 这条记录的二级索引索引上加了范围为 (15, 20) 的间隙锁后，其他事务是无法插入一个 c = 15，id = 17 的新记录，
因为当其他事务插入一条 c = 15，id = 17 的新记录的时候，在二级索引树上定位到插入的位置，而该位置的下一条是 id = 20、c = 20 
的记录，正好该记录的二级索引上有间隙锁，所以这条插入语句会被阻塞，无法插入成功，这样就避免幻读现象的发生。
所以，为了避免幻读现象的发生，就需要在二级索引索引上加范围 (15, 20) 的间隙锁。


## case 15 非唯一索引范围查询且查询的记录存在

```sql
select * from t where c>=10;
```





![verify-twentyone.png](images%2Fverify-twentyone.png)


![verify-twentytwo.png](images%2Fverify-twentytwo.png)

![verify-twentythree.png](images%2Fverify-twentythree.png)





可见，最终的加锁结果是字段c的(5,10]，(10,15], (15,20], (20, 25]以及(25, +无穷大]的next-key lock以及对
主键索引id=10, 15, 20, 25四行加record lock，也就是记录锁。

在 c >= 10 的范围查询中，明明查询 c = 10 的记录存在并且属于等值查询，为什么不会像唯一索引那样，将 c = 10 
记录的二级索引上的 next-key 锁退化为记录锁？
因为 c 字段是非唯一索引，不具有唯一性，所以如果只加记录锁（记录锁无法防止插入，只能防止删除或者修改），就会导致
其他事务插入一条 c = 10 的记录，这样前后两次查询的结果集就不相同了，会出现了幻读的问题。


# 5 总结

可重复读隔离级别遵循两阶段锁协议，所有加锁的资源，都是在事务提交或回滚时才释放的。
next-key lock实际上是由间隙锁(gap lock)加行锁(record lock)实现的。如果切换到读提交隔离级别(rc)的话，就会去掉间隙锁，只剩下行锁部分。
当然，读提交隔离级别在外键场景下还是有间隙锁。
另外，在读提交隔离级别下还有一个优化，即语句执行过程中加上的行锁，在语句执行完成后，就会把不满足条件的行上的行锁直接释放了，不需要等到事务提交。
换句话说，读提交隔离级别下，锁的范围更小，锁的时间更短，这也是不少业务都默认使用读提交隔离级别的原因。

加next-key lock，是先加间隙锁，然后加行锁。间隙锁(gap lock)和行锁(record lock)不同，跟间隙锁存在冲突关系的，
是往这个间隙中插入一个记录这个操作，间隙锁之间是不存在冲突关系的。