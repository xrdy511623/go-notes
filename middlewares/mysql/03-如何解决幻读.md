
---
如何解决幻读？
---

1. 幻读仅专指“新插入的行”。
2. 在可重复读隔离级别下，普通的查询是快照读，是不会看到别的事务插入的数据的。因此，幻读在“当前读”下才会出现。
3. 但如果另一事务插入了一行数据，然后普通查询语句所在的事务又对这行数据进行了修改操作，那么下次执行普通查询语句就会出现幻读，会读到别的事务插入的数据。

一般情况下，普通的查询，也就是快照读不会出现幻读问题，这个是通过MVCC(多版本并发控制)来解决的，详情参见MVCC详解 





![snapshot-read.png](images%2Fsnapshot-read.png)





但是，某些特殊情况下快照读也会出现幻读，例如下面这个案例。





![illusion-read.png](images%2Fillusion-read.png)





可见，即使引入了间隙锁，幻读的问题也没有被完全解决。

即使把所有的记录都加上锁，还是阻止不了新插入的记录，这也是为什么“幻读”会被单独拿出来解决的原因。

# 如何解决幻读？

产生幻读的原因是，行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的“间隙”。因此，为了解决幻读问题，
InnoDB 只好引入新的锁，也就是间隙锁 (Gap Lock)。 顾名思义，间隙锁，锁的就是两个值之间的空隙。比如文章开头
的表 t，初始化插入了 6 个记录，这就产生了 7 个间隙。





![gap-lock-demo.png](images%2Fgap-lock-demo.png)





这样，当你执行 select * from t where d=5 for update 的时候，就不止是给数据库中已有的 6 个记录加上了行锁，
还同时加了 7 个间隙锁。这样就确保了无法再插入新的记录。
也就是说这时候，在一行行扫描的过程中，不仅将给行加上了行锁，还给行两边的空隙，也加上了间隙锁。

但是，千万需要注意的是，跟行锁有冲突关系的是“另外一个行锁”。
但间隙锁不一样，跟间隙锁存在冲突关系的，是“往这个间隙中插入一个记录”这个操作。间隙锁之间都不存在冲突关系。

比如，下面这个案例：





![gap-lock-two.png](images%2Fgap-lock-two.png)





这里 session B 并不会被堵住。因为表 t 里并没有 c=7 这个记录，因此 session A 加的是间隙锁 (5,10)。而
session B 也是在这个间隙加的间隙锁。它们有共同的目标，即：保护这个间隙，不允许插入值。但，它们之间是不冲突的。





![verify-twentyfour.png](images%2Fverify-twentyfour.png)





间隙锁和行锁合称 next-key lock，每个 next-key lock 是前开后闭区间。也就是说，我们的表 t 初始化以后，如果用
select * from t for update 要把整个表所有记录锁起来，就形成了 7 个 next-key lock，分别是 (-∞,0]、(0,5]、
(5,10]、(10,15]、(15,20]、(20, 25]、(25, +supremum]。
间隙锁和 next-key lock 的引入，帮我们解决了幻读的问题，但同时也带来了一些“困扰”。





![dead-lock.png](images%2Fdead-lock.png)





你看到了，这里形成死锁了。我们按语句执行顺序来分析一下：
1. session A 执行 select … for update 语句，由于 id=9 这一行并不存在，因此会加上间隙锁 (5,10);
2. session B 执行 select … for update 语句，同样会加上间隙锁 (5,10)，间隙锁之间不会冲突，因此这个语句可以执行成功；
3. session B 试图插入一行 (9,9,9)，被 session A 的间隙锁挡住了，只好进入等待；
4. session A 试图插入一行 (9,9,9)，被 session B 的间隙锁挡住了。
至此，两个 session 进入互相等待状态，形成死锁。当然，InnoDB 的死锁检测马上就发现了这对死锁关系，让 session A 
的 insert 语句报错返回了。

可以看到，间隙锁的引入，可能会导致同样的语句锁住更大的范围，这其实是影响了并发度的。

间隙锁是在可重复读隔离级别下才会生效的。所以，你如果把隔离级别设置为读提交的话，就没有间隙锁了。但同时，你要解决可能
出现的数据和日志不一致问题，需要把 binlog 格式设置为 row。这，也是现在不少公司使用的配置组合。