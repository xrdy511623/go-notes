
---
全局锁、表级锁和行级锁
---

# 1 全局锁

要使用全局锁，则要执行这条命令：

```sql
flush tables with read lock
```

执行后，整个数据库就处于只读状态了，这时其他线程执行以下操作，都会被阻塞：
- 对数据的增删改操作，比如 insert、delete、update等语句；
- 对表结构的更改操作，比如 alter table、drop table 等语句。

如果要释放全局锁，则要执行这条命令：

```sql
unlock tables
```

当然，当会话断开了，全局锁会被自动释放。

> 全局锁应用场景是什么？

全局锁主要应用于做全库逻辑备份，这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。

> 加全局锁又会带来什么缺点呢？

加上全局锁，意味着整个数据库都是只读状态。
那么如果数据库里有很多数据，备份就会花费很多的时间，关键是备份期间，业务只能读数据，而不能更新数据，这样会造成业务停滞。

> 那么有办法解决吗？

有的，如果数据库的引擎支持的事务支持可重复读的隔离级别，那么在备份数据库之前先开启事务，会先创建 Read View，然后整个事务
执行期间都在用这个 Read View，而且由于 MVCC 的支持，备份期间业务依然可以对数据进行更新操作。
因为在可重复读的隔离级别下，即使其他事务更新了表的数据，也不会影响备份数据库时的 Read View，这就是事务四大特性中的隔离性，
这样备份期间备份的数据一直是在开启事务时的数据。
备份数据库的工具是 mysqldump，在使用 mysqldump 时加上 –single-transaction 参数的时候，就会在备份数据库之前先开启
事务。这种方法只适用于支持「可重复读隔离级别的事务」的存储引擎。
InnoDB 存储引擎默认的事务隔离级别正是可重复读，因此可以采用这种方式来备份数据库。
但是，对于 MyISAM 这种不支持事务的引擎，在备份数据库时就要使用全局锁的方法。


# 2 表级锁

MySQL 表级锁有哪些？具体怎么用的？
MySQL 里面表级别的锁有这几种：
> 表锁；
> 元数据锁（MDL）;
> 意向锁；
> AUTO-INC 锁；

## 2.1 表锁
如果我们想对学生表（t_student）加表锁，可以使用下面的命令：

```sql
//表级别的共享锁，也就是读锁；
lock tables t_student read;

//表级别的独占锁，也就是写锁；
lock tables t_stuent write;
```

需要注意的是，表锁除了会限制别的线程的读写外，也会限制本线程接下来的读写操作。
也就是说如果本线程对学生表加了「共享表锁」，那么本线程接下来如果要对学生表执行写操作的语句，是会被阻塞的，当然其他线程
对学生表进行写操作时也会被阻塞，直到锁被释放。
要释放表锁，可以使用下面这条命令，会释放当前会话的所有表锁：

```sql
unlock tables
```

另外，当会话退出后，也会释放所有表锁。
不过要尽量避免在使用 InnoDB 引擎的表使用表锁，因为表锁的颗粒度太大，会影响并发性能，InnoDB 存储引擎优秀的地方在于实现了
颗粒度更细地行级锁。


## 2.2 元数据锁(MDL锁)
再来说说元数据锁（MDL）。
我们不需要显示的使用 MDL，因为当我们对数据库表进行操作时，会自动给这个表加上 MDL：
- 对一张表进行增删改查(CRUD) 操作时，加的是 MDL 读锁；
- 对一张表做结构变更操作的时候，加的是 MDL 写锁；
MDL 是为了保证当用户对表执行 CRUD 操作时，防止其他线程对这个表结构做了变更。
当有线程在执行 select 语句（ 加 MDL 读锁）的期间，如果有其他线程要更改该表的结构（ 申请 MDL 写锁），那么将会被阻塞，
直到执行完 select 语句（ 释放 MDL 读锁）。
反之，当有线程对表结构进行变更（ 加 MDL 写锁）的期间，如果有其他线程执行了 CRUD 操作（ 申请 MDL 读锁），那么就会被
阻塞，直到表结构变更完成（ 释放 MDL 写锁）。


> MDL 锁不需要显示调用，那它是在什么时候释放的?

MDL锁在事务提交后才会释放，这意味着在事务执行期间，MDL锁是一直持有的。
那如果数据库有一个长事务（所谓的长事务，就是开启了事务，但是一直还没提交），那在对表结构做变更操作的时候，可能会发生意想不到
的事情，比如下面这个顺序的场景：
1. 首先，线程 A 先启用了事务（但是一直不提交），然后执行一条 select 语句，此时就先对该表加上 MDL 读锁；
2. 然后，线程 B 也执行了同样的 select  语句，此时并不会阻塞，因为「读读」并不冲突；
3. 接着，线程 C 修改了表字段，此时由于线程 A 的事务并没有提交，也就是 MDL 读锁还在占用着，这时线程 C 就
无法申请到 MDL 写锁，就会被阻塞，
那么在线程 C 阻塞后，后续所有对该表的 select 语句，就都会被阻塞，如果此时有大量该表的 select 语句的请求到来，就会有大量的
线程被阻塞住，这时数据库的线程很快就会爆满了。


为什么线程 C 因为申请不到 MDL 写锁，而导致后续的申请读锁的查询操作也会被阻塞？

这是因为申请 MDL 锁的操作会形成一个队列，队列中写锁获取优先级高于读锁，一旦出现 MDL 写锁等待，会阻塞后续该表的所有 CRUD 操作。
所以为了能安全的对表结构进行变更，在对表结构变更前，先要看看数据库中的长事务，是否有事务已经对表加上了 MDL 读锁，如果
可以的话，应该 kill 掉这个长事务，然后再做表结构的变更。

因此，对于高并发场景下，用户不可避免的是对数据表进行频繁的CRUD操作，也就是很多线程都会给表加 MDL 读锁，如果此时
需要对数据表结构进行变更(加新的索引或者字段，譬如状态字段之类的)，那就意味着需要给表加 MDL 写锁，而写锁具有更高的优先级，
后续的读锁申请（CRUD 操作）就会会被阻塞，数据库的线程很快就会爆满了，导致整个表的并发操作停滞。

如何应对呢？

> 避免长事务

在高并发场景中，避免长事务对表加锁是关键。
定期检查并清理未提交的事务，尤其是对关键表有影响的长事务。
可以通过以下 SQL 检查长事务：

```sql
SELECT * FROM information_schema.innodb_trx;
```

找到长时间运行的事务并使用 KILL 终止。

> 表结构变更的低影响方法

**复制表策略**
创建新表，按目标结构重新建表。
将旧表数据迁移到新表中。
在低流量时段切换表（例如通过 RENAME TABLE）。

**在线 DDL 工具**
使用工具如 Percona Toolkit 或 gh-ost。
它们通过将表操作拆分为小事务，避免长时间持有 MDL 写锁。

**分库分表或分区表设计**
将热点数据分布到多个表中，降低单表操作的频率。
在变更单个分区或表时，避免对全局系统产生影响。


如果是特别频繁的系统更新需求，可能需要考虑更灵活的数据库架构，比如 NoSQL 数据库，或者在业务逻辑中增加冗余字段
以减少表结构变更的频率。

![long-transaction.png](images%2Flong-transaction.png)



> 下面再展开讲讲常用的在线 DDL 工具

**Percona Toolkit 的使用示例**
Percona Toolkit 中的 pt-online-schema-change 工具通过以下步骤实现在线表结构变更：

创建一个与目标表结构一致的中间表。
逐步将数据从旧表拷贝到中间表。
记录旧表上的数据变化（使用触发器）。
完成数据迁移后，原子性替换旧表。

示例：为一张表添加新字段
假设有一张表 users，需要添加一个 status 字段：

```shell
pt-online-schema-change --alter "ADD COLUMN status VARCHAR(20) DEFAULT 'active'" --execute D=hiring,t=users
```

关键参数解释：
--alter：指定变更的内容。
--execute：执行操作（如果不加此参数，则只会进行模拟操作）。
D：数据库名。
t：表名。
工具的内部工作机制：
创建临时表 users_new，结构与原表 users 相同。
在 users_new 上添加 status 字段。
将旧表 users 的数据逐行拷贝到 users_new。
创建触发器捕获旧表数据的插入、更新和删除操作。
拷贝完成后，原子性地将 users_new 替换为 users。


**gh-ost 的使用示例**
gh-ost 是 GitHub 开发的轻量级在线表结构变更工具，专为 MySQL 高并发场景设计。它的核心原理与 pt-online-schema-change 
类似，但实现更高效：

核心特点：
使用 binlog 捕获数据变更，无需触发器。
变更操作完全以非阻塞方式执行。

示例：为一张表添加新字段
假设有一张表 users，需要添加 status 字段：

```shell
gh-ost --user="root" \
       --password="password" \
       --host="127.0.0.1" \
       --database="hiring" \
       --table="users" \
       --alter="ADD COLUMN status VARCHAR(20) DEFAULT 'active'" \
       --execute
```

关键参数解释：
--alter：指定变更的内容。
--execute：执行操作。
--user 和 --password：MySQL 用户名和密码。
--host：数据库主机地址。
--database 和 --table：指定数据库和表。
工具的内部工作机制：
在主库创建一张临时表 users_ghost。
在临时表上应用 ADD COLUMN status。
使用 binlog 实时捕获 users 表的数据变化。
逐行迁移数据到 users_ghost。
数据迁移完成后，原子性地切换表，将 users_ghost 替换为 users。


![ddl-tools.png](images%2Fddl-tools.png)


> 注意事项

执行前的准备：
确保表有主键或唯一索引（两种工具都要求）。
检查表的大小，预估操作时间。
在非高峰时段进行操作。

监控变更过程：
两种工具都会提供实时日志，显示迁移进度。
注意观察数据库的性能指标，避免对业务产生影响。

失败回滚：
两种工具均支持中断操作并回滚到原始状态。

> 小结

使用 Percona Toolkit 或 gh-ost 可以在高并发场景中有效避免 MDL 写锁阻塞问题。
如果你的环境有 MySQL 主从架构，且表较大，建议使用 gh-ost，它性能更优且对业务影响更小。
在正式操作前，一定要在测试环境中验证变更策略，避免对生产环境产生不可预料的影响。


## 2.3 意向锁

接着，说说意向锁。
- 在使用 InnoDB 引擎的表里对某些记录加上「共享锁」之前，需要先在表级别加上一个「意向共享锁」；
- 在使用 InnoDB 引擎的表里对某些纪录加上「独占锁」之前，需要先在表级别加上一个「意向独占锁」；
也就是，当执行插入、更新、删除操作，需要先对表加上「意向独占锁」，然后对该记录加独占锁。
而普通的 select 是不会加行级锁的，普通的 select 语句是利用 MVCC 实现一致性读，是无锁的。
不过，select 也是可以对记录加共享锁和独占锁的，具体方式如下：

```sql
//先在表上加上意向共享锁，然后对读取的记录加共享锁
select ... lock in share mode


//先表上加上意向独占锁，然后对读取的记录加独占锁
select ... for update;
```

意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，只会和共享表锁
（lock tables ... read）和独占表锁（lock tables ... write）发生冲突。
表锁和行锁是满足读读共享、读写互斥、写写互斥的。
如果没有「意向锁」，那么加「独占表锁」时，就需要遍历表里所有记录，查看是否有记录存在独占锁，这样效率会很慢。
那么有了「意向锁」，由于在对记录加独占锁前，先会加上表级别的意向独占锁，那么在加「独占表锁」时，直接查该表是否有
意向独占锁，如果有就意味着表里已经有记录被加了独占锁，独占表锁就无法加成功了，这样就不用去遍历表里的记录。
所以，意向锁的目的是为了快速判断表里是否有记录被加锁。


## 2.4 AUTO-INC 锁

表里的主键通常都会设置成自增的，这是通过对主键字段声明 AUTO_INCREMENT 属性实现的。
之后在插入数据时，可以不指定主键的值，数据库会自动给主键赋值递增的值，这主要是通过 AUTO-INC 锁实现的。
AUTO-INC 锁是特殊的表锁机制，锁不是在一个事务提交后才释放，而是在执行完插入语句后就会立即释放。
在插入数据时，会加一个表级别的 AUTO-INC 锁，然后为被 AUTO_INCREMENT 修饰的字段赋值递增的值，等插入语句执行完成后，才会
把 AUTO-INC 锁释放掉。
那么，一个事务在持有 AUTO-INC 锁的过程中，其他事务的如果要向该表插入语句都会被阻塞，从而保证插入数据时，被 
AUTO_INCREMENT 修饰的字段的值是连续递增的。

但是， AUTO-INC 锁在对大量数据进行插入的时候，会影响插入性能，因为另一个事务中的插入会被阻塞。

因此，在 MySQL 5.1.22 版本开始，InnoDB 存储引擎提供了一种轻量级的锁来实现自增。
一样也是在插入数据的时候，会为被 AUTO_INCREMENT 修饰的字段加上轻量级锁，然后给该字段赋值一个自增的值，就把这个轻量级锁
释放了，而不需要等待整个插入语句执行完后才释放锁。
InnoDB 存储引擎提供了个 innodb_autoinc_lock_mode 的系统变量，是用来控制选择用 AUTO-INC 锁，还是轻量级的锁。
- 当 innodb_autoinc_lock_mode = 0，就采用 AUTO-INC 锁，语句执行结束后才释放锁；
- 当 innodb_autoinc_lock_mode = 2，就采用轻量级锁，申请自增主键后就释放锁，并不需要等语句执行后才释放。
- 当 innodb_autoinc_lock_mode = 1：
普通 insert 语句，自增锁在申请之后就马上释放；
类似 insert … select 这样的批量插入数据的语句，自增锁还是要等语句执行结束后才被释放；

- innodb_autoinc_lock_mode = 2 是性能最高的方式，但是当搭配  binlog 的日志格式是 statement 一起使用的时候，
在「主从复制的场景」中会发生数据不一致的问题。
举个例子，考虑下面场景：
  session A 往表 t 中插入了 4 行数据，然后创建了一个相同结构的表 t2，然后两个 session 同时执行向表 t2 中插入数据。
  如果 innodb_autoinc_lock_mode = 2，意味着「申请自增主键后就释放锁，不必等插入语句执行完」。那么就可能出现这样的情况：
- session B 先插入了两个记录，(1,1,1)、(2,2,2)；
- 然后，session A 来申请自增 id 得到 id=3，插入了（3,5,5)；
- 之后，session B 继续执行，插入两条记录 (4,3,3)、 (5,4,4)。
  可以看到，session B 的 insert 语句，生成的 id 不连续。
  当「主库」发生了这种情况，binlog 面对 t2 表的更新只会记录这两个 session 的 insert 语句，如果 binlog_format=statement，
  记录的语句就是原始语句。记录的顺序要么先记 session A 的 insert 语句，要么先记 session B 的 insert 语句。
  但不论是哪一种，这个 binlog 拿去「从库」执行，这时从库是按「顺序」执行语句的，只有当执行完一条 SQL 语句后，才会执行下一条 
  SQL。因此，在从库上「不会」发生像主库那样两个 session 「同时」执行向表 t2 中插入数据的场景。所以，在备库上执行了 session B
  的 insert 语句，生成的结果里面，id 都是连续的。这时，主从库就发生了数据不一致。
  要解决这问题，binlog 日志格式要设置为 row，这样在 binlog 里面记录的是主库分配的自增值，到备库执行的时候，主库的自增值是什么，
  从库的自增值就是什么。

所以，当 innodb_autoinc_lock_mode = 2 时，并且 binlog_format = row，既能提升并发性，又不会出现数据一致性问题。


# 3 行级锁
参见:
- [MySQL行锁实战](MySQL行锁实战.md)

## 3.1 插入意向锁

一个事务在插入一条记录的时候，需要判断插入位置是否已被其他事务加了间隙锁（next-key lock 也包含间隙锁）。
如果有的话，插入操作就会发生阻塞，直到拥有间隙锁的那个事务提交为止（释放间隙锁的时刻），在此期间会生成一个插入
意向锁，表明有事务想在某个区间插入新记录，但是现在处于等待状态。
举个例子，假设事务 A 已经对表加了一个范围 id 为（3，5）间隙锁。

当事务 A 还没提交的时候，事务 B 向该表插入一条 id = 4 的新记录，这时会判断到插入的位置已经被事务 A 加了间隙锁，于是
事务 B 会生成一个插入意向锁，然后将锁的状态设置为等待状态（PS：MySQL 加锁时，是先生成锁结构，然后设置锁的状态，如果
锁状态是等待状态，并不是意味着事务成功获取到了锁，只有当锁状态为正常状态时，才代表事务成功获取到了锁），此时事务 B 就会
发生阻塞，直到事务 A 提交了事务。
插入意向锁名字虽然有意向锁，但是它并不是意向锁，它是一种特殊的间隙锁，属于行级别锁。
如果说间隙锁锁住的是一个区间，那么「插入意向锁」锁住的就是一个点。因而从这个角度来说，插入意向锁确实是一种特殊的间隙锁。
插入意向锁与间隙锁的另一个非常重要的差别是：尽管「插入意向锁」也属于间隙锁，但两个事务却不能在同一时间内，一个拥有间隙锁，
另一个拥有该间隙区间内的插入意向锁（当然，插入意向锁如果不在间隙锁区间内则是可以的）。