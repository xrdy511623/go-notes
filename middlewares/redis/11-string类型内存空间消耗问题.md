
---
万⾦油”的String，为什么不好⽤了？
---

# 1 背景

先跟你分享⼀个我曾经遇到的需求。
当时，我们要开发⼀个图⽚存储系统，要求这个系统能快速地记录图⽚ID和图⽚在存储系统中保存时的
ID（可以直接叫作图⽚存储对象ID）。同时，还要能够根据图⽚ID快速查找到图⽚存储对象ID。
因为图⽚数量巨⼤，所以我们就⽤10位数来表⽰图⽚ID和图⽚存储对象ID，例如，图⽚ID为1101000051，
它在存储系统中对应的ID号是3301000051。

可以看到，图⽚ID和图⽚存储对象ID正好⼀⼀对应，是典型的“键-单值”模式。所谓的“单值”，就是指
键值对中的值就是⼀个值，⽽不是⼀个集合，这和String类型提供的“⼀个键对应⼀个值的数据”的保存形
式刚好契合。

⽽且，String类型可以保存⼆进制字节流，就像“万⾦油”⼀样，只要把数据转成⼆进制字节数组，就可以
保存了。

所以，我们的第⼀个⽅案就是⽤String保存数据。我们把图⽚ID和图⽚存储对象ID分别作为键值对的key和
value来保存，其中，图⽚存储对象ID⽤了String类型。

刚开始，我们保存了1亿张图⽚，⼤约⽤了6.4GB的内存。但是，随着图⽚数据量的不断增加，我们的Redis
内存使⽤量也在增加，结果就遇到了⼤内存Redis实例因为⽣成RDB⽽响应变慢的问题。很显然，String类
型并不是⼀种好的选择，我们还需要进⼀步寻找能节省内存开销的数据类型⽅案。

在这个过程中，我深⼊地研究了String类型的底层结构，找到了它内存开销⼤的原因，对“万⾦油”的
String类型有了全新的认知：String类型并不是适⽤于所有场合的，它有⼀个明显的短板，就是它保存数据
时所消耗的内存空间较多。

同时，我还仔细研究了集合类型的数据结构。我发现，集合类型有⾮常节省内存空间的底层实现结构，但
是，集合类型保存的数据模式，是⼀个键对应⼀系列值，并不适合直接保存单值的键值对。所以，我们就使
⽤⼆级编码的⽅法，实现了⽤集合类型保存单值键值对，Redis实例的内存空间消耗明显下降了。


# 2 为什么String类型内存开销⼤？

在刚才的案例中，我们保存了1亿张图⽚的信息，⽤了约6.4GB的内存，⼀个图⽚ID和图⽚存储对象ID的记
录平均⽤了64字节。

但问题是，⼀组图⽚ID及其存储对象ID的记录，实际只需要16字节就可以了。

我们来分析⼀下。图⽚ID和图⽚存储对象ID都是10位数，我们可以⽤两个8字节的Long类型表⽰这两个ID。
因为8字节的Long类型最⼤可以表⽰2的64次⽅的数值，所以肯定可以表⽰10位数。但是，为什么String类
型却⽤了64字节呢？

其实，除了记录实际数据，String类型还需要额外的内存空间记录数据⻓度、空间使⽤等信息，这些信息也
叫作元数据。当实际保存的数据较⼩时，元数据的空间开销就显得⽐较⼤了，有点“喧宾夺主”的意思。

我们前面讲redis底层数据结构时提到过，当你保存64位有符号整数时，String类型会把它保存为⼀个8字节的Long类型整数，
这种保存⽅式通常也叫作int编码⽅式。

另外，对于String类型来说，除了SDS的额外开销，还有⼀个来⾃于RedisObject结构体的开销。
因为Redis的数据类型有很多，⽽且，不同数据类型都有些相同的元数据要记录（⽐如最后⼀次访问的时
间、被引⽤的次数等），所以，Redis会⽤⼀个RedisObject结构体来统⼀记录这些元数据，同时指向实际数
据。

```C
typedef struct redisObject {
    unsigned type:4;      // 对象类型（String/List/Hash/Set/ZSet），4 bit
    unsigned encoding:4;  // 底层编码方式，4 bit
    unsigned lru:24;      // LRU/LFU 时间戳，24 bit（共 4 字节）
    int refcount;         // 引用计数，4 字节
    void *ptr;            // 指向底层数据结构的指针，8 字节
} robj;                   // 总共 16 字节
```

⼀个RedisObject包含了8字节的元数据（type + encoding + lru + refcount）和⼀个8字节指针（ptr），这个指针再进⼀步指向具体数据类型的实际数据所在。

为了节省内存空间，Redis还对Long类型整数和SDS的内存布局做了专⻔的设计，String 类型共有**三种编码方式**：

**1. int 编码**：当保存的是Long类型整数（≤ 2^63 - 1）时，RedisObject中的指针就直接赋值为整数数据了，这样就不⽤额外的指针再指向整数了，节省了指针的空间开销。此时整个 RedisObject 只占 **16 字节**。

**2. embstr 编码**：当保存的字符串长度 ≤ 44 字节时，Redis 将 RedisObject 和 SDS 分配在一块**连续的内存**中。这样只需一次内存分配，且数据局部性好，对 CPU 缓存友好。总占用 = 16（RedisObject）+ 3（SDS 头：len + alloc + flags）+ 字符串长度 + 1（\0），jemalloc 会向上对齐到 64 字节。

**3. raw 编码**：当保存的字符串长度 > 44 字节时，RedisObject 的 ptr 指针指向独立分配的 SDS。此时需要**两次内存分配**（RedisObject 一次、SDS 一次），且存在指针跳转开销。

> **为什么 embstr 的阈值是 44 字节？** 因为 jemalloc 最小分配单位为 64 字节。64 - 16（RedisObject）- 3（SDS 头 sdshdr8）- 1（\0 结束符）= 44 字节，刚好充分利用一个 64 字节的 jemalloc 分配单元。

好了，知道了RedisObject所包含的额外元数据开销，现在，我们就可以计算String类型的内存使⽤量了。

因为10位数的图⽚ID和图⽚存储对象ID是Long类型整数，所以可以直接⽤int编码的RedisObject保存。每
个int编码的RedisObject元数据部分占8字节，指针部分被直接赋值为8字节的整数了。此时，每个ID会使⽤
16字节，加起来⼀共是32字节。但是，另外的32字节去哪⼉了呢？

前面讲过，Redis会使⽤⼀个全局哈希表保存所有键值对，哈希表的每⼀项是⼀个dictEntry的结构
体，⽤来指向⼀个键值对。dictEntry结构中有三个8字节的指针，分别指向key、value以及下⼀个
dictEntry，三个指针共24字节。

但是，这三个指针只有24字节，为什么会占⽤了32字节呢？这就要提到Redis使⽤的内存分配库jemalloc了。

jemalloc在分配内存时，会根据我们申请的字节数N， 找⼀个⽐N⼤，但是最接近N的2的幂次数作为分配的
空间，这样可以减少频繁分配的次数。

举个例⼦。如果你申请6字节空间，jemalloc实际会分配8字节空间；如果你申请24字节空间，jemalloc则
会分配32字节。所以，在我们刚刚说的场景⾥，dictEntry结构就占⽤了32字节。加上前面的图⽚ID和图⽚存储对象ID
都采用int编码的RedisObject一共占用32字节，所以总共是32+32=64字节。

你看，明明有效信息只有16字节，使⽤String类型保存时，却需要64字节的内存空间，有48字节都没有⽤于
保存实际的数据。我们来换算下，如果要保存的图⽚有1亿张，那么1亿条的图⽚ID记录就需要6.4GB内存空
间，其中有4.8GB的内存空间都⽤来保存元数据了，额外的内存空间开销很⼤。那么，有没有更加节省内存
的⽅法呢？


# 3 ⽤什么数据结构可以节省内存？

我们知道，Redis有⼀种底层数据结构，叫压缩列表（ziplist），这是⼀种⾮常节省内存的结构。

压缩列表之所以能节省内存，就在于它是⽤⼀系列连续的entry保存数据。每个entry的元数据包括下⾯⼏部分。

prev_len，表⽰前⼀个entry的⻓度。prev_len有两种取值情况：1字节或5字节。取值1字节时，表⽰上
⼀个entry的⻓度⼩于254字节。虽然1字节的值能表⽰的数值范围是0到255，但是压缩列表中zlend的取
值默认是255，因此，就默认⽤255表⽰整个压缩列表的结束，其他表⽰⻓度的地⽅就不能再⽤255这个值
了。所以，当上⼀个entry⻓度⼩于254字节时，prev_len取值为1字节，否则，就取值为5字节。

len：表⽰⾃⾝⻓度，4字节；

encoding：表⽰编码⽅式，1字节；

content：保存实际数据。

这些entry会挨个⼉放置在内存中，不需要再⽤额外的指针进⾏连接，这样就可以节省指针所占⽤的空间。
我们以保存图⽚存储对象ID为例，来分析⼀下压缩列表是如何节省内存空间的。

每个entry保存⼀个图⽚存储对象ID（8字节），此时，每个entry的prev_len只需要1个字节就⾏，因为每个
entry的前⼀个entry⻓度都只有8字节，⼩于254字节。这样⼀来，⼀个图⽚的存储对象ID所占⽤的内存⼤⼩
是14字节（1+4+1+8=14），实际分配16字节。

Redis基于压缩列表实现了List、Hash和Sorted Set这样的集合类型，这样做的最⼤好处就是节省了
dictEntry的开销。当你⽤String类型时，⼀个键值对就有⼀个dictEntry，要⽤32字节空间。但采⽤集合类
型时，⼀个key就对应⼀个集合的数据，能保存的数据多了很多，但也只⽤了⼀个dictEntry，这样就节省了
内存。

这个⽅案听起来很好，但还存在⼀个问题：在⽤集合类型保存键值对时，⼀个键对应了⼀个集合的数据，但
是在我们的场景中，⼀个图⽚ID只对应⼀个图⽚的存储对象ID，我们该怎么⽤集合类型呢？换句话说，在⼀
个键对应⼀个值（也就是单值键值对）的情况下，我们该怎么⽤集合类型来保存这种单值键值对呢？


# 4 如何⽤集合类型保存单值的键值对？

在保存单值的键值对时，可以采⽤基于Hash类型的⼆级编码⽅法。这⾥说的⼆级编码，就是把⼀个单值的
数据拆分成两部分，前⼀部分作为Hash集合的key，后⼀部分作为Hash集合的value，这样⼀来，我们就可
以把单值数据保存到Hash集合中了。

以图⽚ID 1101000060和图⽚存储对象ID 3302000080为例，我们可以把图⽚ID的前7位（1101000）作为
Hash类型的键，把图⽚ID的最后3位（060）和图⽚存储对象ID分别作为Hash类型值中的field和value。
按照这种设计⽅法，我在Redis中插⼊了两组图⽚ID及其存储对象ID的记录，并且⽤info命令查看了内存开
销，我发现，增加第二条记录后，内存占⽤只增加了16字节，如下所⽰：

```shell
info memory
# Memory
used_memory:1160320

hset 1101000 060 3302000080
(integer) 1
127.0.0.1:6379> info memory
# Memory
used_memory:1160416

hset 1101000 070 3302000090
(integer) 1
127.0.0.1:6379> info memory
# Memory
used_memory:1160432
```

下面分析第一条 `hset 1101000 060 3302000080` 的内存开销：

| 组成部分 | 计算过程 | 实际分配 |
|---------|---------|---------|
| **哈希键 RedisObject** | 1101000 是 Long 整数，int 编码，元数据 8B + 指针直存整数 8B = 16B | 16 字节 |
| **dictEntry** | 3 个指针 × 8B = 24B | 32 字节（jemalloc 对齐） |
| **ziplist 头** | zlbytes(4B) + zltail(4B) + zllen(2B) + zlend(1B) = 11B | 16 字节（jemalloc 对齐） |
| **entry: field "060"** | prevlen(1B) + encoding(1B) + content(3B) = 5B | 与 ziplist 连续分配 |
| **entry: value "3302000080"** | prevlen(1B) + encoding(1B) + content(10B) = 12B | 与 ziplist 连续分配 |
| **ziplist 总体** | 11 + 5 + 12 = 28B | 32 字节（jemalloc 对齐） |

> 注：ziplist 是一块连续内存，头部和所有 entry 在同一个分配块内。28B 会被 jemalloc 对齐到 32B。

第一条记录总开销：16（RedisObject）+ 32（dictEntry）+ 32（ziplist）= **80 字节**。实际 `info memory` 显示增加了 96 字节，多出的 16 字节来自 Redis 内部的 dict 哈希表扩容和内存对齐开销。

执行第二条 `hset 1101000 070 3302000090` 时：
- 哈希键 `1101000` 已存在，**复用**，不新增开销
- dictEntry 已存在，**复用**
- 只需在已有 ziplist 中追加两个 entry（field + value），通过 `realloc` 扩展 ziplist

新增的两个 entry 大小为 5 + 12 = 17 字节，ziplist 从 32B 扩展到约 48B（jemalloc 对齐），实际增量约 **16 字节**，与 `info memory` 的观察一致。

在使⽤String类型时，每个记录需要消耗64字节，这种⽅式却只⽤了16字节，所使⽤的内存空间是原来的
1/4，满⾜了我们节省内存空间的需求。

不过，你可能也会有疑惑：“⼆级编码⼀定要把图⽚ID的前7位作为Hash类型的键，把最后3位作为Hash类
型值中的key吗？”其实，⼆级编码⽅法中采⽤的ID⻓度是有讲究的。

我们知道，Redis Hash类型的两种底层实现结构，分别是压缩列表和哈希表。

那么，Hash类型底层结构什么时候使⽤压缩列表，什么时候使⽤哈希表呢？其实，Hash类型设置了⽤压缩
列表保存数据时的两个阈值，⼀旦超过了阈值，Hash类型就会⽤哈希表来保存数据了。

这两个阈值分别对应以下两个配置项：

hash-max-ziplist-entries：表⽰⽤压缩列表保存时哈希集合中的最⼤元素个数。
hash-max-ziplist-value：表⽰⽤压缩列表保存时哈希集合中单个元素的最⼤⻓度。

如果我们往Hash集合中写⼊的元素个数超过了hash-max-ziplist-entries，或者写⼊的单个元素⼤⼩超过了
hash-max-ziplist-value，Redis就会⾃动把Hash类型的实现结构由压缩列表转为哈希表。
⼀旦从压缩列表转为了哈希表，Hash类型就会⼀直⽤哈希表进⾏保存，⽽不会再转回压缩列表了。在节省
内存空间⽅⾯，哈希表就没有压缩列表那么⾼效了。

为了能充分使⽤压缩列表的精简内存布局，我们⼀般要控制保存在Hash集合中的元素个数。所以，在刚才
的⼆级编码中，我们只⽤图⽚ID最后3位作为Hash集合的key，也就保证了Hash集合的元素个数不超过
1000，同时，我们把hash-max-ziplist-entries设置为1000，这样⼀来，Hash集合就可以⼀直使⽤压缩列表
来节省内存空间了。


# 5 ⽤集合类型保存单值的键值对会有什么缺点？

一是查询时间复杂度由O(1)下降为O(N)，查询效率下降，但如果集合中元素数量比较少，那么影响还是可控的。

当使⽤Hash并且底层采⽤ziplist⽅式存储时，虽然可以节省内存空间，但是在查询指定元素时，都要遍历整个
ziplist，找到指定的元素。所以使⽤压缩列表⽅式存储时，虽然可以利⽤CPU⾼速缓存，但也不适合存储过多的数据
（hash-max-ziplist-entries和zset-max-ziplist-entries不宜设置过⼤），否则查询性能就会下降⽐较厉害。
整体来说，这样的⽅案就是时间换空间，我们需要权衡使⽤。

二是设置过期变得困难。

因为是单个键对集合，所以⽆法控制每个元素的过期，只能整个key设置过期，或者业务层单独维护每个元素过期删除的逻辑，
这样会⽐较复杂，⽽使⽤String虽然占⽤内存多，但是每个key都可以单独设置过期时间，还可以设置maxmemory和淘汰策略
，以这种⽅式控制整个实例的内存上限。

三是 Hash 集合中的 field 无法单独设置 TTL，也无法使用 `SETNX`、`INCR` 等 String 专属命令。如果业务需要对单个键值对做原子递增或分布式锁等操作，二级编码方案就不适用了。


# 6 总结

| 主题 | 核心要点 |
|------|---------|
| String 内存开销 | 一个 key-value 至少占 dictEntry(32B) + key RedisObject(16B) + value RedisObject(16B) = 64B，有效数据可能只有 16B |
| RedisObject 结构 | 16 字节（type 4bit + encoding 4bit + lru 24bit + refcount 4B + ptr 8B） |
| String 三种编码 | int（≤ 2^63-1 整数，16B）、embstr（≤ 44B 字符串，一次分配 64B）、raw（> 44B，两次分配） |
| jemalloc 对齐 | 按 2 的幂次分配（8/16/32/64/...），会产生内部碎片 |
| 二级编码方案 | 将单值 key 拆分为 Hash 的 key + field，利用 ziplist 压缩存储，节省 dictEntry 开销 |
| ziplist 阈值 | `hash-max-ziplist-entries`（默认 512）和 `hash-max-ziplist-value`（默认 64B），超过则转为哈希表 |
| 二级编码代价 | 查询 O(N) 而非 O(1)、无法对单元素设置过期、不支持 String 专属命令 |

**选型建议**：

| 场景 | 推荐方案 |
|------|---------|
| 海量小 key-value（如 ID 映射），内存敏感 | Hash 二级编码 + ziplist |
| 需要单 key 过期、原子操作（INCR/SETNX） | String 类型 |
| 单 key 值较大（> 几百字节） | String 类型（ziplist 节省效果不明显） |
| key 数量不多（< 百万级），内存充足 | String 类型（简单优先） |