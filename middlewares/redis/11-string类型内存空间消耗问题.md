
---
万⾦油”的String，为什么不好⽤了？
---

# 1 背景

先跟你分享⼀个我曾经遇到的需求。
当时，我们要开发⼀个图⽚存储系统，要求这个系统能快速地记录图⽚ID和图⽚在存储系统中保存时的
ID（可以直接叫作图⽚存储对象ID）。同时，还要能够根据图⽚ID快速查找到图⽚存储对象ID。
因为图⽚数量巨⼤，所以我们就⽤10位数来表⽰图⽚ID和图⽚存储对象ID，例如，图⽚ID为1101000051，
它在存储系统中对应的ID号是3301000051。

可以看到，图⽚ID和图⽚存储对象ID正好⼀⼀对应，是典型的“键-单值”模式。所谓的“单值”，就是指
键值对中的值就是⼀个值，⽽不是⼀个集合，这和String类型提供的“⼀个键对应⼀个值的数据”的保存形
式刚好契合。

⽽且，String类型可以保存⼆进制字节流，就像“万⾦油”⼀样，只要把数据转成⼆进制字节数组，就可以
保存了。

所以，我们的第⼀个⽅案就是⽤String保存数据。我们把图⽚ID和图⽚存储对象ID分别作为键值对的key和
value来保存，其中，图⽚存储对象ID⽤了String类型。

刚开始，我们保存了1亿张图⽚，⼤约⽤了6.4GB的内存。但是，随着图⽚数据量的不断增加，我们的Redis
内存使⽤量也在增加，结果就遇到了⼤内存Redis实例因为⽣成RDB⽽响应变慢的问题。很显然，String类
型并不是⼀种好的选择，我们还需要进⼀步寻找能节省内存开销的数据类型⽅案。

在这个过程中，我深⼊地研究了String类型的底层结构，找到了它内存开销⼤的原因，对“万⾦油”的
String类型有了全新的认知：String类型并不是适⽤于所有场合的，它有⼀个明显的短板，就是它保存数据
时所消耗的内存空间较多。

同时，我还仔细研究了集合类型的数据结构。我发现，集合类型有⾮常节省内存空间的底层实现结构，但
是，集合类型保存的数据模式，是⼀个键对应⼀系列值，并不适合直接保存单值的键值对。所以，我们就使
⽤⼆级编码的⽅法，实现了⽤集合类型保存单值键值对，Redis实例的内存空间消耗明显下降了。


# 2 为什么String类型内存开销⼤？

在刚才的案例中，我们保存了1亿张图⽚的信息，⽤了约6.4GB的内存，⼀个图⽚ID和图⽚存储对象ID的记
录平均⽤了64字节。

但问题是，⼀组图⽚ID及其存储对象ID的记录，实际只需要16字节就可以了。

我们来分析⼀下。图⽚ID和图⽚存储对象ID都是10位数，我们可以⽤两个8字节的Long类型表⽰这两个ID。
因为8字节的Long类型最⼤可以表⽰2的64次⽅的数值，所以肯定可以表⽰10位数。但是，为什么String类
型却⽤了64字节呢？

其实，除了记录实际数据，String类型还需要额外的内存空间记录数据⻓度、空间使⽤等信息，这些信息也
叫作元数据。当实际保存的数据较⼩时，元数据的空间开销就显得⽐较⼤了，有点“喧宾夺主”的意思。

我们前面讲redis底层数据结构时提到过，当你保存64位有符号整数时，String类型会把它保存为⼀个8字节的Long类型整数，
这种保存⽅式通常也叫作int编码⽅式。

另外，对于String类型来说，除了SDS的额外开销，还有⼀个来⾃于RedisObject结构体的开销。
因为Redis的数据类型有很多，⽽且，不同数据类型都有些相同的元数据要记录（⽐如最后⼀次访问的时
间、被引⽤的次数等），所以，Redis会⽤⼀个RedisObject结构体来统⼀记录这些元数据，同时指向实际数
据。

⼀个RedisObject包含了8字节的元数据和⼀个8字节指针，这个指针再进⼀步指向具体数据类型的实际数据
所在。

为了节省内存空间，Redis还对Long类型整数和SDS的内存布局做了专⻔的设计。

当保存的是Long类型整数时，RedisObject中的指针就直接赋值为整数数据了，这样就不⽤额外的
指针再指向整数了，节省了指针的空间开销。

好了，知道了RedisObject所包含的额外元数据开销，现在，我们就可以计算String类型的内存使⽤量了。

因为10位数的图⽚ID和图⽚存储对象ID是Long类型整数，所以可以直接⽤int编码的RedisObject保存。每
个int编码的RedisObject元数据部分占8字节，指针部分被直接赋值为8字节的整数了。此时，每个ID会使⽤
16字节，加起来⼀共是32字节。但是，另外的32字节去哪⼉了呢？

前面讲过，Redis会使⽤⼀个全局哈希表保存所有键值对，哈希表的每⼀项是⼀个dictEntry的结构
体，⽤来指向⼀个键值对。dictEntry结构中有三个8字节的指针，分别指向key、value以及下⼀个
dictEntry，三个指针共24字节。

但是，这三个指针只有24字节，为什么会占⽤了32字节呢？这就要提到Redis使⽤的内存分配库jemall了。

jemalloc在分配内存时，会根据我们申请的字节数N， 找⼀个⽐N⼤，但是最接近N的2的幂次数作为分配的
空间，这样可以减少频繁分配的次数。

举个例⼦。如果你申请6字节空间，jemalloc实际会分配8字节空间；如果你申请24字节空间，jemalloc则
会分配32字节。所以，在我们刚刚说的场景⾥，dictEntry结构就占⽤了32字节。加上前面的图⽚ID和图⽚存储对象ID
都采用int编码的RedisObject一共占用32字节，所以总共是32+32=64字节。

你看，明明有效信息只有16字节，使⽤String类型保存时，却需要64字节的内存空间，有48字节都没有⽤于
保存实际的数据。我们来换算下，如果要保存的图⽚有1亿张，那么1亿条的图⽚ID记录就需要6.4GB内存空
间，其中有4.8GB的内存空间都⽤来保存元数据了，额外的内存空间开销很⼤。那么，有没有更加节省内存
的⽅法呢？


# 3 ⽤什么数据结构可以节省内存？

我们知道，Redis有⼀种底层数据结构，叫压缩列表（ziplist），这是⼀种⾮常节省内存的结构。

压缩列表之所以能节省内存，就在于它是⽤⼀系列连续的entry保存数据。每个entry的元数据包括下⾯⼏部分。

prev_len，表⽰前⼀个entry的⻓度。prev_len有两种取值情况：1字节或5字节。取值1字节时，表⽰上
⼀个entry的⻓度⼩于254字节。虽然1字节的值能表⽰的数值范围是0到255，但是压缩列表中zlend的取
值默认是255，因此，就默认⽤255表⽰整个压缩列表的结束，其他表⽰⻓度的地⽅就不能再⽤255这个值
了。所以，当上⼀个entry⻓度⼩于254字节时，prev_len取值为1字节，否则，就取值为5字节。

len：表⽰⾃⾝⻓度，4字节；

encoding：表⽰编码⽅式，1字节；

content：保存实际数据。

这些entry会挨个⼉放置在内存中，不需要再⽤额外的指针进⾏连接，这样就可以节省指针所占⽤的空间。
我们以保存图⽚存储对象ID为例，来分析⼀下压缩列表是如何节省内存空间的。

每个entry保存⼀个图⽚存储对象ID（8字节），此时，每个entry的prev_len只需要1个字节就⾏，因为每个
entry的前⼀个entry⻓度都只有8字节，⼩于254字节。这样⼀来，⼀个图⽚的存储对象ID所占⽤的内存⼤⼩
是14字节（1+4+1+8=14），实际分配16字节。

Redis基于压缩列表实现了List、Hash和Sorted Set这样的集合类型，这样做的最⼤好处就是节省了
dictEntry的开销。当你⽤String类型时，⼀个键值对就有⼀个dictEntry，要⽤32字节空间。但采⽤集合类
型时，⼀个key就对应⼀个集合的数据，能保存的数据多了很多，但也只⽤了⼀个dictEntry，这样就节省了
内存。

这个⽅案听起来很好，但还存在⼀个问题：在⽤集合类型保存键值对时，⼀个键对应了⼀个集合的数据，但
是在我们的场景中，⼀个图⽚ID只对应⼀个图⽚的存储对象ID，我们该怎么⽤集合类型呢？换句话说，在⼀
个键对应⼀个值（也就是单值键值对）的情况下，我们该怎么⽤集合类型来保存这种单值键值对呢？


# 4 如何⽤集合类型保存单值的键值对？

在保存单值的键值对时，可以采⽤基于Hash类型的⼆级编码⽅法。这⾥说的⼆级编码，就是把⼀个单值的
数据拆分成两部分，前⼀部分作为Hash集合的key，后⼀部分作为Hash集合的value，这样⼀来，我们就可
以把单值数据保存到Hash集合中了。

以图⽚ID 1101000060和图⽚存储对象ID 3302000080为例，我们可以把图⽚ID的前7位（1101000）作为
Hash类型的键，把图⽚ID的最后3位（060）和图⽚存储对象ID分别作为Hash类型值中的field和value。
按照这种设计⽅法，我在Redis中插⼊了两组图⽚ID及其存储对象ID的记录，并且⽤info命令查看了内存开
销，我发现，增加第二条记录后，内存占⽤只增加了16字节，如下所⽰：

```shell
info memory
# Memory
used_memory:1160320

hset 1101000 060 3302000080
(integer) 1
127.0.0.1:6379> info memory
# Memory
used_memory:1160416

hset 1101000 070 3302000090
(integer) 1
127.0.0.1:6379> info memory
# Memory
used_memory:1160432
```

下面简单分析下，执行hset 1101000 060 3302000080时，哈希键是1101000，
是Long类型整数，所以可以直接⽤int编码的RedisObject保存。每个int编码的
RedisObject元数据部分占8字节，指针部分被直接赋值为8字节的整数了。此时，
哈希键1101000会占用16个字节。

然后执行hset 1101000 060 3302000080意味着redis的全局哈希表还要新增
一个键值对，哈希表的每⼀项是⼀个dictEntry的结构体，⽤来指向⼀个键值对。
dictEntry结构中有三个8字节的指针，分别指向key、value以及下⼀个
dictEntry，三个指针共24字节，jemalloc实际会分配32个字节。

060 330200008这个field-value对会使用压缩列表进行存储，所需要的内存开销就是
初始化一个压缩列表和这个field-value对所对应的entry所占用的内存。而根据压缩列表
和entry的数据结构定义，初始化一个压缩列表需要占用的内存是zlbytes，int32类型，
也就是4个字节，zltail_offset，int32类型，也是4个字节，zllength，int16类型，
2个字节，zlend，int8类型，1个字节，一共是4+4+2+1=11个字节，jemalloc实际会分配
16个字节；而field(060)本身也就是content占用3个字节，encoding占用1个字节，prevlen
占用1个字节，总共是3+1+1=5个字节，jemalloc实际会分配8个字节；而value(3302000080)本身
也就是content占用10个字节，encoding占用1个字节，prevlen占用1个字节，总共是10+1+1=12个
字节，jemalloc实际会分配16个字节，所以初始化压缩列表以及在压缩列表中存储两个entry所占
内存空间位16+8+16=40个字节。

因此，执行hset 1101000 060 3302000080一共会占用16+32+40=88个字节的内存，但是
实际占用的内存空间是96字节，也许这里有整理内存碎片或者是内存对齐的缘故？

在执行hset 1101000 070 3302000090时，哈希键1101000可以重用，不需要再新增内存空间，
压缩列表的元数据开销在执行hset 1101000 060时也已经有了，所以此次只会新增070 3302000090
这个field-value对所对应的两个entry的内存空间，显然，这个与060 330200008这个field-value对
所占用的内存空间是一样的，也是8+16=24字节，但是为什么实际只新增了16个字节呢？

那是因为第一次执行hset 1101000 060 3302000080时分配了96个字节，但是实际只需要88个字节，因此
有96-88=8个字节是空闲的，这次要分配24个字节内存时，可以把之前空闲的8字节利用起来，所以本次
只需要分配24-8=16字节。

在使⽤String类型时，每个记录需要消耗64字节，这种⽅式却只⽤了16字节，所使⽤的内存空间是原来的
1/4，满⾜了我们节省内存空间的需求。

不过，你可能也会有疑惑：“⼆级编码⼀定要把图⽚ID的前7位作为Hash类型的键，把最后3位作为Hash类
型值中的key吗？”其实，⼆级编码⽅法中采⽤的ID⻓度是有讲究的。

我们知道，Redis Hash类型的两种底层实现结构，分别是压缩列表和哈希表。

那么，Hash类型底层结构什么时候使⽤压缩列表，什么时候使⽤哈希表呢？其实，Hash类型设置了⽤压缩
列表保存数据时的两个阈值，⼀旦超过了阈值，Hash类型就会⽤哈希表来保存数据了。

这两个阈值分别对应以下两个配置项：

hash-max-ziplist-entries：表⽰⽤压缩列表保存时哈希集合中的最⼤元素个数。
hash-max-ziplist-value：表⽰⽤压缩列表保存时哈希集合中单个元素的最⼤⻓度。

如果我们往Hash集合中写⼊的元素个数超过了hash-max-ziplist-entries，或者写⼊的单个元素⼤⼩超过了
hash-max-ziplist-value，Redis就会⾃动把Hash类型的实现结构由压缩列表转为哈希表。
⼀旦从压缩列表转为了哈希表，Hash类型就会⼀直⽤哈希表进⾏保存，⽽不会再转回压缩列表了。在节省
内存空间⽅⾯，哈希表就没有压缩列表那么⾼效了。

为了能充分使⽤压缩列表的精简内存布局，我们⼀般要控制保存在Hash集合中的元素个数。所以，在刚才
的⼆级编码中，我们只⽤图⽚ID最后3位作为Hash集合的key，也就保证了Hash集合的元素个数不超过
1000，同时，我们把hash-max-ziplist-entries设置为1000，这样⼀来，Hash集合就可以⼀直使⽤压缩列表
来节省内存空间了。


# 5 ⽤集合类型保存单值的键值对会有什么缺点？

一是查询时间复杂度由O(1)下降为O(N)，查询效率下降，但如果集合中元素数量比较少，那么影响还是可控的。

当使⽤Hash并且底层采⽤ziplist⽅式存储时，虽然可以节省内存空间，但是在查询指定元素时，都要遍历整个
ziplist，找到指定的元素。所以使⽤压缩列表⽅式存储时，虽然可以利⽤CPU⾼速缓存，但也不适合存储过多的数据
（hash-max-ziplist-entries和zset-max-ziplist-entries不宜设置过⼤），否则查询性能就会下降⽐较厉害。
整体来说，这样的⽅案就是时间换空间，我们需要权衡使⽤。

二是设置过期变得困难。

因为是单个键对集合，所以⽆法控制每个元素的过期，只能整个key设置过期，或者业务层单独维护每个元素过期删除的逻辑，
这样会⽐较复杂，⽽使⽤String虽然占⽤内存多，但是每个key都可以单独设置过期时间，还可以设置maxmemory和淘汰策略
，以这种⽅式控制整个实例的内存上限。