
---
AOF⽇志：宕机了，Redis如何避免数据丢失？
---

如果有⼈问你：“你会把Redis⽤在什么业务场景下？”我想你⼤概率会说：“我会把它当作缓存使⽤，因
为它把后端数据库中的数据存储在内存中，然后直接从内存中读取数据，响应速度会⾮常快。”没错，这确
实是Redis的⼀个普遍使⽤场景，但是，这⾥也有⼀个绝对不能忽略的问题：⼀旦服务器宕机，内存中的数
据将全部丢失。

我们很容易想到的⼀个解决⽅案是，从后端数据库恢复这些数据，但这种⽅式存在两个问题：⼀是，需要频
繁访问数据库，会给数据库带来巨⼤的压⼒；⼆是，这些数据是从慢速数据库中读取出来的，性能肯定⽐不
上从Redis中读取，导致使⽤这些数据的应⽤程序响应变慢。所以，对Redis来说，实现数据的持久化，避免
从后端数据库中进⾏恢复，是⾄关重要的。

⽬前，Redis的持久化主要有两⼤机制，即AOF⽇志和RDB快照。我们先重点学习下AOF⽇志。

# 1 AOF日志是如何实现的？

说到⽇志，我们⽐较熟悉的是数据库的写前⽇志（Write Ahead Log, WAL），也就是说，在实际写数据前，
先把修改的数据记到⽇志⽂件中，以便故障时进⾏恢复。不过，AOF⽇志正好相反，它是写后⽇志，“写
后”的意思是Redis是先执⾏命令，把数据写⼊内存，然后才记录⽇志，如下图所⽰:





![redis-write-behind-log.png](images%2Fredis-write-behind-log.png)





那AOF为什么要先执⾏命令再记⽇志呢？要回答这个问题，我们要先知道AOF⾥记录了什么内容。

传统数据库的⽇志，例如redo log（重做⽇志），记录的是修改后的数据，⽽AOF⾥记录的是Redis收到的
每⼀条命令，这些命令是以⽂本形式保存的。

我们以Redis收到“set testkey testvalue”命令后记录的⽇志为例，看看AOF⽇志的内容。其中，“*3”表
⽰当前命令有三个部分，每部分都是由“$+数字”开头，后⾯紧跟着具体的命令、键或值。这⾥，“数
字”表⽰这部分中的命令、键或值⼀共有多少字节。例如，“$3 set”表⽰这部分有3个字节，也就是“set”命令。





![aof-file.png](images%2Faof-file.png)





但是，为了避免额外的检查开销，Redis在向AOF⾥⾯记录⽇志的时候，并不会先去对这些命令进⾏语法检
查。所以，如果先记⽇志再执⾏命令的话，⽇志中就有可能记录了错误的命令，Redis在使⽤⽇志恢复数据
时，就可能会出错。

⽽写后⽇志这种⽅式，就是先让系统执⾏命令，只有命令能执⾏成功，才会被记录到⽇志中，否则，系统就
会直接向客⼾端报错。所以，Redis使⽤写后⽇志这⼀⽅式的⼀⼤好处是，可以避免出现记录错误命令的情况。

除此之外，AOF还有⼀个好处：它是在命令执⾏后才记录⽇志，所以不会阻塞当前的写操作。
不过，AOF也有两个潜在的⻛险。

⾸先，如果刚执⾏完⼀个命令，还没有来得及记⽇志就宕机了，那么这个命令和相应的数据就有丢失的⻛险。
如果此时Redis是⽤作缓存，还可以从后端数据库重新读⼊数据进⾏恢复，但是，如果Redis是直接⽤作
数据库的话，此时，因为命令没有记⼊⽇志，所以就⽆法⽤⽇志进⾏恢复了。

其次，AOF虽然避免了对当前命令的阻塞，但可能会给下⼀个操作带来阻塞⻛险。这是因为，AOF⽇志也是
在主线程中执⾏的，如果在把⽇志⽂件写⼊磁盘时，磁盘写压⼒⼤，就会导致写盘很慢，进⽽导致后续的操
作也⽆法执⾏了。

仔细分析的话，你就会发现，这两个⻛险都是和AOF写回磁盘的时机相关的。这也就意味着，如果我们能够
控制⼀个写命令执⾏完后AOF⽇志写回磁盘的时机，这两个⻛险就解除了。

# 2 三种写回策略

其实，对于这个问题，AOF机制给我们提供了三个选择，也就是AOF配置项appendfsync的三个可选值。

Always，同步写回：每个写命令执⾏完，⽴⻢同步地将⽇志写回磁盘；
Everysec，每秒写回：每个写命令执⾏完，只是先把⽇志写到AOF⽂件的内存缓冲区，每隔⼀秒把缓冲
区中的内容写⼊磁盘；
No，操作系统控制的写回：每个写命令执⾏完，只是先把⽇志写到AOF⽂件的内存缓冲区，由操作系统
决定何时将缓冲区内容写回磁盘。

针对避免主线程阻塞和减少数据丢失问题，这三种写回策略都⽆法做到两全其美。我们来分析下其中的原因。

“同步写回”可以做到基本不丢数据，但是它在每⼀个写命令后都有⼀个慢速的落盘操作，不可避免地会
影响主线程性能；
虽然“操作系统控制的写回”在写完缓冲区后，就可以继续执⾏后续的命令，但是落盘的时机已经不在
Redis⼿中了，只要AOF记录没有写回磁盘，⼀旦宕机对应的数据就丢失了；
“每秒写回”采⽤⼀秒写回⼀次的频率，避免了“同步写回”的性能开销，虽然减少了对系统性能的影
响，但是如果发⽣宕机，上⼀秒内未落盘的命令操作仍然会丢失。所以，这只能算是，在避免影响主线程
性能和避免数据丢失两者间取了个折中。

这三种策略的写回时机，以及优缺点汇总如下表所示:





![aof-write-back-strategy.png](images%2Faof-write-back-strategy.png)



刷盘（fsync 或 fdatasync）是关键的一步，它负责将内存中的数据同步到磁盘文件，确保数据持久化。

always 模式下，fsync 是由主线程同步执行的，无法交由后台线程异步执行，因此会阻塞主线程并影响写入性能。
everysec 模式下，fsync 是由后台线程异步执行的，不会阻塞主线程，因此对性能影响较小。
no 模式下，fsync 完全由操作系统的调度策略决定，主线程完全没有刷盘开销，性能最佳，但数据丢失风险最高。

到这⾥，我们就可以根据系统对⾼性能和⾼可靠性的要求，来选择使⽤哪种写回策略了。总结⼀下就是：想
要获得⾼性能，就选择No策略；如果想要得到⾼可靠性保证，就选择Always策略；如果允许数据有⼀点丢
失，⼜希望性能别受太⼤影响的话，那么就选择Everysec策略。

但是，按照系统的性能需求选定了写回策略，并不是“⾼枕⽆忧”了。毕竟，AOF是以⽂件的形式在记录接
收到的所有写命令。随着接收的写命令越来越多，AOF⽂件会越来越⼤。这也就意味着，我们⼀定要⼩⼼
AOF⽂件过⼤带来的性能问题。

这⾥的“性能问题”，主要在于以下三个⽅⾯：⼀是，⽂件系统本⾝对⽂件⼤⼩有限制，⽆法保存过⼤的⽂
件；⼆是，如果⽂件太⼤，之后再往⾥⾯追加命令记录的话，效率也会变低；三是，如果发⽣宕机，AOF中
记录的命令要⼀个个被重新执⾏，⽤于故障恢复，如果⽇志⽂件太⼤，整个恢复过程就会⾮常缓慢，这就会
影响到Redis的正常使⽤。

所以，我们就要采取⼀定的控制⼿段，这个时候，AOF重写机制就登场了。


# 3 AOF重写机制

## 3.1 多变一

简单来说，AOF重写机制就是在重写时，Redis根据数据库的现状创建⼀个新的AOF⽂件，也就是说，读取
数据库中的所有键值对，然后对每⼀个键值对⽤⼀条命令记录它的写⼊。⽐如说，当读取了键值
对“testkey”: “testvalue”之后，重写机制会记录set testkey testvalue这条命令。这样，当需要恢复
时，可以重新执⾏该命令，实现“testkey”: “testvalue”的写⼊。

为什么重写机制可以把⽇志⽂件变⼩呢? 实际上，重写机制具有“多变⼀”功能。所谓的“多变⼀”，也就
是说，旧⽇志⽂件中的多条命令，在重写后的新⽇志中变成了⼀条命令。

我们知道，AOF⽂件是以追加的⽅式，逐⼀记录接收到的写命令的。当⼀个键值对被多条写命令反复修改
时，AOF⽂件会记录相应的多条命令。但是，在重写的时候，是根据这个键值对当前的最新状态，为它⽣成
对应的写⼊命令。这样⼀来，⼀个键值对在重写⽇志中只⽤⼀条命令就⾏了，⽽且，在⽇志恢复时，只⽤执
⾏这条命令，就可以直接完成这个键值对的写⼊了。

下⾯这张图就是⼀个例⼦：





![aof-rewrite-example.png](images%2Faof-rewrite-example.png)





当我们对⼀个列表先后做了6次修改操作后，列表的最后状态是[“D”, “C”, “N”]，此时，只⽤LPUSH
u:list “N”, “C”, "D"这⼀条命令就能实现该数据的恢复，这就节省了五条命令的空间。对于被修改过成
百上千次的键值对来说，重写能节省的空间当然就更⼤了。

不过，虽然AOF重写后，⽇志⽂件会缩⼩，但是，要把整个数据库的最新数据的操作⽇志都写回磁盘，仍然
是⼀个⾮常耗时的过程。这时，我们就要继续关注另⼀个问题了：重写会不会阻塞主线程？


## 3.2 后台线程异步执行aof重写

和AOF⽇志由主线程写回不同，重写过程是由后台线程bgrewriteaof来完成的，这也是为了避免阻塞主线
程，导致数据库性能下降。

重写的过程可以总结为“⼀个拷⻉，两处⽇志”。

“⼀个拷⻉”就是指，每次执⾏重写时，主线程fork出后台的bgrewriteaof⼦进程。此时，fork会把主线程
的内存拷⻉⼀份给bgrewriteaof⼦进程，这⾥⾯就包含了数据库的最新数据。然后，bgrewriteaof⼦进程就
可以在不影响主线程的情况下，逐⼀把拷⻉的数据写成操作，记⼊重写⽇志。

“两处⽇志”⼜是什么呢？因为主线程未阻塞，仍然可以处理新来的操作。此时，如果有写操作，第⼀处⽇志就是指正在使⽤的AOF⽇
志，Redis会把这个操作写到它的缓冲区。这样⼀来，即使宕机了，这个AOF⽇志的操作仍然是⻬全的，可以⽤于恢复。

⽽第⼆处⽇志，就是指新的AOF重写⽇志。这个操作也会被写到重写⽇志的缓冲区。这样，重写⽇志也不会
丢失最新的操作。等到拷⻉数据的所有操作记录重写完成后，重写⽇志记录的这些最新操作也会写⼊新的
AOF⽂件，以保证数据库最新状态的记录。此时，我们就可以⽤新的AOF⽂件替代旧⽂件了。





![aof-process.png](images%2Faof-process.png)





总结来说，每次AOF重写时，Redis会先执⾏⼀个内存拷⻉，⽤于重写；然后，使⽤两个⽇志保证在重写过
程中，新写⼊的数据不会丢失。⽽且，因为Redis采⽤额外的线程进⾏数据重写，所以，这个过程并不会阻
塞主线程。


## 3.3 AOF重写的触发时机

AOF 重写有两种触发方式：**手动触发**和**自动触发**。

**手动触发**：客户端执行 `BGREWRITEAOF` 命令，Redis 立即开始 AOF 重写。

**自动触发**：Redis 通过以下两个配置项控制自动重写的时机，必须**同时满足**才会触发：

```
# AOF 文件大小相比上次重写后增长的百分比，默认 100（即翻倍时触发）
auto-aof-rewrite-percentage 100

# AOF 文件的最小大小，低于此值不会触发重写，默认 64MB
auto-aof-rewrite-min-size 64mb
```

也就是说，只有当 AOF 文件大小同时满足"超过 64MB"和"比上次重写后的大小增长了 100%"这两个条件时，Redis 才会自动触发 AOF 重写。

此外，如果当前已有 BGSAVE 或 BGREWRITEAOF 子进程在运行，Redis 会推迟本次重写，等子进程结束后再执行。


## 3.4 重写期间的内存问题

AOF 重写需要 fork 子进程，而 fork 操作会利用操作系统的**写时复制（Copy-On-Write，COW）** 机制。在理想情况下，子进程与父进程共享
相同的物理内存页，只有当父进程修改某个内存页时，操作系统才会为子进程复制一份该内存页。

但在高写入压力下，COW 会导致大量内存页被复制，**最坏情况下内存使用量可能翻倍**。这是生产环境中常见的问题，需要注意以下几点：

- 确保服务器预留足够的内存，通常建议 Redis 使用的内存不超过物理内存的 50%
- 可以通过 `INFO persistence` 命令中的 `aof_rewrite_buffer_length` 监控重写缓冲区的大小
- 如果使用了 Linux 的 Transparent Huge Pages（THP），COW 的内存开销会被放大（每次复制 2MB 而不是 4KB），建议关闭 THP

此外，fork 操作本身也有开销。Redis 的 fork 耗时与数据量大致成正比，在大内存实例（如 20GB+）上，fork 可能耗时数百毫秒，
这段时间主线程是阻塞的。可以通过 `INFO persistence` 中的 `latest_fork_usec` 监控最近一次 fork 的耗时。


# 4 AOF 文件的数据恢复

## 4.1 AOF 加载流程

当 Redis 启动时，如果开启了 AOF 持久化（`appendonly yes`），会优先使用 AOF 文件来恢复数据（即使 RDB 文件也存在）。
加载流程如下：

1. Redis 启动，检查是否存在 AOF 文件
2. 创建一个**伪客户端**（fake client），该客户端不需要网络连接，但功能与普通客户端完全一致
3. 从 AOF 文件中逐条读取命令
4. 使用伪客户端执行每一条命令，将数据恢复到内存中
5. 所有命令执行完毕，数据恢复完成

由于 AOF 是逐条回放命令，恢复速度比 RDB 慢。对于大规模数据，AOF 恢复可能需要较长时间，这也是为什么 Redis 4.0 引入了
混合持久化模式（详见后文）。


## 4.2 AOF 文件修复

如果 Redis 在写入 AOF 文件时发生宕机，可能导致 AOF 文件末尾的命令不完整（例如只写了一半）。Redis 提供了
`redis-check-aof` 工具来修复这种问题：

```bash
# 检查 AOF 文件是否损坏
redis-check-aof appendonly.aof

# 修复 AOF 文件（截断末尾不完整的命令）
redis-check-aof --fix appendonly.aof
```

`--fix` 选项会找到 AOF 文件中最后一条不完整的命令，将其及之后的内容全部删除。这意味着可能会丢失少量数据，
但可以保证 AOF 文件的正确性，让 Redis 正常启动。

Redis 也提供了 `aof-load-truncated` 配置项（默认 yes）：当设置为 yes 时，Redis 在启动加载 AOF 文件遇到末尾截断的情况会
自动忽略并继续启动，而不是报错退出。


# 5 Redis 7.0 Multi-Part AOF

Redis 7.0 对 AOF 机制进行了一次重大重构，引入了 **Multi-Part AOF（MP-AOF）** 方案。在此之前，AOF 只是一个单独的文件，
重写时需要创建完整的新文件再替换旧文件。MP-AOF 将 AOF 拆分为多个文件，配合一个清单文件来管理。


## 5.1 MP-AOF 的文件结构

MP-AOF 将 AOF 拆分为三种类型的文件：

**1. BASE 文件**：由 AOF 重写生成，保存重写时刻数据库的完整快照（以命令形式或 RDB 格式），最多只有一个

**2. INCR 文件**：增量 AOF 文件，记录重写开始后新收到的写命令。可以有多个，每次重写都会创建一个新的 INCR 文件

**3. MANIFEST 文件**：清单文件，记录当前有效的 BASE 文件和 INCR 文件列表，是 MP-AOF 的核心索引

文件存放在 `appenddirname` 配置项指定的目录中（默认为 `appendonlydir`），文件命名格式为：

```
appendonlydir/
├── appendonly.aof.1.base.rdb      # BASE 文件（RDB 格式）
├── appendonly.aof.1.incr.aof      # INCR 文件 1
├── appendonly.aof.2.incr.aof      # INCR 文件 2（最新的增量）
└── appendonly.aof.manifest        # 清单文件
```


## 5.2 MP-AOF 解决了什么问题

**问题一：重写期间内存开销大**

在旧的 AOF 方案中，重写期间主线程需要同时维护两个缓冲区：旧 AOF 的写入缓冲区和重写 AOF 的缓冲区（aof_rewrite_buf）。
高写入压力下，重写缓冲区可能占用大量内存。

MP-AOF 方案中，重写开始时 Redis 会创建一个新的 INCR 文件，后续的写命令直接追加到新的 INCR 文件中，**不再需要重写缓冲区**。
子进程只需要根据当前内存数据生成 BASE 文件，完成后更新 MANIFEST 文件即可。这大幅降低了重写期间的额外内存开销。

**问题二：重写完成后的原子替换风险**

旧方案使用 `rename` 系统调用将新 AOF 文件替换旧文件。虽然 `rename` 是原子操作，但如果新文件很大，之前的 `fsync` 操作可能耗时较长，
存在数据风险窗口。

MP-AOF 方案通过更新 MANIFEST 文件来切换，MANIFEST 文件很小，更新操作更加安全。

**问题三：恢复时不必回放全部历史命令**

MP-AOF 恢复时，先加载 BASE 文件（如果是 RDB 格式则加载速度很快），再依次回放各 INCR 文件中的增量命令。
相比旧方案回放整个 AOF 文件，恢复速度显著提升。


## 5.3 MP-AOF 的重写流程

1. 主线程 fork 子进程
2. 主线程创建一个新的 INCR 文件，后续写命令追加到该文件
3. 子进程根据内存快照生成新的 BASE 文件（可以是 RDB 格式或 AOF 格式，取决于 `aof-use-rdb-preamble` 配置）
4. 子进程完成后通知主线程
5. 主线程更新 MANIFEST 文件，将旧的 BASE 文件和已合并的 INCR 文件标记为无效
6. 后台异步删除旧的 BASE 文件和无效的 INCR 文件


# 6 AOF 相关配置汇总

```
# 是否开启 AOF 持久化，默认 no
appendonly yes

# AOF 文件名，默认 appendonly.aof
appendfilename "appendonly.aof"

# AOF 文件存放目录（Redis 7.0+ MP-AOF），默认 appendonlydir
appenddirname "appendonlydir"

# 写回策略：always | everysec | no，默认 everysec
appendfsync everysec

# AOF 重写期间是否暂停 fsync，默认 no
# 设置为 yes 时，重写期间新的写命令不会 fsync，减少磁盘 IO 竞争，但增加数据丢失风险
no-appendfsync-on-rewrite no

# 自动触发重写的增长百分比，默认 100
auto-aof-rewrite-percentage 100

# 自动触发重写的最小文件大小，默认 64MB
auto-aof-rewrite-min-size 64mb

# 加载 AOF 文件时遇到末尾截断是否继续启动，默认 yes
aof-load-truncated yes

# AOF 重写时是否使用 RDB 前缀（混合持久化），默认 yes（Redis 4.0+）
aof-use-rdb-preamble yes
```

其中 `aof-use-rdb-preamble` 是一个非常重要的配置。当设置为 yes 时，AOF 重写生成的文件前半部分是 RDB 格式的快照数据，
后半部分是重写开始后的增量 AOF 命令。这种**混合持久化**方式兼顾了 RDB 的快速加载和 AOF 的数据完整性。


# 7 总结

AOF 持久化的完整生命周期可以串联为：

```
写命令执行 → 写入 AOF 缓冲区 → 根据 appendfsync 策略刷盘 → AOF 文件增长
    → 触发重写条件 → fork 子进程 → 生成新 BASE 文件 → 切换 MANIFEST → 删除旧文件
    → Redis 重启 → 加载 BASE + 回放 INCR → 数据恢复完成
```

| 关注点 | 关键机制 | 配置项 |
|---|---|---|
| **数据安全** | 三种写回策略控制丢失窗口 | `appendfsync` |
| **文件膨胀** | AOF 重写"多变一" | `auto-aof-rewrite-percentage`、`auto-aof-rewrite-min-size` |
| **重写性能** | fork + COW + 后台子进程 | `no-appendfsync-on-rewrite` |
| **恢复速度** | 混合持久化 RDB + AOF | `aof-use-rdb-preamble` |
| **文件管理（7.0+）** | MP-AOF 多文件方案 | `appenddirname` |
| **文件修复** | redis-check-aof 工具 | `aof-load-truncated` |

AOF 的核心设计理念是**在数据安全性和系统性能之间提供灵活的权衡选择**。从 Redis 4.0 的混合持久化到 7.0 的 MP-AOF，
每一次演进都在减少重写开销的同时提升恢复速度，使得 AOF 成为生产环境中最常用的持久化方案。