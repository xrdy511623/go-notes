
---
⾼性能IO模型：为什么单线程Redis能那么快？
---

今天，我们来探讨⼀个很多⼈都很关⼼的问题：“为什么单线程的Redis能那么快？”
⾸先，要厘清⼀个事实，我们通常说，Redis是单线程，主要是指Redis的⽹络IO和键值对读写是由⼀个线程来完成的，这也是Redis对外提供
键值存储服务的主要流程。但Redis的其他功能，⽐如持久化、 异步删除、集群数据同步等，其实是由额外的线程执⾏的。

所以，严格来说，Redis并不是单线程，但是我们⼀般把Redis称为单线程⾼性能，⽽且，这也会促使你紧接着提问：“为什么⽤单线程？
为什么单线程能这么快？”

要弄明⽩这个问题，我们就要深⼊地学习下Redis的单线程设计机制以及多路复⽤机制。之后你在调优Redis性能时，也能更有针对性地避免会
导致Redis单线程阻塞的操作，例如执⾏复杂度⾼的命令。

# 1 Redis为什么⽤单线程？

要更好地理解Redis为什么⽤单线程，我们就要先了解多线程的开销。

# 1.1 多线程的开销

⽇常写程序时，我们经常会听到⼀种说法：“使⽤多线程，可以增加系统吞吐率，或是可以增加系统扩展性。”的确，对于⼀个多线程的系统来说，
在有合理的资源分配的情况下，可以增加系统中处理请求操作的资源实体，进⽽提升系统能够同时处理的请求数，即吞吐率。

但是，请你注意，通常情况下，在我们采⽤多线程后，如果没有良好的系统设计，实际得到的结果，其实是不符合预期的。 我们刚开始增加线程数时，
系统吞吐率会增加，但是，再进⼀步增加线程时，系统吞吐率就增⻓迟缓了，有时甚⾄还会出现下降的情况。

为什么会出现这种情况呢？⼀个关键的瓶颈在于，系统中通常会存在被多线程同时访问的共享资源，⽐如⼀个共享的数据结构。当有多个线程要修改
这个共享资源时，为了保证共享资源的正确性，就需要有额外的机制进⾏保证，⽽这个额外的机制， 就会带来额外的开销。

并发访问控制⼀直是多线程开发中的⼀个难点问题，如果没有精细的设计，⽐如说，只是简单地采⽤⼀个粗粒度互斥锁，就会出现不理想的结果：
即使增加了线程，⼤部分线程也在等待获取访问共享资源的互斥锁， 并⾏变串⾏，系统吞吐率并没有随着线程的增加⽽增加。

⽽且，采⽤多线程开发⼀般会引⼊同步原语来保护共享资源的并发访问，这也会降低系统代码的易调试性和可维护性。为了避免这些问题，Redis
直接采⽤了单线程模式。

# 2 单线程Redis为什么那么快？

通常来说，单线程的处理能⼒要⽐多线程差很多，但是Redis却能使⽤单线程模型达到每秒数⼗万级别的处理能⼒，这是为什么呢？其实，这是
Redis多⽅⾯设计选择的⼀个综合结果。

⼀⽅⾯，Redis的⼤部分操作在内存上完成，再加上它采⽤了⾼效的数据结构，例如哈希表和跳表，这是它实现⾼性能的⼀个重要原因。另⼀⽅⾯，
就是Redis采⽤了多路复⽤机制，使其在⽹络IO操作中能并发处理⼤量的客⼾端请求，实现⾼吞吐率。接下来，我们就重点学习下多路复⽤机制。

⾸先，我们要弄明⽩⽹络操作的基本IO模型和潜在的阻塞点。毕竟，Redis采⽤单线程进⾏IO，如果线程被阻塞了，就⽆法进⾏多路复⽤了。


## 2.1 基本IO模型与阻塞点

以Get请求为例，Redis为了处理⼀个Get请求，需要监听客⼾端请求（bind/listen），和客⼾端建⽴连接（accept），从socket中读取请求
（recv），解析客⼾端发送请求（parse），根据请求类型读取键值数据（get），最后给客⼾端返回结果，即向socket中写回数据（send）。

下图显⽰了这⼀过程，其中，bind/listen、accept、recv、parse和send属于⽹络IO处理，⽽get属于键值数据操作。既然Redis是单线程，
那么，最基本的⼀种实现是在⼀个线程中依次执⾏上⾯说的这些操作。





![get-process.png](images%2Fget-process.png)





但是，在这⾥的⽹络IO操作中，有潜在的阻塞点，分别是accept()和recv()。当Redis监听到⼀个客⼾端有连接请求，但⼀直未能成功建⽴起连接时，
会阻塞在accept()函数这⾥，导致其他客⼾端⽆法和Redis建⽴连接。类似的，当Redis通过recv()从⼀个客⼾端读取数据时，如果数据⼀直没有到达，
Redis也会⼀直阻塞在recv()。 这就导致Redis整个线程阻塞，⽆法处理其他客⼾端请求，效率很低。不过，幸运的是，socket⽹络模型本⾝⽀持
⾮阻塞模式。


## 2.2 非阻塞模式

Socket⽹络模型的⾮阻塞模式设置，主要体现在三个关键的函数调⽤上，如果想要使⽤socket⾮阻塞模式，就必须要了解这三个函数的调⽤返回类型
和设置模式。接下来，我们就重点学习下它们。

在socket模型中，不同操作调⽤后会返回不同的套接字类型。socket()⽅法会返回主动套接字，然后调⽤listen()⽅法，将主动套接字转化为监听
套接字，此时，可以监听来⾃客⼾端的连接请求。最后，调⽤accept()⽅法接收到达的客⼾端连接，并返回已连接套接字。





![non-block-pattern.png](images%2Fnon-block-pattern.png)





针对监听套接字，我们可以设置⾮阻塞模式：当Redis调⽤accept()但⼀直未有连接请求到达时，Redis线程可以返回处理其他操作，⽽不⽤⼀直
等待。但是，你要注意的是，调⽤accept()时，已经存在监听套接字了。

虽然Redis线程可以不⽤继续等待，但是总得有机制继续在监听套接字上等待后续连接请求，并在有请求时通知Redis。

类似的，我们也可以针对已连接套接字设置⾮阻塞模式：Redis调⽤recv()后，如果已连接套接字上⼀直没有数据到达，Redis线程同样可以返回
处理其他操作。我们也需要有机制继续监听该已连接套接字，并在有数据达到时通知Redis。

这样才能保证Redis线程，既不会像基本IO模型中⼀直在阻塞点等待，也不会导致Redis⽆法处理实际到达的连接请求或数据。

到此，Linux中的IO多路复⽤机制就要登场了。


## 2.3 基于多路复⽤的⾼性能I/O模型

Linux中的IO多路复⽤机制是指⼀个线程处理多个IO流，就是我们经常听到的select/epoll机制。简单来说，在Redis只运⾏单线程的情况下，
该机制允许内核中，同时存在多个监听套接字和已连接套接字。内核会⼀直监听这些套接字上的连接请求或数据请求。⼀旦有请求到达，就会交给
Redis线程处理，这就实现了⼀个Redis线程处理多个IO流的效果。

下图就是基于多路复⽤的Redis IO模型。图中的多个FD就是刚才所说的多个套接字。Redis⽹络框架调⽤epoll机制，让内核监听这些套接字。
此时，Redis线程不会阻塞在某⼀个特定的监听或已连接套接字上，也就是说，不会阻塞在某⼀个特定的客⼾端请求处理上。正因为此，Redis
可以同时和多个客⼾端连接并处理请求，从⽽提升并发性。





![redis-io-pattern.png](images%2Fredis-io-pattern.png)





为了在请求到达时能通知到Redis线程，select/epoll提供了基于事件的回调机制，即针对不同事件的发⽣， 调⽤相应的处理函数。

那么，回调机制是怎么⼯作的呢？其实，select/epoll⼀旦监测到FD上有请求到达时，就会触发相应的事件。

这些事件会被放进⼀个事件队列，Redis单线程对该事件队列不断进⾏处理。这样⼀来，Redis⽆需⼀直轮询是否有请求实际发⽣，这就可以
避免造成CPU资源浪费。同时，Redis在对事件队列中的事件进⾏处理时，会调⽤相应的处理函数，这就实现了基于事件的回调。因为Redis
⼀直在对事件队列进⾏处理，所以能及时响应客⼾端请求，提升Redis的响应性能。

为了⽅便理解，我们再以连接请求和读数据请求为例，具体解释⼀下。

这两个请求分别对应Accept事件和Read事件，Redis分别对这两个事件注册accept和get回调函数。当Linux内核监听到有连接请求或读数据
请求时，就会触发Accept事件和Read事件，此时，内核就会回调Redis相应的accept和get函数进⾏处理。

这就像病⼈去医院瞧病。在医⽣实际诊断前，每个病⼈（等同于请求）都需要先分诊、测体温、登记等。如果这些⼯作都由医⽣来完成，医⽣的
⼯作效率就会很低。所以，医院都设置了分诊台，分诊台会⼀直处理这些诊断前的⼯作（类似于Linux内核监听请求），然后再转交给医⽣做
实际诊断。这样即使⼀个医⽣（相当于Redis单线程），效率也能提升。

不过，需要注意的是，即使你的应⽤场景中部署了不同的操作系统，多路复⽤机制也是适⽤的。因为这个机制的实现有很多种，既有基于Linux
系统下的select和epoll实现，也有基于FreeBSD的kqueue实现，以及基于Solaris的evport实现，这样，你可以根据Redis实际运⾏的
操作系统，选择相应的多路复⽤实现。


