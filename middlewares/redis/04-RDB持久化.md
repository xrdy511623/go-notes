
---
内存快照：宕机后， Redis 如何实现快速恢复？
---

我们知道，Redis 要避免数据丢失可以采用 AOF 日志进行持久化。这个⽅法的好
处，是每次执⾏只需要记录操作命令，需要持久化的数据量不⼤。⼀般⽽⾔，只要你
采⽤的不是 always 的持久化策略，就不会对性能造成太⼤影响。

但是，也正因为记录的是操作命令，⽽不是实际的数据，所以，⽤ AOF
⽅法进⾏故障恢复的时候，需要逐⼀把操作⽇志都执⾏⼀遍。如果操作
⽇志⾮常多， Redis 就会恢复得很缓慢，影响到正常使⽤。这当然不是理
想的结果。那么，还有没有既可以保证可靠性，还能在宕机时实现快速
恢复的其他⽅法呢？

当然有了，这就是我们要介绍另⼀种持久化⽅法： 内存快
照。所谓内存快照，就是指内存中的数据在某⼀个时刻的状态记录。这
就类似于照⽚，当你给朋友拍照时，⼀张照⽚就能把朋友⼀瞬间的形象
完全记下来。

对 Redis 来说，它实现类似照⽚记录效果的⽅式，就是把某⼀时刻的状
态以⽂件的形式写到磁盘上，也就是快照。这样⼀来，即使宕机，快照
⽂件也不会丢失，数据的可靠性也就得到了保证。这个快照⽂件就称为
RDB ⽂件，其中， RDB 就是 Redis DataBase 的缩写。

和 AOF 相⽐， RDB 记录的是某⼀时刻的数据，并不是操作，所以，在做
数据恢复时，我们可以直接把 RDB ⽂件读⼊内存，很快地完成恢复。听
起来好像很不错，但内存快照也并不是最优选项。为什么这么说呢？

我们还要考虑两个关键问题：

• 对哪些数据做快照？这关系到快照的执⾏效率问题；
• 做快照时，数据还能被增删改吗？这关系到 Redis 是否被阻塞，能
否同时正常处理请求。

这么说可能不太好理解，我们还是拿拍照⽚来举例⼦。我们在拍照
时，通常要关注两个问题：

• 如何取景？也就是说，我们打算把哪些⼈、哪些物拍到照⽚中；
• 在按快⻔前，要记着提醒朋友不要乱动，否则拍出来的照⽚就模糊了。


你看，这两个问题是不是⾮常重要呢？那么，接下来，我们就来具体地
聊⼀聊。先说“取景”问题，也就是我们对哪些数据做快照。


# 1 给哪些内存数据做快照？

Redis 的数据都在内存中，为了提供所有数据的可靠性保证，它执⾏的是
全量快照，也就是说，把内存中的所有数据都记录到磁盘中，这就类似于
给 100 个⼈拍合影，把每⼀个⼈都拍进照⽚⾥。这样做的好处是，⼀
次性记录了所有数据，⼀个都不少。

当你给⼀个⼈拍照时，只⽤协调⼀个⼈就够了，但是，拍 100 ⼈的⼤合
影，却需要协调 100 个⼈的位置、状态，等等，这当然会更费时费⼒。
同样，给内存的全量数据做快照，把它们全部写⼊磁盘也会花费很多时
间。⽽且，全量数据越多， RDB ⽂件就越⼤，往磁盘上写数据的时间开
销就越⼤。

对于 Redis ⽽⾔，它的单线程模型就决定了，我们要尽量避免所有会阻
塞主线程的操作，所以，针对任何操作，我们都会提⼀个灵魂之问：“它
会阻塞主线程吗?”RDB ⽂件的⽣成是否会阻塞主线程，这就关系到是否
会降低 Redis 的性能。

Redis 提供了两个命令来⽣成 RDB ⽂件，分别是 save 和 bgsave。

• save：在主线程中执⾏，会导致阻塞；
• bgsave：创建⼀个⼦进程，专⻔⽤于写⼊ RDB ⽂件，避免了主线
程的阻塞，这也是 Redis RDB ⽂件⽣成的默认配置。

好了，这个时候，我们就可以通过 bgsave 命令来执⾏全量快照，这既提
供了数据的可靠性保证，也避免了对 Redis 的性能影响。

接下来，我们要关注的问题就是，在对内存数据做快照时，这些数据还
能“动”吗? 也就是说，这些数据还能被修改吗？ 这个问题⾮常重要，这
是因为，如果数据能被修改，那就意味着 Redis 还能正常处理写操作。
否则，所有写操作都得等到快照完了才能执⾏，性能⼀下⼦就降低了。

# 2 快照时数据能修改吗?

在给别⼈拍照时，⼀旦对⽅动了，那么这张照⽚就拍糊了，我们就需要
重拍，所以我们当然希望对⽅保持不动。对于内存快照⽽⾔，我们也不
希望数据“动”。

举个例⼦。我们在时刻 t 给内存做快照，假设内存数据量是 4GB，磁盘
的写⼊带宽是 0.2GB/s，简单来说，⾄少需要 20s（4/0.2 = 20）才能
做完。如果在时刻 t+5s 时，⼀个还没有被写⼊磁盘的内存数据 A，被修
改成了 A’，那么就会破坏快照的完整性，因为 A’不是时刻 t 时的状态。
因此，和拍照类似，我们在做快照时也不希望数据“动”，也就是不能被
修改。

但是，如果快照执⾏期间数据不能被修改，是会有潜在问题的。对于刚
刚的例⼦来说，在做快照的 20s 时间⾥，如果这 4GB 的数据都不能被修
改， Redis 就不能处理对这些数据的写操作，那⽆疑就会给业务服务造成
巨⼤的影响。

你可能会想到，可以⽤ bgsave 避免阻塞啊。这⾥我就要说到⼀个常⻅的
误区了， 避免阻塞和正常处理写操作并不是⼀回事。此时，主线程的确
没有阻塞，可以正常接收请求，但是，为了保证快照完整性，它只能处
理读操作，因为不能修改正在执⾏快照的数据。

为了快照⽽暂停写操作，肯定是不能接受的。所以这个时候， Redis 就会
借助操作系统提供的写时复制技术（Copy-On-Write, COW），在执⾏
快照的同时，正常处理写操作。

简单来说， bgsave ⼦进程是由主线程 fork ⽣成的， 可以共享主线程的所
有内存数据。 bgsave ⼦进程运⾏后，开始读取主线程的内存数据，并把
它们写⼊ RDB ⽂件。

此时，如果主线程对这些数据也都是读操作（例如图中的键值对 A），那
么，主线程和 bgsave ⼦进程相互不影响。但是，如果主线程要修改⼀块
数据（例如图中的键值对 C），那么，这块数据就会被复制⼀份，⽣成
该数据的副本。然后， bgsave ⼦进程会把这个副本数据写⼊ RDB ⽂
件，⽽在这个过程中，主线程仍然可以直接修改原来的数据。





![rdb-process.png](images%2Frdb-process.png)





这既保证了快照的完整性，也允许主线程同时对数据进⾏修改，避免了
对正常业务的影响。

到这⾥，我们就解决了对“哪些数据做快照”以及“做快照时数据能否修
改”这两⼤问题： Redis 会使⽤ bgsave 对当前内存中的所有数据做快
照，这个操作是⼦进程在后台完成的，通过写时复制技术允许主线程同时可以修改数
据。

现在，我们再来看另⼀个问题：多久做⼀次快照？我们在拍照的时候，
还有项技术叫“连拍”，可以记录⼈或物连续多个瞬间的状态。那么，快
照也适合“连拍”吗？


# 3 快照执行的频率

对于快照来说，所谓“连拍”就是指连续地做快照。这样⼀来，快照的间
隔时间变得很短，即使某⼀时刻发⽣宕机了，因为上⼀时刻快照刚执
⾏，丢失的数据也不会太多。但是，这其中的快照间隔时间就很关键
了。

比如，我们先在 T0 时刻做了⼀次快照，然后⼜在 T0+t 时刻做了
⼀次快照，在这期间，数据块 5 和 9 被修改了。如果在 t 这段时间内，
机器宕机了，那么，只能按照 T0 时刻的快照进⾏恢复。此时，数据块 5
和 9 的修改值因为没有快照记录，就⽆法恢复了。

所以，要想尽可能恢复数据， t 值就要尽可能⼩， t 越⼩，就越像“连
拍”。那么， t 值可以⼩到什么程度呢，⽐如说是不是可以每秒做⼀次快
照？毕竟，每次快照都是由 bgsave ⼦进程在后台执⾏，也不会阻塞主线程。

这种想法其实是错误的。虽然 bgsave 执⾏时不阻塞主线程，但是， 如果
频繁地执⾏全量快照，也会带来两⽅⾯的开销。

⼀⽅⾯，频繁将全量数据写⼊磁盘，会给磁盘带来很⼤压⼒，多个快照
竞争有限的磁盘带宽，前⼀个快照还没有做完，后⼀个⼜开始做了，容
易造成恶性循环。

另⼀⽅⾯， bgsave ⼦进程需要通过 fork 操作从主线程创建出来。虽然，
⼦进程在创建后不会再阻塞主线程，但是， fork 这个创建过程本身会阻
塞主线程，⽽且主线程的内存越⼤，阻塞时间越⻓。如果频繁 fork 出
bgsave ⼦进程，这就会频繁阻塞主线程了。那么，有什么其他好⽅法
吗？

此时，我们可以做增量快照，所谓增量快照，就是指，做了⼀次全量快
照后，后续的快照只对修改的数据进⾏快照记录，这样可以避免每次全
量快照的开销。

在第⼀次做完全量快照后， T1 和 T2 时刻如果再做快照，我们只需要将
被修改的数据写⼊快照⽂件就⾏。但是，这么做的前提是， 我们需要记
住哪些数据被修改了。你可不要⼩瞧这个“记住”功能，它需要我们使⽤
额外的元数据信息去记录哪些数据被修改了，这会带来额外的空间开销
问题。如下图所示：





![rdb-enhance.png](images%2Frdb-enhance.png)





如果我们对每⼀个键值对的修改，都做个记录，那么，如果有 1 万个被修
改的键值对，我们就需要有 1 万条额外的记录。⽽且，有的时候，键值对
⾮常⼩，⽐如只有 32 字节，⽽记录它被修改的元数据信息，可能就需要
8 字节，这样的画，为了“记住”修改，引⼊的额外空间开销⽐较⼤。这
对于内存资源宝贵的 Redis 来说，有些得不偿失。


到这⾥，你可以发现，虽然跟 AOF 相⽐，快照的恢复速度快，但是，快
照的频率不好把握，如果频率太低，两次快照间⼀旦宕机，就可能有⽐
较多的数据丢失。如果频率太⾼，⼜会产⽣额外开销，那么，还有什么
⽅法既能利⽤ RDB 的快速恢复，⼜能以较⼩的开销做到尽量少丢数据
呢？

# 4 混合持久化策略

Redis 4.0 中提出了⼀个混合使⽤ AOF ⽇志和内存快照的⽅法。简单来
说，内存快照以⼀定的频率执⾏，在两次快照之间，使⽤ AOF ⽇志记录
这期间的所有命令操作。

这样⼀来，快照不⽤很频繁地执⾏，这就避免了频繁 fork 对主线程的影
响。⽽且， AOF ⽇志也只⽤记录两次快照间的操作，也就是说，不需要
记录所有操作了，因此，就不会出现⽂件过⼤的情况了，也可以避免重
写开销。

如下图所示， T1 和 T2 时刻的修改，⽤ AOF ⽇志记录，等到第⼆次做全
量快照时，就可以清空 AOF ⽇志，因为此时的修改都已经记录到快照中
了，恢复时就不再⽤⽇志了。






![mixed-persistence.png](images%2Fmixed-persistence.png)





这个⽅法既能享受到 RDB ⽂件快速恢复的好处，⼜能享受到 AOF 只记
录操作命令的简单优势，颇有点“⻥和熊掌可以兼得”的感觉，建议你在
实践中⽤起来。


混合持久化通过 `aof-use-rdb-preamble` 配置项控制（Redis 5.0+ 默认开启）：

```
# 开启混合持久化（AOF 重写时使用 RDB 前缀）
aof-use-rdb-preamble yes
```

开启后，AOF 重写生成的文件格式为：

```
[RDB 格式的全量快照数据] + [重写期间的增量 AOF 命令]
```

恢复时，Redis 先加载 RDB 部分（速度快），再回放 AOF 增量命令（数据完整），兼顾了两者的优势。


# 5 RDB 文件结构

RDB 文件是一个经过压缩的二进制文件，其整体结构如下：

```
┌──────────┬─────────┬──────────┬───────────┬─────┬──────────┐
│  REDIS   │ db_ver  │ aux_data │ databases │ EOF │ checksum │
│ (5bytes) │ (4bytes)│ (可变)    │  (可变)   │(1B) │ (8bytes) │
└──────────┴─────────┴──────────┴───────────┴─────┴──────────┘
```

各部分说明：

- **REDIS**：5 字节的魔数（magic number），固定为 "REDIS" 字符串，用于在加载时快速判断文件是否为 RDB 格式
- **db_version**：4 字节的版本号字符串，如 "0009" 表示 RDB 版本 9
- **aux_data**：辅助字段，记录 Redis 版本、创建时间、已用内存等元数据
- **databases**：核心数据区域，按数据库编号依次存储各 db 中的键值对。每个 db 的结构为：
  - `SELECTDB` 标记 + 数据库编号
  - `RESIZEDB` 标记 + db 大小 + 过期键数量
  - 键值对序列：每个键值对包含过期时间（可选）、值类型、键、值
- **EOF**：1 字节的文件结束标记，值为 0xFF
- **checksum**：8 字节的 CRC64 校验和，覆盖文件的所有前述内容

RDB 文件默认启用 LZF 压缩算法对字符串值进行压缩，可以通过 `rdbcompression` 配置项控制。


# 6 RDB 在主从复制中的作用

RDB 不仅用于持久化，还在 Redis 主从复制中扮演着关键角色。

**全量同步（Full Resynchronization）** 时，master 节点的操作流程为：

1. master 执行 `BGSAVE`，fork 子进程生成当前数据的 RDB 文件
2. 在生成 RDB 文件期间，master 将新收到的写命令缓存到**复制缓冲区**（replication buffer）
3. RDB 文件生成完毕后，master 将 RDB 文件通过网络发送给 slave
4. slave 接收到 RDB 文件后，清空旧数据，加载 RDB 文件恢复数据
5. master 再将复制缓冲区中的增量命令发送给 slave 执行

可以看出，RDB 文件是全量同步的核心载体。如果 RDB 文件过大，全量同步会消耗大量网络带宽和时间，这也是大内存 Redis 实例
在主从切换时恢复较慢的原因之一。

此外，**无盘复制**（diskless replication，通过 `repl-diskless-sync yes` 配置）允许 master 直接将 RDB 数据通过 socket 流式
传输给 slave，而不先写入磁盘，适用于磁盘慢但网络快的场景。


# 7 RDB 文件校验与修复

Redis 在生成 RDB 文件时会计算 CRC64 校验和并写入文件末尾。加载 RDB 文件时，Redis 会重新计算数据的校验和并与文件中
记录的值进行比对，如果不匹配则拒绝加载并报错。

可以通过 `rdbchecksum` 配置项控制是否启用校验（默认 yes）。关闭校验可以将加载性能提升约 10%，但会降低数据安全性。

Redis 提供了 `redis-check-rdb` 工具来检查 RDB 文件是否损坏：

```bash
# 检查 RDB 文件完整性
redis-check-rdb dump.rdb
```

如果 RDB 文件损坏，该工具会报告具体的错误位置。但与 AOF 不同，RDB 是二进制格式，损坏后通常无法修复，
只能使用备份或 AOF 文件来恢复数据。这也是为什么生产环境建议同时开启 RDB 和 AOF 的原因之一。


# 8 RDB 相关配置汇总

```
# 自动触发 BGSAVE 的规则（可配置多条，满足任一即触发）
# 格式：save <seconds> <changes>
save 900 1       # 900 秒内至少 1 次写操作
save 300 10      # 300 秒内至少 10 次写操作
save 60 10000    # 60 秒内至少 10000 次写操作
# 如果要禁用自动 RDB，设置为：save ""

# RDB 文件名，默认 dump.rdb
dbfilename dump.rdb

# RDB 文件存放目录，默认当前目录
dir ./

# BGSAVE 出错时是否停止接受写操作，默认 yes
# 这是一个重要的安全机制：如果 RDB 持久化失败（如磁盘满），Redis 会拒绝写入以提醒运维人员
stop-writes-on-bgsave-error yes

# 是否启用 LZF 压缩，默认 yes
# 压缩会消耗少量 CPU，但可以显著减小 RDB 文件大小
rdbcompression yes

# 是否在 RDB 文件末尾写入 CRC64 校验和，默认 yes
rdbchecksum yes

# 删除没有持久化配置的实例中的 RDB 文件，默认 no（Redis 6.2+）
rdb-del-sync-files no
```

其中 `stop-writes-on-bgsave-error yes` 是一个容易被忽视但很重要的配置。当 BGSAVE 因磁盘空间不足等原因失败时，
Redis 会拒绝所有写命令（返回 MISCONF 错误），以此来通知运维人员持久化出了问题，避免在没有持久化保障的情况下继续写入数据。


# 9 RDB vs AOF 对比总结

| 对比维度 | RDB | AOF |
|---|---|---|
| **持久化内容** | 某一时刻的全量数据快照（二进制） | 所有写命令的追加日志（文本/RESP） |
| **文件大小** | 小（二进制压缩） | 大（即使重写后仍比 RDB 大） |
| **恢复速度** | 快（直接加载二进制数据） | 慢（逐条回放命令） |
| **数据安全性** | 低（两次快照之间的数据可能丢失） | 高（最多丢失 1 秒数据，everysec 模式） |
| **对性能的影响** | fork 时短暂阻塞，之后无影响 | always 模式影响较大，everysec 模式影响小 |
| **文件可读性** | 不可读（二进制格式） | 可读（RESP 文本协议） |
| **适用场景** | 备份、灾难恢复、主从全量同步 | 数据安全性要求高的场景 |
| **Redis 重启加载优先级** | 低（AOF 开启时优先加载 AOF） | 高（优先于 RDB） |

**生产环境建议**：同时开启 RDB 和 AOF，并启用混合持久化（`aof-use-rdb-preamble yes`）。
这样既能通过 RDB 实现快速恢复和高效备份，又能通过 AOF 保证数据安全性，是目前最推荐的持久化方案。