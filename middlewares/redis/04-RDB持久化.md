
---
内存快照：宕机后， Redis 如何实现快速恢复？
---

我们知道，Redis 要避免数据丢失可以采用 AOF 日志进行持久化。这个⽅法的好
处，是每次执⾏只需要记录操作命令，需要持久化的数据量不⼤。⼀般⽽⾔，只要你
采⽤的不是 always 的持久化策略，就不会对性能造成太⼤影响。

但是，也正因为记录的是操作命令，⽽不是实际的数据，所以，⽤ AOF
⽅法进⾏故障恢复的时候，需要逐⼀把操作⽇志都执⾏⼀遍。如果操作
⽇志⾮常多， Redis 就会恢复得很缓慢，影响到正常使⽤。这当然不是理
想的结果。那么，还有没有既可以保证可靠性，还能在宕机时实现快速
恢复的其他⽅法呢？

当然有了，这就是我们要介绍另⼀种持久化⽅法： 内存快
照。所谓内存快照，就是指内存中的数据在某⼀个时刻的状态记录。这
就类似于照⽚，当你给朋友拍照时，⼀张照⽚就能把朋友⼀瞬间的形象
完全记下来。

对 Redis 来说，它实现类似照⽚记录效果的⽅式，就是把某⼀时刻的状
态以⽂件的形式写到磁盘上，也就是快照。这样⼀来，即使宕机，快照
⽂件也不会丢失，数据的可靠性也就得到了保证。这个快照⽂件就称为
RDB ⽂件，其中， RDB 就是 Redis DataBase 的缩写。

和 AOF 相⽐， RDB 记录的是某⼀时刻的数据，并不是操作，所以，在做
数据恢复时，我们可以直接把 RDB ⽂件读⼊内存，很快地完成恢复。听
起来好像很不错，但内存快照也并不是最优选项。为什么这么说呢？

我们还要考虑两个关键问题：

• 对哪些数据做快照？这关系到快照的执⾏效率问题；
• 做快照时，数据还能被增删改吗？这关系到 Redis 是否被阻塞，能
否同时正常处理请求。

这么说可能不太好理解，我们还是拿拍照⽚来举例⼦。我们在拍照
时，通常要关注两个问题：

• 如何取景？也就是说，我们打算把哪些⼈、哪些物拍到照⽚中；
• 在按快⻔前，要记着提醒朋友不要乱动，否则拍出来的照⽚就模糊了。


你看，这两个问题是不是⾮常重要呢？那么，接下来，我们就来具体地
聊⼀聊。先说“取景”问题，也就是我们对哪些数据做快照。


# 1 给哪些内存数据做快照？

Redis 的数据都在内存中，为了提供所有数据的可靠性保证，它执⾏的是
全量快照，也就是说，把内存中的所有数据都记录到磁盘中，这就类似于
给 100 个⼈拍合影，把每⼀个⼈都拍进照⽚⾥。这样做的好处是，⼀
次性记录了所有数据，⼀个都不少。

当你给⼀个⼈拍照时，只⽤协调⼀个⼈就够了，但是，拍 100 ⼈的⼤合
影，却需要协调 100 个⼈的位置、状态，等等，这当然会更费时费⼒。
同样，给内存的全量数据做快照，把它们全部写⼊磁盘也会花费很多时
间。⽽且，全量数据越多， RDB ⽂件就越⼤，往磁盘上写数据的时间开
销就越⼤。

对于 Redis ⽽⾔，它的单线程模型就决定了，我们要尽量避免所有会阻
塞主线程的操作，所以，针对任何操作，我们都会提⼀个灵魂之问：“它
会阻塞主线程吗?”RDB ⽂件的⽣成是否会阻塞主线程，这就关系到是否
会降低 Redis 的性能。

Redis 提供了两个命令来⽣成 RDB ⽂件，分别是 save 和 bgsave。

• save：在主线程中执⾏，会导致阻塞；
• bgsave：创建⼀个⼦进程，专⻔⽤于写⼊ RDB ⽂件，避免了主线
程的阻塞，这也是 Redis RDB ⽂件⽣成的默认配置。

好了，这个时候，我们就可以通过 bgsave 命令来执⾏全量快照，这既提
供了数据的可靠性保证，也避免了对 Redis 的性能影响。

接下来，我们要关注的问题就是，在对内存数据做快照时，这些数据还
能“动”吗? 也就是说，这些数据还能被修改吗？ 这个问题⾮常重要，这
是因为，如果数据能被修改，那就意味着 Redis 还能正常处理写操作。
否则，所有写操作都得等到快照完了才能执⾏，性能⼀下⼦就降低了。

# 2 快照时数据能修改吗?

在给别⼈拍照时，⼀旦对⽅动了，那么这张照⽚就拍糊了，我们就需要
重拍，所以我们当然希望对⽅保持不动。对于内存快照⽽⾔，我们也不
希望数据“动”。

举个例⼦。我们在时刻 t 给内存做快照，假设内存数据量是 4GB，磁盘
的写⼊带宽是 0.2GB/s，简单来说，⾄少需要 20s（4/0.2 = 20）才能
做完。如果在时刻 t+5s 时，⼀个还没有被写⼊磁盘的内存数据 A，被修
改成了 A’，那么就会破坏快照的完整性，因为 A’不是时刻 t 时的状态。
因此，和拍照类似，我们在做快照时也不希望数据“动”，也就是不能被
修改。

但是，如果快照执⾏期间数据不能被修改，是会有潜在问题的。对于刚
刚的例⼦来说，在做快照的 20s 时间⾥，如果这 4GB 的数据都不能被修
改， Redis 就不能处理对这些数据的写操作，那⽆疑就会给业务服务造成
巨⼤的影响。

你可能会想到，可以⽤ bgsave 避免阻塞啊。这⾥我就要说到⼀个常⻅的
误区了， 避免阻塞和正常处理写操作并不是⼀回事。此时，主线程的确
没有阻塞，可以正常接收请求，但是，为了保证快照完整性，它只能处
理读操作，因为不能修改正在执⾏快照的数据。

为了快照⽽暂停写操作，肯定是不能接受的。所以这个时候， Redis 就会
借助操作系统提供的写时复制技术（Copy-On-Write, COW），在执⾏
快照的同时，正常处理写操作。

简单来说， bgsave ⼦进程是由主线程 fork ⽣成的， 可以共享主线程的所
有内存数据。 bgsave ⼦进程运⾏后，开始读取主线程的内存数据，并把
它们写⼊ RDB ⽂件。

此时，如果主线程对这些数据也都是读操作（例如图中的键值对 A），那
么，主线程和 bgsave ⼦进程相互不影响。但是，如果主线程要修改⼀块
数据（例如图中的键值对 C），那么，这块数据就会被复制⼀份，⽣成
该数据的副本。然后， bgsave ⼦进程会把这个副本数据写⼊ RDB ⽂
件，⽽在这个过程中，主线程仍然可以直接修改原来的数据。





![rdb-process.png](images%2Frdb-process.png)





这既保证了快照的完整性，也允许主线程同时对数据进⾏修改，避免了
对正常业务的影响。

到这⾥，我们就解决了对“哪些数据做快照”以及“做快照时数据能否修
改”这两⼤问题： Redis 会使⽤ bgsave 对当前内存中的所有数据做快
照，这个操作是⼦进程在后台完成的，通过写时复制技术允许主线程同时可以修改数
据。

现在，我们再来看另⼀个问题：多久做⼀次快照？我们在拍照的时候，
还有项技术叫“连拍”，可以记录⼈或物连续多个瞬间的状态。那么，快
照也适合“连拍”吗？


# 3 快照执行的频率

对于快照来说，所谓“连拍”就是指连续地做快照。这样⼀来，快照的间
隔时间变得很短，即使某⼀时刻发⽣宕机了，因为上⼀时刻快照刚执
⾏，丢失的数据也不会太多。但是，这其中的快照间隔时间就很关键
了。

比如，我们先在 T0 时刻做了⼀次快照，然后⼜在 T0+t 时刻做了
⼀次快照，在这期间，数据块 5 和 9 被修改了。如果在 t 这段时间内，
机器宕机了，那么，只能按照 T0 时刻的快照进⾏恢复。此时，数据块 5
和 9 的修改值因为没有快照记录，就⽆法恢复了。

所以，要想尽可能恢复数据， t 值就要尽可能⼩， t 越⼩，就越像“连
拍”。那么， t 值可以⼩到什么程度呢，⽐如说是不是可以每秒做⼀次快
照？毕竟，每次快照都是由 bgsave ⼦进程在后台执⾏，也不会阻塞主线程。

这种想法其实是错误的。虽然 bgsave 执⾏时不阻塞主线程，但是， 如果
频繁地执⾏全量快照，也会带来两⽅⾯的开销。

⼀⽅⾯，频繁将全量数据写⼊磁盘，会给磁盘带来很⼤压⼒，多个快照
竞争有限的磁盘带宽，前⼀个快照还没有做完，后⼀个⼜开始做了，容
易造成恶性循环。

另⼀⽅⾯， bgsave ⼦进程需要通过 fork 操作从主线程创建出来。虽然，
⼦进程在创建后不会再阻塞主线程，但是， fork 这个创建过程本身会阻
塞主线程，⽽且主线程的内存越⼤，阻塞时间越⻓。如果频繁 fork 出
bgsave ⼦进程，这就会频繁阻塞主线程了。那么，有什么其他好⽅法
吗？

此时，我们可以做增量快照，所谓增量快照，就是指，做了⼀次全量快
照后，后续的快照只对修改的数据进⾏快照记录，这样可以避免每次全
量快照的开销。

在第⼀次做完全量快照后， T1 和 T2 时刻如果再做快照，我们只需要将
被修改的数据写⼊快照⽂件就⾏。但是，这么做的前提是， 我们需要记
住哪些数据被修改了。你可不要⼩瞧这个“记住”功能，它需要我们使⽤
额外的元数据信息去记录哪些数据被修改了，这会带来额外的空间开销
问题。如下图所示：





![rdb-enhance.png](images%2Frdb-enhance.png)





如果我们对每⼀个键值对的修改，都做个记录，那么，如果有 1 万个被修
改的键值对，我们就需要有 1 万条额外的记录。⽽且，有的时候，键值对
⾮常⼩，⽐如只有 32 字节，⽽记录它被修改的元数据信息，可能就需要
8 字节，这样的画，为了“记住”修改，引⼊的额外空间开销⽐较⼤。这
对于内存资源宝贵的 Redis 来说，有些得不偿失。


到这⾥，你可以发现，虽然跟 AOF 相⽐，快照的恢复速度快，但是，快
照的频率不好把握，如果频率太低，两次快照间⼀旦宕机，就可能有⽐
较多的数据丢失。如果频率太⾼，⼜会产⽣额外开销，那么，还有什么
⽅法既能利⽤ RDB 的快速恢复，⼜能以较⼩的开销做到尽量少丢数据
呢？

# 4 混合持久化策略

Redis 4.0 中提出了⼀个混合使⽤ AOF ⽇志和内存快照的⽅法。简单来
说，内存快照以⼀定的频率执⾏，在两次快照之间，使⽤ AOF ⽇志记录
这期间的所有命令操作。

这样⼀来，快照不⽤很频繁地执⾏，这就避免了频繁 fork 对主线程的影
响。⽽且， AOF ⽇志也只⽤记录两次快照间的操作，也就是说，不需要
记录所有操作了，因此，就不会出现⽂件过⼤的情况了，也可以避免重
写开销。

如下图所示， T1 和 T2 时刻的修改，⽤ AOF ⽇志记录，等到第⼆次做全
量快照时，就可以清空 AOF ⽇志，因为此时的修改都已经记录到快照中
了，恢复时就不再⽤⽇志了。






![mixed-persistence.png](images%2Fmixed-persistence.png)





这个⽅法既能享受到 RDB ⽂件快速恢复的好处，⼜能享受到 AOF 只记
录操作命令的简单优势，颇有点“⻥和熊掌可以兼得”的感觉，建议你在
实践中⽤起来。


## 4.1 如何开启混合持久化？

默认情况：Redis 4.0 默认不开启混合持久化。需要手动配置才能启用。
配置选项：
修改 Redis 配置文件 redis.conf，启用混合持久化的参数是：

```shell
aof-use-rdb-preamble yes
```

yes：开启混合持久化。
no：仅使用纯 AOF 持久化。


你也可以通过 Redis CLI 动态修改配置：

```shell
CONFIG SET aof-use-rdb-preamble yes
```

内存快照（RDB）的执行频率由配置文件中的 save 参数控制，例如：

```shell
save 900 1  # 900秒（15分钟）内有至少1个写操作时执行快照
save 300 10 # 300秒（5分钟）内有至少10个写操作时执行快照
save 60 10000 # 60秒内有至少10000个写操作时执行快照
```

可以根据业务场景调整快照频率，以平衡性能和数据持久化的可靠性。

混合持久化配置示例

```shell
# 启用混合持久化
aof-use-rdb-preamble yes

# 快照频率
save 900 1
save 300 10
save 60 10000

# AOF 持久化模式（推荐使用 always 或 everysec）
appendonly yes
appendfsync everysec
```

## 4.2 混合持久化机制具体如何实现？

(1) 快照作为基础
在持久化时，Redis 会先将当前内存中的所有数据保存为一个 RDB 快照。
这个快照反映了执行持久化时的完整数据状态。

(2) AOF 记录增量命令
在 RDB 快照生成的同时，Redis 会继续记录在此快照基础上产生的增量命令（写操作）。
增量命令以 AOF 格式附加在快照之后，形成一个文件：

```css
[RDB快照数据] + [增量AOF日志命令]
```

(3) 文件恢复时的顺序
在服务器重启时：
首先加载 RDB 部分的快照数据。
然后从 AOF 部分回放增量命令，恢复到最新状态。

(4) 如何实现两者结合
混合持久化的文件格式和流程：
在内存快照阶段，数据被序列化为 RDB 格式并写入持久化文件。
在快照之后的命令操作被以 AOF 格式记录下来。
整个文件在磁盘上是一个二进制文件，前半部分是 RDB，后半部分是 AOF。