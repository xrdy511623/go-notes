
---
Linux磁盘I/O是怎么工作的？
---

# 1 磁盘

磁盘是可以持久化存储的设备，根据存储介质的不同，常见磁盘可以分为两类：机械磁盘和固态磁盘。
第一类，机械磁盘，也称为硬盘驱动器（Hard Disk Driver），通常缩写为 HDD。机械磁盘主要由盘片和读写磁头组成，数据就
存储在盘片的环状磁道中。在读写数据前，需要移动读写磁头，定位到数据所在的磁道，然后才能访问数据。

显然，如果 I/O 请求刚好连续，那就不需要磁道寻址，自然可以获得最佳性能。这其实就是我们熟悉的，连续 I/O 的工作原理。
与之相对应的，当然就是随机 I/O，它需要不停地移动磁头，来定位数据位置，所以读写速度就会比较慢。

第二类，固态磁盘（Solid State Disk），通常缩写为 SSD，由固态电子元器件组成。固态磁盘不需要磁道寻址，所以，
不管是连续 I/O，还是随机 I/O 的性能，都比机械磁盘要好得多。

其实，无论机械磁盘，还是固态磁盘，相同磁盘的随机 I/O 都要比连续 I/O 慢很多，原因也很明显。
对机械磁盘来说，我们刚刚提到过的，由于随机 I/O 需要更多的磁头寻道和盘片旋转，它的性能自然要比连续 I/O 慢。
而对固态磁盘来说，虽然它的随机性能比机械硬盘好很多，但同样存在“先擦除再写入”的限制。随机读写会导致大量的垃圾回收，
所以相对应的，随机 I/O 的性能比起连续 I/O 来，也还是差了很多。

**随机写入和垃圾回收**

> SSD的基本工作原理

存储单元：SSD使用NAND闪存芯片存储数据，这些芯片由多个块（Block）组成，每个块又由多个页（Page）组成。典型的块大小为128KB到256KB，
每个页大小为4KB到8KB。
写入操作：SSD的写入操作只能在空白（即已经擦除）的页上进行。如果需要写入的数据位置已经被使用，则必须先擦除才能写入。
擦除操作：SSD的擦除操作只能在块级别进行，即一个块中的所有页必须一起擦除。单独擦除一页是不可行的。

> 随机写入和垃圾回收

随机写入的影响
> 先擦除再写入：当数据需要被写入到一个已经使用的页时，SSD必须先将这个页所在的整个块擦除，然后再写入新的数据。这意味着即使
只需要修改4KB的数据，也需要擦除并重写128KB到256KB的整个块。

> 写放大效应：由于必须擦除整个块，写入操作往往会涉及到比实际写入数据量更多的擦除和写入操作。这会导致所谓的“写放大效应”，
即实际写入到闪存的数据量大于主机请求写入的数据量。

> 垃圾回收

当SSD上的空闲空间耗尽或者变少时，垃圾回收机制会被触发：

> 识别无效数据：垃圾回收机制首先会识别出哪些数据块包含无效数据。这些无效数据是由于更新或删除操作产生的。
> 搬移有效数据：有效数据从含有无效数据的块中被复制到空闲块中。
> 擦除无效块：完成数据搬移后，原来地含有无效数据的块被擦除，变成空闲块供未来写入使用。

垃圾回收对性能的影响
写入放缓：在进行垃圾回收的过程中，SSD需要进行大量的读取、复制和擦除操作，这会导致写入操作速度明显下降。
寿命缩短：频繁地擦除和写入操作会加速NAND闪存芯片的磨损，从而缩短SSD的寿命。NAND闪存有有限地擦写周期（P/E cycle），
即每个块只能被擦除和写入一定次数。
延迟增加：垃圾回收会导致SSD的读写延迟增加，特别是在高负载的随机写入场景下，这种延迟会更明显。

**预读提升连续 I/O 性能**
此外，连续 I/O 还可以通过预读的方式，来减少 I/O 请求的次数，这也是其性能优异的一个原因。很多性能优化的方案，也都会从这个
角度出发，来优化 I/O 性能。

此外，机械磁盘和固态磁盘还分别有一个最小的读写单位。
机械磁盘的最小读写单位是扇区，一般大小为 512 字节。
而固态磁盘的最小读写单位是页，通常大小是 4KB、8KB 等。
但是，如果每次都读写 512 字节这么小的单位的话，效率很低。所以，文件系统会把连续的扇区或页，组成逻辑块，
然后以逻辑块作为最小单元来管理数据。常见的逻辑块的大小是 4KB，也就是说，连续 8 个扇区，或者单独的一个页，都可以组成一个逻辑块。

除了可以按照存储介质来分类，另一个常见的分类方法，是按照接口来分类，比如可以把硬盘分为 IDE（Integrated Drive Electronics）、
SCSI（Small Computer System Interface） 、SAS（Serial Attached SCSI） 、SATA（Serial ATA） 、FC（Fibre Channel）等。
不同的接口，往往分配不同的设备名称。比如， IDE 设备会分配一个 hd 前缀的设备名，SCSI 和 SATA 设备会分配一个 sd 前缀的设备名。
如果是多块同类型的磁盘，就会按照 a、b、c 等的字母顺序来编号。

除了磁盘本身的分类外，当你把磁盘接入服务器后，按照不同的使用方式，又可以把它们划分为多种不同的架构。
最简单的，就是直接作为独立磁盘设备来使用。这些磁盘，往往还会根据需要，划分为不同的逻辑分区，每个分区再用数字编号。比如我们前面多次
用到的 /dev/sda ，还可以分成两个分区 /dev/sda1 和 /dev/sda2。

另一个比较常用的架构，是把多块磁盘组合成一个逻辑磁盘，构成冗余独立磁盘阵列，也就是 RAID（Redundant Array of Independent Disks），
从而可以提高数据访问的性能，并且增强数据存储的可靠性。
根据容量、性能和可靠性需求的不同，RAID 一般可以划分为多个级别，如 RAID0、RAID1、RAID5、RAID10 等。

RAID0 有最优的读写性能，但不提供数据冗余的功能。
而其他级别的 RAID，在提供数据冗余的基础上，对读写性能也有一定程度的优化。

最后一种架构，是把这些磁盘组合成一个网络存储集群，再通过 NFS、SMB、iSCSI 等网络存储协议，暴露给服务器使用。
在 Linux 中，磁盘实际上是作为一个块设备来管理的，也就是以块为单位读写数据，并且支持随机读写。每个块设备都会被赋予
两个设备号，分别是主、次设备号。主设备号用在驱动程序中，用来区分设备类型；而次设备号则是用来给多个同类设备编号。


# 通用块层
跟虚拟文件系统 VFS 类似，为了减小不同块设备的差异带来的影响，Linux 通过一个统一的通用块层，来管理各种不同的块设备。

通用块层，其实是处在文件系统和磁盘驱动中间的一个块设备抽象层。它主要有两个功能 。
第一个功能跟虚拟文件系统的功能类似。向上，为文件系统和应用程序，提供访问块设备的标准接口；向下，把各种异构的磁盘设备抽象为
统一的块设备，并提供统一框架来管理这些设备的驱动程序。
第二个功能，通用块层还会给文件系统和应用程序发来的 I/O 请求排队，并通过重新排序、请求合并等方式，提高磁盘读写的效率。

其中，对 I/O 请求排序的过程，也就是我们熟悉的 I/O 调度。事实上，Linux 内核支持四种 I/O 调度算法，分别是 NONE、NOOP、
CFQ 以及 DeadLine。

第一种 NONE ，更确切来说，并不能算 I/O 调度算法。因为它完全不使用任何 I/O 调度器，对文件系统和应用程序的 I/O 其实不做
任何处理，常用在虚拟机中（此时磁盘 I/O 调度完全由物理机负责）。

第二种 NOOP ，是最简单的一种 I/O 调度算法。它实际上是一个先入先出的队列，只做一些最基本的请求合并，常用于 SSD 磁盘。

第三种 CFQ（Completely Fair Scheduler），也被称为完全公平调度器，是现在很多发行版的默认 I/O 调度器，它为每个进程维护
了一个 I/O 调度队列，并按照时间片来均匀分布每个进程的 I/O 请求。
类似于进程 CPU 调度，CFQ 还支持进程 I/O 的优先级调度，所以它适用于运行大量进程的系统，像是桌面环境、多媒体应用等。

最后一种 DeadLine 调度算法，分别为读、写请求创建了不同的 I/O 队列，可以提高机械磁盘的吞吐量，并确保达到最终期限（deadline）
的请求被优先处理。DeadLine 调度算法，多用在 I/O 压力比较重的场景，比如数据库等。


# I/O 栈

我们可以把 Linux 存储系统的 I/O 栈，由上到下分为三个层次，分别是文件系统层、通用块层和设备层。这三个 I/O 层的关系如
下图所示，这其实也是 Linux 存储系统的 I/O 栈全景图。





![io_stack.png](images%2Fio_stack.png)





根据这张 I/O 栈的全景图，我们可以更清楚地理解，存储系统 I/O 的工作原理。

文件系统层，包括虚拟文件系统和其他各种文件系统的具体实现。它为上层的应用程序，提供标准的文件访问接口；对下会通过通用块层，
来存储和管理磁盘数据。

通用块层，包括块设备 I/O 队列和 I/O 调度器。它会对文件系统的 I/O 请求进行排队，再通过重新排序和请求合并，然后才要发送给
下一级的设备层。

设备层，包括存储设备和相应的驱动程序，负责最终物理设备的 I/O 操作。

存储系统的 I/O ，通常是整个系统中最慢的一环。所以， Linux会通过多种缓存机制来优化 I/O 效率。
比方说，为了优化文件访问的性能，会使用页缓存、索引节点缓存、目录项缓存等多种缓存机制，以减少对下层块设备的直接调用。
同样，为了优化块设备的访问效率，会使用缓冲区，来缓存块设备的数据。

# 小结
我们梳理了 Linux 磁盘 I/O 的工作原理，并了解了由文件系统层、通用块层和设备层构成的 Linux 存储系统 I/O 栈。
其中，通用块层是 Linux 磁盘 I/O 的核心。向上，它为文件系统和应用程序，提供访问了块设备的标准接口；向下，把
各种异构的磁盘设备，抽象为统一的块设备，并会对文件系统和应用程序发来的 I/O 请求进行重新排序、请求合并等，
提高了磁盘访问的效率。


# 磁盘性能指标

说到磁盘性能的衡量标准，必须要提到五个常见指标，也就是我们经常用到的，使用率、饱和度、IOPS、吞吐量以及响应时间等。
这五个指标，是衡量磁盘性能的基本指标。

**使用率**
磁盘使用率通常表示磁盘的繁忙程度，也就是磁盘正在进行读/写操作的时间百分比。它可以理解为磁盘在一个时间段内的活动时间占比。
定义：磁盘使用率是磁盘正在进行 I/O 操作的时间占整个时间段的百分比。
测量单位：百分比（%）。
用途：主要用于衡量磁盘的繁忙程度，帮助了解磁盘是否处于高负载状态。
计算方式：通过监控磁盘的 I/O 操作时间与总时间的比值。例如，如果在一个监测周期内（如1秒），磁盘有0.7秒在处理 I/O 操作，
那么使用率就是70%。
用途:帮助了解磁盘是否处于高负载状态，是否需要扩展磁盘资源。

**饱和度**
磁盘饱和度则反映磁盘请求队列的拥挤程度，即磁盘在处理请求时是否能够及时完成。如果磁盘请求队列经常堆积，说明磁盘饱和度高，
磁盘已经无法及时处理所有的 I/O 请求。过高的饱和度，往往意味着磁盘存在严重的性能瓶颈。当饱和度为 100% 时，
磁盘无法接受新的 I/O 请求。

定义：磁盘饱和度是衡量磁盘 I/O 请求队列的拥挤程度，反映磁盘是否被 I/O 请求淹没。
测量单位：通常没有具体的单位，可以通过队列长度、平均等待时间等指标间接反映。
用途：用于判断磁盘是否成为系统瓶颈，磁盘是否能够及时响应 I/O 请求。
计算方式：通常通过监测 I/O 请求队列的长度、请求等待时间等指标。例如，如果请求队列长度持续超过磁盘的处理能力，就可以认为磁盘饱和度高。

**IOPS(Input/Output Operations Per Second)**
定义：IOPS 表示磁盘每秒可以处理的输入/输出操作次数。它是衡量存储设备处理能力的一个重要指标。
测量单位：操作次数/秒。

用途：
性能评估：用于评估存储设备在处理随机读写请求时的性能。
负载分析：帮助分析系统在高 I/O 负载下的表现。
规划和优化：用于存储系统的容量规划和性能优化。

计算方式：
IOPS = 每秒完成的读操作数 + 每秒完成的写操作数。

影响因素：
访问模式：随机访问和顺序访问的 IOPS 差异较大，通常顺序访问的 IOPS 更高。
请求大小：小块数据的 IOPS 通常比大块数据的 IOPS 高。
硬件性能：磁盘类型（如 HDD、SSD）、缓存大小、控制器性能等都会影响 IOPS。

IOPS（Input/Output Per Second），是指每秒的 I/O 请求数。

**吞吐量**
定义：吞吐量表示磁盘在单位时间内能够传输的数据量，它是衡量存储设备数据传输能力的一个重要指标。
测量单位：MB/s 或 GB/s。

用途：
数据传输能力：用于评估存储设备在传输大量数据时的性能。
系统瓶颈分析：帮助确定系统中是否存在 I/O 瓶颈。
性能对比：用于对比不同存储设备的传输性能。

计算方式：
吞吐量 = 每秒传输的数据块数 × 每块数据的大小。

影响因素：
数据块大小：大块数据的吞吐量通常比小块数据的吞吐量高。
访问模式：顺序访问的吞吐量通常比随机访问的吞吐量高。
硬件性能：磁盘类型、接口速度（如 SATA、SAS、NVMe）、缓存等都会影响吞吐量。

**响应时间**
定义：响应时间表示从发出 I/O 请求到收到响应所花费的时间。它是衡量存储设备响应速度的一个重要指标。
测量单位：毫秒（ms）。

用途：
用户体验：响应时间直接影响系统的响应速度和用户体验。
性能瓶颈分析：帮助识别系统中的性能瓶颈。
性能优化：用于优化存储系统的配置和性能。

计算方式：
响应时间 = 请求发出时间 - 请求完成时间。

影响因素：
I/O 队列长度：长队列会增加响应时间。
访问模式：随机访问的响应时间通常比顺序访问的响应时间长。
硬件性能：磁盘类型、控制器、缓存等会影响响应时间。
系统负载：高负载下的响应时间通常会增加。

这里要注意的是，使用率只考虑有没有 I/O，而不考虑 I/O 的大小。换句话说，当使用率是 100% 的时候，磁盘依然有可能接受新的 I/O 请求。
这些指标，很可能是你经常挂在嘴边的，一讨论磁盘性能必定提起的对象。不过我还是要强调一点，不要孤立地去比较某一指标，而要结合读写比例、
I/O 类型（随机还是连续）以及 I/O 的大小，综合来分析。

举个例子，在数据库、大量小文件等这类随机读写比较多的场景中，IOPS 更能反映系统的整体性能；而在多媒体等顺序读写较多的场景中，
吞吐量才更能反映系统的整体性能。

一般来说，我们在为应用程序的服务器选型时，要先对磁盘的 I/O 性能进行基准测试，以便可以准确评估，磁盘性能是否可以满足应用程序的需求。
这一方面，我推荐用性能测试工具 fio ，来测试磁盘的 IOPS、吞吐量以及响应时间等核心指标。但还是那句话，因地制宜，灵活选取。在基准测试时，
一定要注意根据应用程序 I/O 的特点，来具体评估指标。

当然，这就需要你测试出，不同 I/O 大小（一般是 512B 至 1MB 中间的若干值）分别在随机读、顺序读、随机写、顺序写等各种场景下的性能情况。
用性能工具得到的这些指标，可以作为后续分析应用程序性能的依据。一旦发生性能问题，你就可以把它们作为磁盘性能的极限值，进而评估磁盘 I/O 的使用情况。

了解磁盘的性能指标，只是我们 I/O 性能测试的第一步。接下来，又该用什么方法来观测它们呢?


# 磁盘 I/O 观测
第一个要观测的，是每块磁盘的使用情况。
iostat 是最常用的磁盘 I/O 性能观测工具，它提供了每个磁盘的使用率、IOPS、吞吐量等各种常见的性能指标，当然，这些指标实际上来自 /proc/diskstats。
iostat 的输出界面如下。





![iostat-demo.png](images%2Fiostat-demo.png)





从这里你可以看到，iostat 提供了非常丰富的性能指标。第一列的 Device 表示磁盘设备的名字，其他各列指标，虽然数量较多，但是每个指标的含义都很重要。





![iostat-exp.png](images%2Fiostat-exp.png)





这些指标中，你要注意：
%util ，就是我们前面提到的磁盘 I/O 使用率；
r/s+ w/s ，就是 IOPS；
rkB/s+wkB/s ，就是吞吐量；
r_await+w_await ，就是响应时间。
在观测指标时，也别忘了结合请求的大小（ rareq-sz 和 wareq-sz）一起分析。
你可能注意到，从 iostat 并不能直接得到磁盘饱和度。事实上，饱和度通常也没有其他简单的观测方法，不过，你可以把观测到的，
平均请求队列长度或者读写请求完成的等待时间，跟基准测试的结果（比如通过 fio）进行对比，综合评估磁盘的饱和情况。


# 进程 I/O 观测
除了每块磁盘的 I/O 情况，每个进程的 I/O 情况也是我们需要关注的重点。
上面提到的 iostat 只提供磁盘整体的 I/O 性能数据，缺点在于，并不能知道具体是哪些进程在进行磁盘读写。要观察进程的 I/O 情况，
你还可以使用 pidstat 和 iotop 这两个工具。
pidstat 加上 -d 参数，就可以看到进程的 I/O 情况，如下所示：

```shell
$ pidstat -d 1 
13:39:51      UID       PID   kB_rd/s   kB_wr/s kB_ccwr/s iodelay  Command 
13:39:52      102       916      0.00      4.00      0.00       0  rsyslogd

```

从 pidstat 的输出你能看到，它可以实时查看每个进程的 I/O 情况，包括下面这些内容。
用户 ID（UID）和进程 ID（PID） 。
每秒读取的数据大小（kB_rd/s） ，单位是 KB。
每秒发出的写请求数据大小（kB_wr/s） ，单位是 KB。
每秒取消的写请求数据大小（kB_ccwr/s） ，单位是 KB。
块 I/O 延迟（iodelay），包括等待同步块 I/O 和换入块 I/O 结束的时间，单位是时钟周期。

除了可以用 pidstat 实时查看，根据 I/O 大小对进程排序，也是性能分析中一个常用的方法。这一点，我推荐另一个工具， 
iotop。它是一个类似于 top 的工具，你可以按照 I/O 大小对进程排序，然后找到 I/O 较大的那些进程。
iotop 的输出如下所示：

```shell
$ iotop
Total DISK READ :       0.00 B/s | Total DISK WRITE :       7.85 K/s 
Actual DISK READ:       0.00 B/s | Actual DISK WRITE:       0.00 B/s 
  TID  PRIO  USER     DISK READ  DISK WRITE  SWAPIN     IO>    COMMAND 
15055 be/3 root        0.00 B/s    7.85 K/s  0.00 %  0.00 % systemd-journald 
```
从这个输出，你可以看到，前两行分别表示，进程的磁盘读写大小总数和磁盘真实的读写大小总数。因为缓存、缓冲区、I/O 合并
等因素的影响，它们可能并不相等。

剩下的部分，则是从各个角度来分别表示进程的 I/O 情况，包括线程 ID、I/O 优先级、每秒读磁盘的大小、每秒写磁盘的大小、
换入和等待 I/O 的时钟百分比等。
这两个工具，是我们分析磁盘 I/O 性能时最常用到的。