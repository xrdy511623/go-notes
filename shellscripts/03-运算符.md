
---
运算符
---

# 1 赋值运算符
> = 赋值运算符，用于为算数赋值和字符串赋值，使用unset取消为变量的赋值
> = 除了作为赋值运算符还可以作为测试操作符

# 2 算数运算符

> 基本运算符
+ - * / ** %

> 使用expr进行运算，只支持整数(运算符号左右两边有空格)
```shell
expr 4 + 5
```

> 数字变量的使用方法
let "变量名=变量值"
变量值使用0开头为八进制
变量值使用0x开头为十六进制

例如:
```shell
num1=`expr 4 + 5`
# 输出9
echo $num1
```

双圆括号是let命令的简化
```shell
((a=10))
# 输出10
echo $a

# 运算符号左右两边无空格
((a=4+5))
# 输出9 
echo $a 输出9
((a++))
# 输出10
echo $a
((a--))
# 输出9
echo $a 
# 输出30
echo $((10+20))
```

> 双圆括号可以用于算术运算
```shell
echo $((10+20))
```

> ()括号用于定义数组变量
```shell
arr=(ip1 ip2 ip3)
```

> [] 单独使用方括号通常用于测试条件。这种用法通常与条件语句结合使用，例如if语句或者while循环。
> 方括号内可以包含条件表达式，而表达式的结果会决定条件语句的执行。
> 在传统的shell中，方括号通常用于进行条件测试，这被称为“test”命令。例如：
```shell
if [ condition ]; then
    # do something
fi
```

> [[]] 双方括号通常被用于条件测试和字符串操作。相比于单方括号 []，双方括号提供了更多功能和更加灵活的条件判断。
一些用途包括：

**条件测试**
可以用于测试条件表达式的真假，类似于单方括号 []。但是双方括号提供了更多的条件测试功能，例如模式匹配、正则表达式匹配等。

```shell
if [[ $var == "value" ]]; then
    # do something
fi
```

**正则表达式匹配**

```shell
if [[ $string =~ regex ]]; then
    # do something
fi

```

**逻辑操作符**
双方括号支持逻辑操作符（例如 && 和 ||）来组合条件。
```shell
if [[ $var1 == "value1" && $var2 == "value2" ]]; then
    # do something
fi

```

> 单方括号与双方括号的比较

双方括号 "[[]]" 和单方括号 "[]" 都可以用于条件判断，但是它们的语法有一些区别：

双方括号 "[[]]" 是bash shell的内建特性，其提供了强大的字符串比较和模式匹配能力。例如，你可以使用“==”或 “!=” 
对符合某种模式的字符串进行条件判断。并且在"[[]]"里使用变量时，即使变量未定义或者为空，也不会报错。

双方括号 "[[]]" 允许 "&&" 和 "||" 等逻辑操作符的使用。
单方括号 "[]" 是旧式的标准Unix sh命令，在许多不同的shell环境中都可以使用。但是它的字符串比较功能较弱，并且
在处理变量时需要额外小心，比如变量为空或未被引用时可能产生错误。
单方括号 "[]" 只支持" -a " 和 " -o "作为和、或的逻辑运算符。
因此，在bash shell中，推荐使用双方括号 "[[]]"，尤其是在处理字符串或者变量存在空值的可能性时。而在编写需要
与多种不同shell环境兼容的脚本时，使用单方括号 "[]" 更为保险。


">" 是输出重定向操作符，用于将命令的标准输出（stdout）重定向到文件中。如果文件不存在，则会创建文件；
如果文件已存在，则会覆盖文件内容。

```shell
# 将命令 ls 的输出重定向到文件 list.txt
ls > list.txt
```

而">>"也是输出重定向操作符，不过它是将命令的输出追加到文件末尾
```shell
# 将命令 date 的输出追加到文件 log.txt 的末尾
date >> log.txt
```

> 在shell脚本中，花括号{}通常用于创建代码块，变量展开，以及生成序列等。以下是一些示例:

**创建代码块**
花括号可以用来创建代码块，用于定义函数或者在循环中使用。
```shell
{
    echo "This is inside a code block"
    # other commands...
}
```

**变量展开**
花括号也可以用于变量的展开，特别是当变量名后面跟着一些字符时，以区分变量名的结束。
```shell
name="John"
echo "${name}'s dog"  # 输出为 "John's dog"
```

**扩展序列**
花括号还可以用于生成数字序列，扩展字符串
```shell
echo {1..5}  # 输出为 "1 2 3 4 5"
echo {a..c}  # 输出为 "a b c"
```

**文件名扩展**
花括号还可以用于文件名扩展，以匹配指定的文件名模式。

```shell
touch file_{1..5}.txt  # 创建文件 file_1.txt, file_2.txt, ..., file_5.txt
```

**在变量名中使用花括号进行分隔**
在一些情况下，花括号可用于将变量名分隔开。

```shell
prefix="file_"
number=1
echo "${prefix}${number}.txt"  # 输出为 "file_1.txt"
# 文件复制的简化写法
# 原来的写法
cp -v /etc/passwd /etc/passwd.bak
# 简化写法, ,表示分隔目录
cp -v /etc/passwd{,.bak}
```

**比较运算符**
> 大于
< 小于
>= 大于等于
<= 小于等于

**逻辑符号**

&& 且
|| 或
! 非，也就是取反

**其他符号**
# 注释符号
; 命令分隔符 需要注意的是，case语句的分隔符要转义;;
: 空指令，常用于死循环中，用作占位符。
. 与source命令相同，用于执行shell脚本
~ 用户家目录
- cd - 回到上一次访问的目录
, 分隔目录
* 通配符，用于匹配零个或多个字符。当使用 * 时，它会匹配任何字符串，包括空字符串。
？条件测试和通配符，用于匹配任意单个字符。
$ 取值符号
| 管道符号 管道符前面命令的输出作为后面命令的输入来源

```shell
ps ef | grep mysql
```
& 用于将命令放置在后台运行，而不阻塞脚本的执行。这样可以使得脚本继续执行下一个命令或任务。
& 也可以用于将多个命令放置在同一行，并在后台依次执行这些命令。
```shell
# 将多个命令放置在同一行，并在后台依次执行这些命令
command1 & command2 & command3 &
cd Downloads & ls
```
_ 空格

